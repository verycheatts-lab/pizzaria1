<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    
    <!-- PWA Manifest -->
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#EA1D2C">

<!--   INSIRA ABAIXO AS TAGS DE SEO -->
<title>Cardápio da Pizzaria</title>


<!--   INSIRA ACIMA AS TAGS DE SEO -->

    <script src="env-config.js"></script>
    <script src="config.js"></script>
    <script>
        // Validação do sistema localStorage (essencial para funcionamento do carrinho)
        document.addEventListener('DOMContentLoaded', function() {
            setTimeout(() => {
                const functions = {
                    initializeStorageSystem,
                    saveCartToStorage,
                    loadCartFromStorage,
                    saveCouponToStorage
                };
                
                const missing = Object.entries(functions)
                    .filter(([name, fn]) => typeof fn !== 'function')
                    .map(([name]) => name);
                
                if (missing.length > 0) {
                    errorLog('❌ Funções localStorage não carregadas:', missing);
                    console.warn('⚠️ Carrinho pode não funcionar corretamente!');
                } else {
                    debugLog('✅ Sistema localStorage OK');
                }
            }, 500);
        });
    </script>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Supabase Client -->
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <script>
        // --- INÍCIO: Lógica PWA ---
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('/service-worker.js')
                    .then(registration => {
                        console.log('[PWA] Service Worker registrado com sucesso:', registration);
                    })
                    .catch(error => {
                        console.error('[PWA] Falha ao registrar Service Worker:', error);
                    });
            });
        }

        let deferredPrompt;
        window.addEventListener('beforeinstallprompt', (e) => {
            // Previne que o mini-infobar apareça no Chrome
            e.preventDefault();
            // Guarda o evento para que possa ser acionado mais tarde
            deferredPrompt = e;
            // Mostra o pop-up de instalação, a menos que o app já esteja instalado
            if (!isStandalone()) {
                showInstallPromotion();
            }
        });

        function isStandalone() {
            return window.matchMedia('(display-mode: standalone)').matches || window.navigator.standalone;
        }

        function showInstallPromotion() {
            const installPopup = document.getElementById('install-popup');
            if (installPopup && !isStandalone()) {
                installPopup.classList.remove('hidden');
            }
        }

        async function triggerInstallPrompt() {
            if (deferredPrompt) {
                deferredPrompt.prompt();
                deferredPrompt = null;
            }
            // Esconde o pop-up após o prompt ser exibido
            const installPopup = document.getElementById('install-popup');
            if (installPopup) {
                installPopup.classList.add('hidden');
            }
        }

        // Detecta quando o PWA foi instalado com sucesso
        window.addEventListener('appinstalled', (event) => {
            console.log('[PWA] App instalado com sucesso!');
            alert('App Pizzaria Solnascente Instalado com sucesso!');
        }, { once: true });
    </script>


    <!-- QR Code Library -->
    <script src="https://cdn.jsdelivr.net/npm/qrcode@1.4.4/build/qrcode.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap');
        
        /* ===== ANTI-FLASH: OCULTAR CONTEÚDO ATÉ CARREGAMENTO COMPLETO ===== */
        body {
            visibility: hidden;
        }
        
        body.loaded {
            visibility: visible;
        }
        
        /* Garantir que o preloader seja sempre visível */
        #preloader {
            visibility: visible !important;
        }
        
        /* Fallback: mostrar conteúdo após 10 segundos mesmo se JS falhar */
        body {
            animation: showContentFallback 0s 10s forwards;
        }
        
        @keyframes showContentFallback {
            to {
                visibility: visible;
            }
        }
        
        :root {
            /* ===== CORES PRINCIPAIS - ESTILO PIZZARIA (Vermelho, Verde, Bege) ===== */
            --cor-primaria: #D92B2B;           /* Vermelho tomate intenso, clássico de pizzaria */
            --cor-primaria-escura: #B92424;    /* Vermelho mais escuro para hover */
            --cor-secundaria: #228B22;         /* Verde manjericão, fresco e italiano */
            --cor-secundaria-escura: #1A691A;  /* Verde escuro para hover */
            --cor-terciaria: #FFC700;          /* Amarelo queijo para destaques */
            --cor-terciaria-escura: #E0A800;   /* Amarelo escuro para hover */
            --cor-accent: #FFC700;             /* Amarelo queijo para destaques */
            --cor-accent-escura: #E0A800;      /* Amarelo escuro */
            --cor-whatsapp: #25D366;           /* Verde WhatsApp */
            --cor-whatsapp-escura: #128C7E;    /* Verde WhatsApp escuro */
            
            /* ===== CORES DE FUNDO - MAIS CLEAN ===== */
            --cor-fundo: #F9F9F9;              /* Fundo cinza bem claro, moderno e limpo */
            --cor-fundo-branco: #FFFFFF;       /* Branco puro para cards */
            --cor-fundo-card: #FFFFFF;         /* Cards em branco puro */
            --cor-fundo-modal: rgba(0, 0, 0, 0.9); /* Fundo modal escuro */
            
            /* ===== CORES DE TEXTO - MELHOR CONTRASTE ===== */
            --cor-texto: #212121;              /* Preto suave para melhor leitura */
            --cor-texto-secundario: #555555;   /* Cinza escuro para textos de apoio */
            --cor-texto-claro: #9CA3AF;        /* Texto claro */
            --cor-texto-branco: #FFFFFF;       /* Texto branco */
            --cor-texto-destaque: #D92B2B;     /* Texto destaque vermelho */
            
            /* ===== CORES DE BORDA - MAIS SUAVES ===== */
            --cor-borda: #E5E7EB;              /* Borda padrão */
            --cor-borda-clara: #F3F4F6;        /* Borda clara */
            --cor-borda-escura: #D1D5DB;       /* Borda escura */
            --cor-borda-destaque: #D92B2B;     /* Borda destaque */
            
            /* ===== CORES DE ESTADO - FOOD FRIENDLY ===== */
            --cor-sucesso: #28a745;            /* Verde sucesso */
            --cor-sucesso-fundo: #E8F5E9;      /* Fundo verde claro */
            --cor-erro: #dc3545;               /* Vermelho erro */
            --cor-erro-fundo: #FFEBEE;         /* Fundo vermelho claro */
            --cor-aviso: #FFC700;              /* Amarelo aviso */
            --cor-aviso-fundo: #fff8e1;        /* Fundo amarelo claro */
            --cor-info: #2196F3;               /* Azul informação */
            --cor-info-fundo: #E3F2FD;         /* Fundo azul claro */
            
            /* ===== TRANSPARÊNCIAS - MAIS MODERNAS ===== */
            --transparencia-backdrop: rgba(255, 255, 255, 0.95); /* Backdrop blur */
            --transparencia-sombra: rgba(25, 25, 25, 0.08);       /* Sombra padrão mais sutil */
            --transparencia-sombra-forte: rgba(0, 0, 0, 0.12);    /* Sombra forte */
            --transparencia-hover: rgba(217, 43, 43, 0.08);       /* Hover com cor primária */
            --transparencia-whatsapp: rgba(37, 211, 102, 0.3);    /* Sombra WhatsApp */
            --transparencia-whatsapp-escura: rgba(18, 140, 126, 0.4); /* Sombra WhatsApp escura */
            --transparencia-primaria: rgba(217, 43, 43, 0.1);     /* Transparência primária */
            --transparencia-secundaria: rgba(34, 139, 34, 0.1);  /* Transparência secundária */
            
            /* ===== SOMBRAS - ESTILO iFOOD ===== */
            --sombra-card: 0 4px 12px rgba(25, 25, 25, 0.08);     /* Sombra card mais sutil */
            --sombra-card-hover: 0 8px 24px rgba(0, 0, 0, 0.12);  /* Sombra hover */
            --sombra-botao: 0 4px 16px rgba(217, 43, 43, 0.3);    /* Sombra botão com novo vermelho */
            --sombra-botao-hover: 0 6px 20px rgba(217, 43, 43, 0.4); /* Sombra botão hover */
            --sombra-modal: 0 20px 60px rgba(0, 0, 0, 0.5);       /* Sombra modal */
            --sombra-toast: 0 10px 25px rgba(0, 0, 0, 0.15);      /* Sombra toast */
            
            /* ===== GRADIENTES MODERNOS - ESTILO iFOOD ===== */
            --gradiente-primario: linear-gradient(135deg, #D92B2B 0%, #B92424 100%);     /* Gradiente vermelho */
            --gradiente-secundaria: linear-gradient(135deg, #228b22 0%, #1a6a1a 100%);   /* Gradiente verde */
            --gradiente-terciaria: linear-gradient(135deg, #f5deb3 0%, #e5cdaa 100%);    /* Gradiente bege */
            --gradiente-sucesso: linear-gradient(135deg, #28a745 0%, #218838 100%);      /* Verde sucesso */
            --gradiente-whatsapp: linear-gradient(135deg, #25D366 0%, #128C7E 100%);     /* WhatsApp */
            --gradiente-card: linear-gradient(135deg, #FFFFFF 0%, #FAFAFA 100%);         /* Card sutil */
            
            /* ===== GRADIENTES HOVER - MAIS INTENSOS ===== */
            --gradiente-primario-hover: linear-gradient(135deg, #B92424 0%, #D92B2B 100%);
            --gradiente-secundario-hover: linear-gradient(135deg, #1a6a1a 0%, #228b22 100%);
            --gradiente-sucesso-hover: linear-gradient(135deg, #218838 0%, #28a745 100%);
        }
        
        body { font-family: 'Inter', sans-serif; }
        
        /* ===== FIX SCROLL EM MODAIS MOBILE ===== */
        /* Prevenir scroll do body quando modal está aberto */
        body.modal-open {
            overflow: hidden;
            position: fixed;
            width: 100%;
            height: 100%;
        }
        
        /* Garantir scroll suave em modais mobile */
        [id$="-modal"] {
            -webkit-overflow-scrolling: touch;
            overscroll-behavior: contain;
        }
        
        /* Container scrollável dentro de modais */
        [id$="-modal"] .overflow-y-auto {
            -webkit-overflow-scrolling: touch;
            overscroll-behavior: contain;
            touch-action: pan-y;
        }
        
        .category-nav {
            backdrop-filter: blur(10px);
            background: rgba(255, 255, 255, 0.95);
            border-bottom: 1px solid var(--cor-borda);
        }
        
        /* Ajuste de posicionamento para mobile */
        @media (max-width: 768px) {
            .category-nav {
                top: 88px !important;
            }
        }
        
        /* Melhorar renderização no desktop */
        @media (min-width: 769px) {
            .category-nav {
                background: rgba(255, 255, 255, 0.98);
                backdrop-filter: blur(8px);
            }
        }
        
        /* Setas de navegação das categorias */
        .nav-arrow {
            transition: opacity 0.3s ease, transform 0.2s ease;
        }
        
        .nav-arrow:hover {
            transform: scale(1.05);
        }
        
        .nav-arrow:active {
            transform: scale(0.95);
        }
        
        /* Smooth scroll para o container das categorias */
        #category-nav {
            scroll-behavior: smooth;
        }
        
        /* Garantir que as setas fiquem fixas */
        #nav-arrow-left,
        #nav-arrow-right {
            flex-shrink: 0;
        }
        
        .category-item {
            transition: all 0.3s ease;
            white-space: nowrap;
        }
        
        /* Hide scrollbar for category navigation */
        .scrollbar-hide {
            -ms-overflow-style: none;  /* Internet Explorer 10+ */
            scrollbar-width: none;  /* Firefox */
        }
        
        .scrollbar-hide::-webkit-scrollbar {
            display: none;  /* Safari and Chrome */
        }
        
        .category-item.active {
            background: var(--cor-primaria);
            color: var(--cor-texto-branco);
        }
        
        /* Estilo específico para o botão de busca (lupa) */
        .search-button {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            min-width: 40px;
            height: 40px;
            padding: 0 12px;
            border-radius: 20px;
            border: 1px solid #cbd5e1;
            background: #f8fafc;
            color: #64748b;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            cursor: pointer;
        }
        
        .search-button:hover {
            background: #e2e8f0;
            border-color: #94a3b8;
            color: #475569;
        }
        
        .search-button:active {
            background: #cbd5e1;
        }
        
        /* Responsividade para o botão de busca */
        @media (max-width: 768px) {
            .search-button {
                min-width: 36px;
                height: 36px;
                padding: 0 10px;
            }
        }
        
        @media (max-width: 480px) {
            .search-button {
                min-width: 34px;
                height: 34px;
                padding: 0 8px;
            }
        }
        
        .food-card {
            transition: all 0.3s ease;
            cursor: pointer;
        }
        
        .food-card:hover {
            transform: translateY(-2px);
            box-shadow: var(--sombra-card);
        }
        
        .cart-fab {
            position: fixed;
            bottom: 30px;
            right: 20px;
            z-index: 1000;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            min-width: 160px;
            height: 64px;
            border-radius: 32px;
            box-shadow: 0 8px 25px var(--transparencia-whatsapp);
            backdrop-filter: blur(10px);
        }
        
        .cart-fab:hover {
            transform: scale(1.05);
            box-shadow: 0 12px 35px var(--transparencia-whatsapp-escura);
        }
        
        .modal-overlay {
            backdrop-filter: blur(5px);
        }
        
        .quantity-btn {
            transition: all 0.2s ease;
        }
        
        .quantity-btn:active {
            transform: scale(0.95);
        }
        
        .modal-footer {
            position: sticky;
            bottom: 0;
            background: var(--cor-fundo-branco);
            border-top: 1px solid var(--cor-borda);
            padding: 16px 20px;
            margin: 0 -24px -24px -24px;
            border-radius: 0 0 16px 16px;
            box-shadow: 0 -4px 6px -1px var(--transparencia-sombra);
            z-index: 10;
        }
        
        @media (max-width: 640px) {
            #header-slogan {
                font-size: 0.65rem !important;
            }
        }
        
        @media (max-width: 480px) {
            .modal-footer {
                padding: 16px 20px;
                margin: 0 -20px -20px -20px;
            }
        }
        
        .slide-up {
            animation: slideUp 0.3s ease-out;
        }
        
        @keyframes slideUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        /* ===== CUPOM EXPANSÍVEL - TRANSIÇÕES SUAVES ===== */
        .coupon-toggle-btn {
            transition: all 0.3s ease;
            cursor: pointer;
            user-select: none;
        }
        
        .coupon-toggle-btn:hover {
            background-color: var(--cor-fundo-card);
            transform: translateY(-1px);
            box-shadow: var(--sombra-card);
        }
        
        .coupon-toggle-btn:active {
            transform: translateY(0);
        }
        
        .coupon-field-container {
            max-height: 0;
            opacity: 0;
            overflow: hidden;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        .coupon-arrow {
            transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        .bounce {
            animation: bounce 0.6s ease;
        }
        
        @keyframes bounce {
            0%, 20%, 50%, 80%, 100% {
                transform: translateY(0);
            }
            40% {
                transform: translateY(-10px);
            }
            60% {
                transform: translateY(-5px);
            }
        }
        
        .shake {
            animation: shake 0.6s ease-in-out;
        }
        
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            10%, 30%, 50%, 70%, 90% { transform: translateX(-8px); }
            20%, 40%, 60%, 80% { transform: translateX(8px); }
        }
        
        .shake-animation {
            animation: shake 0.5s ease-in-out;
        }
        
        .field-error {
            border-color: var(--cor-erro) !important;
            background-color: var(--cor-erro-fundo) !important;
            box-shadow: 0 0 0 3px rgba(239, 68, 68, 0.2) !important;
            border-width: 2px !important;
        }
        
        .error-message {
            color: var(--cor-erro);
            font-size: 0.875rem;
            margin-top: 0.5rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-weight: 500;
            animation: slideDown 0.3s ease-out;
        }
        
        @keyframes slideDown {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        @keyframes gradientRotate {
            0% {
                background-position: 0% 50%, 0% 0%;
            }
            25% {
                background-position: 0% 50%, 100% 0%;
            }
            50% {
                background-position: 0% 50%, 100% 100%;
            }
            75% {
                background-position: 0% 50%, 0% 100%;
            }
            100% {
                background-position: 0% 50%, 0% 0%;
            }
        }
        
        @keyframes smoothSpin {
            0% {
                transform: rotate(0deg);
            }
            100% {
                transform: rotate(360deg);
            }
        }
        
        .toast {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 9999;
            max-width: 400px;
            width: 90%;
            padding: 16px 20px;
            border-radius: 12px;
            box-shadow: var(--sombra-toast);
            backdrop-filter: blur(10px);
            animation: toastSlideIn 0.4s ease-out;
        }
        
        .toast-error {
            background: var(--gradiente-primario);
            color: var(--cor-texto-branco);
            border: 1px solid rgba(255,255,255,0.2);
        }
        
        .toast-success {
            background: linear-gradient(135deg, var(--cor-primaria), var(--cor-secundaria)) !important;
            color: white !important;
            border: 1px solid rgba(255,255,255,0.2);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.2) !important;
        }
        
        /* Lightbox Styles */
        .lightbox {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: var(--cor-fundo-modal);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 9999;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
        }
        
        .lightbox.active {
            opacity: 1;
            visibility: visible;
        }
        
        .lightbox-content {
            position: relative;
            max-width: 90vw;
            max-height: 90vh;
            transform: scale(0.8);
            transition: transform 0.3s ease;
        }
        
        .lightbox.active .lightbox-content {
            transform: scale(1);
        }
        
        .lightbox-image {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
            border-radius: 8px;
        }
        
        .lightbox-close {
            position: absolute;
            top: -40px;
            right: 0;
            background: rgba(255, 255, 255, 0.9);
            border: none;
            border-radius: 50%;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 18px;
            font-weight: bold;
            color: var(--cor-texto);
            transition: all 0.2s ease;
        }
        
        .lightbox-close:hover {
            background: var(--cor-fundo-branco);
            transform: scale(1.1);
        }
        
        .lightbox-title {
            position: absolute;
            bottom: -40px;
            left: 0;
            right: 0;
            text-align: center;
            color: var(--cor-texto-branco);
            font-size: 16px;
            font-weight: 500;
        }
           
        
        .toast-warning {
            background: var(--gradiente-terciario);
            color: var(--cor-texto-branco);
            border: 1px solid rgba(255,255,255,0.2);
        }
        
        @keyframes toastSlideIn {
            from {
                opacity: 0;
                transform: translate(-50%, -20px);
            }
            to {
                opacity: 1;
                transform: translate(-50%, 0);
            }
        }
        
        .toast-exit {
            animation: toastSlideOut 0.3s ease-in forwards;
        }
        
        @keyframes toastSlideOut {
            to {
                opacity: 0;
                transform: translate(-50%, -20px);
            }
        }
        
        /* Lazy Loading Styles */
        .lazy-image {
            opacity: 0;
            transition: opacity 0.3s ease;
            image-rendering: auto;
            image-rendering: -webkit-optimize-contrast;
            -webkit-backface-visibility: hidden;
            backface-visibility: hidden;
        }
        
        .lazy-image.loaded {
            opacity: 1;
        }
        
        /* Melhor qualidade de imagem para food-cards */
        .food-card img {
            image-rendering: auto;
            image-rendering: -webkit-optimize-contrast;
            -webkit-backface-visibility: hidden;
            backface-visibility: hidden;
            -webkit-font-smoothing: antialiased;
            /* Filtros sutis para melhorar qualidade visual */
            filter: contrast(1.03) saturate(1.05);
            -webkit-filter: contrast(1.03) saturate(1.05);
        }
        
        /* Melhor qualidade de imagem para modal */
        #modal-content img {
            image-rendering: auto;
            image-rendering: -webkit-optimize-contrast;
            -webkit-backface-visibility: hidden;
            backface-visibility: hidden;
            object-fit: cover;
            object-position: center;
            -webkit-font-smoothing: antialiased;
            /* Filtros para melhorar nitidez e qualidade visual */
            filter: contrast(1.05) saturate(1.1) brightness(1.02);
            -webkit-filter: contrast(1.05) saturate(1.1) brightness(1.02);
        }
        
        @keyframes shimmer {
            0% {
                background-position: -200% 0;
            }
            100% {
                background-position: 200% 0;
            }
        }
        
        /* Checkout disabled styles */
        .checkout-disabled .add-to-cart-btn,
        .checkout-disabled .quantity-controls,
        .checkout-disabled .cart-fab,
        .checkout-disabled .cart-count,
        .checkout-disabled .add-btn,
        .checkout-disabled .modal-footer,
        .checkout-disabled .quantity-btn {
            display: none !important;
        }
        
        .checkout-disabled .food-card {
            cursor: default;
        }
        
        .checkout-disabled .food-card:hover {
            transform: none;
        }
        
        /* Animação pulse para badge de desconto */
        @keyframes pulse {
            0% {
                transform: scale(1);
                opacity: 1;
            }
            50% {
                transform: scale(1.05);
                opacity: 0.9;
            }
            100% {
                transform: scale(1);
                opacity: 1;
            }
        }

        /* Garantir que o seletor de idiomas fique abaixo dos modais */
        #gtranslate_wrapper,
        #gt_float_wrapper,
        #gt_float_wrapper .gt_float_switcher,
        #gt_float_wrapper .gt_switcher {
            z-index: 40 !important;
        }

        /* Estilos para o modal de rastreio */
        .status-step {
            transition: all 0.3s ease-in-out;
        }
        .status-step.active {
            transform: scale(1.05);
        }
        .status-line {
            transition: width 0.5s ease-in-out;
        }

        /* Estilos para o Pop-up de Instalação PWA */
        #install-popup {
            transition: opacity 0.3s ease, transform 0.3s ease;
        }
        #install-popup.hidden {
            opacity: 0;
            transform: translateY(20px);
            pointer-events: none;
        }
        .install-btn {
            background: var(--gradiente-primario);
        }
        .install-btn:hover {
            background: var(--gradiente-primario-hover);
        }


        .highlight-update {
            animation: pulse-bg 1.5s ease-out;
        }
        @keyframes pulse-bg { 0% { background-color: rgba(59, 130, 246, 0); } 50% { background-color: rgba(59, 130, 246, 0.15); } 100% { background-color: rgba(59, 130, 246, 0); } }

        /* Loading Overlay para Login/Logout */
        .auth-loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }
        .auth-loading-overlay.active {
            opacity: 1;
            visibility: visible;
        }
        .auth-loading-content {
            text-align: center;
            color: white;
        }
        .auth-loading-spinner {
            width: 60px;
            height: 60px;
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-top: 4px solid white;
            border-radius: 50%;
            animation: authSpin 1s linear infinite;
            margin: 0 auto 20px;
        }
        @keyframes authSpin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .auth-loading-text {
            font-size: 18px;
            font-weight: 600;
            animation: authPulse 1.5s ease-in-out infinite;
        }
        @keyframes authPulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        /* Animação para notificação de atualização de pedido */
        @keyframes slideInFromRight {
            from {
                opacity: 0;
                transform: translateX(100%);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }
        .animate-slide-in {
            animation: slideInFromRight 0.3s ease-out;
        }
     
    </style>

    <!-- Pop-up de Instalação PWA -->
    <div id="install-popup" class="hidden fixed bottom-4 right-4 max-w-sm bg-white rounded-xl shadow-2xl p-5 z-[1200]">
        <div class="flex items-start space-x-4">
            <img id="install-logo" src="" alt="Logo" class="w-12 h-12 rounded-lg flex-shrink-0" onerror="this.style.display='none'">
            <div class="flex-1">
                <h3 class="font-bold text-gray-800">Instale nosso App!</h3>
                <p class="text-sm text-gray-600 mt-1">Tenha acesso rápido ao nosso cardápio direto da sua tela inicial.</p>
                <div class="mt-4 flex space-x-3">
                    <button onclick="document.getElementById('install-popup').classList.add('hidden')" class="flex-1 text-sm py-2 px-4 rounded-lg bg-gray-200 text-gray-700 hover:bg-gray-300 transition-colors">Agora não</button>
                    <button onclick="triggerInstallPrompt()" class="install-btn flex-1 text-sm py-2 px-4 rounded-lg text-white font-semibold transition-transform hover:scale-105">Instalar</button>
                </div>
            </div>
        </div>
    </div>



  
</head>
<body style="background-color: var(--cor-fundo) !important;">

    <!-- Loading Overlay para Login/Logout -->
    <div id="auth-loading-overlay" class="auth-loading-overlay">
        <div class="auth-loading-content">
            <div class="auth-loading-spinner"></div>
            <div id="auth-loading-text" class="auth-loading-text">Processando...</div>
        </div>
    </div>
  
   
    <!-- Promotional Banner -->
    <div id="promo-banner" class="hidden w-full text-white text-sm font-medium text-center p-2.5 relative transition-all duration-500" style="background: var(--gradiente-primario);">
        <div class="max-w-4xl mx-auto flex items-center justify-center space-x-2 px-8">
            <span id="promo-icon" class="text-lg">🎉</span>
            <span id="promo-text" class="leading-tight"></span>
        </div>
        <button onclick="closePromoBanner()" class="absolute top-1/2 right-3 transform -translate-y-1/2 text-white/70 hover:text-white transition-colors" title="Fechar">
            <svg class="w-5 h-5" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg>
        </button>
    </div>
    
    <!-- Header -->
    <header class="bg-white shadow-sm sticky top-0 z-40">
        <div class="max-w-4xl mx-auto px-4 py-4">
            <div class="flex items-center justify-between">
                <div class="flex items-center space-x-3 cursor-pointer hover:opacity-80 transition-opacity" onclick="window.location.reload()" title="Recarregar página">
                    <img id="header-logo" src="" alt="Logo" class="object-cover rounded-lg cursor-pointer" style="display: none; width: 55px; height: 55px;" onerror="this.style.display='none'" onclick="event.stopPropagation(); clearStorageAndReload()" title="Clique para limpar cache e recarregar">
                    <div>
                        <h1 id="header-company-name" class="text-base sm:text-2xl font-bold" style="color: var(--cor-primaria) !important;">Pizzaria Sol Nascente</h1>
                        <p id="header-slogan" class="text-xs sm:text-base" style="color: var(--cor-texto) !important;" >A melhor pizza da cidade!</p>
                    </div>
                </div>
                <div class="flex items-center space-x-2 sm:space-x-3">
                    <!-- Botão Rastrear Pedido -->
                    <button onclick="openTrackingModal()" class="hidden sm:flex items-center space-x-2 px-3 py-2 rounded-lg text-sm font-medium transition-all duration-200" style="background-color: transparent; color: var(--cor-primaria); border: 1px solid var(--cor-primaria);" onmouseover="this.style.backgroundColor='var(--cor-primaria)'; this.style.color='white';" onmouseout="this.style.backgroundColor='transparent'; this.style.color='var(--cor-primaria)';" title="Rastrear seus pedidos">
                        <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 20l-5.447-2.724A1 1 0 013 16.382V5.618a1 1 0 011.447-.894L9 7m0 13l6-3m-6 3V7m6 10l5.447 2.724A1 1 0 0021 16.382V5.618a1 1 0 00-1.447-.894L15 7m-6 3l6-3"></path></svg>
                        <span>Rastrear Pedidos</span>
                    </button>

                    <!-- Botão Login/Cadastro/Perfil -->
                    <button id="auth-button-desktop" onclick="openAuthModal()" class="hidden sm:flex items-center space-x-2 px-3 py-2 rounded-lg text-sm font-medium transition-all duration-200" style="background-color: transparent; color: var(--cor-primaria); border: 1px solid var(--cor-primaria);" onmouseover="this.style.backgroundColor='var(--cor-primaria)'; this.style.color='white';" onmouseout="this.style.backgroundColor='transparent'; this.style.color='var(--cor-primaria)';" title="Entrar ou Cadastrar">
                        <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z"></path></svg>
                        <span>Entrar</span>
                    </button>

                    <div class="text-right cursor-pointer hover:bg-gray-50 p-2 rounded-lg transition-colors" onclick="openHoursModal()" id="hours-indicator" style="font-size: 0.85rem;">
                        <div class="flex items-center space-x-2">
                            <div class="font-medium" style="color: var(--cor-secundaria) !important;" id="status-text">Aberto</div>
                        </div>
                        <div style="color: var(--cor-texto) !important;" id="hours-text">até 23h</div>
                    </div>
                </div>
            </div>
        </div>
     
        <!-- Botões Mobile -->
        <div class="sm:hidden px-4 pb-3 space-y-2">
            <button onclick="openTrackingModal()" class="w-full flex items-center justify-center space-x-2 px-3 py-2.5 rounded-lg text-sm font-medium transition-all duration-200" style="background-color: transparent; color: var(--cor-primaria); border: 1px solid var(--cor-primaria);" onmouseover="this.style.backgroundColor='var(--cor-primaria)'; this.style.color='white';" onmouseout="this.style.backgroundColor='transparent'; this.style.color='var(--cor-primaria)';" title="Rastrear seus pedidos">
                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 20l-5.447-2.724A1 1 0 013 16.382V5.618a1 1 0 011.447-.894L9 7m0 13l6-3m-6 3V7m6 10l5.447 2.724A1 1 0 0021 16.382V5.618a1 1 0 00-1.447-.894L15 7m-6 3l6-3"></path></svg>
                <span>Rastrear Pedidos</span>
            </button>
            <button id="auth-button-mobile" onclick="openAuthModal()" class="w-full flex items-center justify-center space-x-2 px-3 py-2.5 rounded-lg text-sm font-medium transition-all duration-200" style="background-color: transparent; color: var(--cor-primaria); border: 1px solid var(--cor-primaria);" onmouseover="this.style.backgroundColor='var(--cor-primaria)'; this.style.color='white';" onmouseout="this.style.backgroundColor='transparent'; this.style.color='var(--cor-primaria)';" title="Entrar ou Cadastrar">
                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z"></path></svg>
                <span>Entrar / Cadastrar</span>
            </button>
        </div>
    </header>

    <!-- Categories Navigation -->
    <nav class="category-nav fixed top-[89px] left-0 right-0 z-30 bg-white" style="border-bottom: 1px solid var(--cor-borda) !important;">
        <div class="max-w-4xl mx-auto px-4 py-3">
            <div class="relative flex items-center">
                <!-- Seta Esquerda (Desktop apenas) -->
                <button id="nav-arrow-left" class="hidden md:flex items-center justify-center w-8 h-8 rounded-full bg-white shadow-md border border-gray-200 hover:bg-gray-50 transition-all duration-200 mr-2 z-10 nav-arrow" style="opacity: 0; pointer-events: none;">
                    <svg class="w-4 h-4 text-gray-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"></path>
                    </svg>
                </button>
                
                <!-- Container das categorias -->
                <div class="flex space-x-2 overflow-x-auto scrollbar-hide flex-1" id="category-nav">
                    <!-- Categories will be populated dynamically from CSV data -->
                </div>
                
                <!-- Seta Direita (Desktop apenas) -->
                <button id="nav-arrow-right" class="hidden md:flex items-center justify-center w-8 h-8 rounded-full bg-white shadow-md border border-gray-200 hover:bg-gray-50 transition-all duration-200 ml-2 z-10 nav-arrow">
                    <svg class="w-4 h-4 text-gray-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"></path>
                    </svg>
                </button>
            </div>
        </div>
    </nav>

    <!-- Menu Content -->
    <main class="max-w-4xl mx-auto px-4 py-6 pb-4 mt-[80px] sm:mt-[60px]">
        <!-- Search -->
        <div class="mb-6">
            <div class="relative" title="Busque pelo nome da pizza, ingrediente ou código (SKU)">
                <input type="text" id="search" placeholder="Buscar..." autocomplete="off" 
                       class="w-full pl-4 pr-20 py-3 rounded-lg focus:ring-2 focus:border-transparent" style="border: 1px solid var(--cor-borda) !important; --tw-ring-color: var(--cor-primaria) !important;">
                <div class="absolute right-2 top-2 flex space-x-2">
                    <button id="clear-search" onclick="clearSearch()" class="hidden rounded-full w-8 h-8 flex items-center justify-center transition-colors" style="background-color: var(--cor-fundo-secundario) !important; color: var(--cor-texto-secundario) !important;" title="Limpar busca" onmouseover="this.style.backgroundColor='var(--cor-borda)'" onmouseout="this.style.backgroundColor='var(--cor-fundo-secundario)'">
                        <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                        </svg>
                    </button>
                    <button id="search-btn" onclick="performSearch()" class="rounded-full w-8 h-8 flex items-center justify-center transition-colors" style="background-color: var(--cor-primaria) !important; color: white !important;" title="Pesquisar" onmouseover="this.style.backgroundColor='var(--cor-primaria-hover)'" onmouseout="this.style.backgroundColor='var(--cor-primaria)'">
                        <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"></path>
                        </svg>
                    </button>
                </div>
            </div>
        </div>

        <!-- Menu Sections -->
        <div id="menu-content">
            <!-- Sections will be populated here -->
        </div>
    </main>

    <!-- Google Review CTA -->
    <section id="google-reviews-section" class="py-12 mt-0" style="background: var(--cor-fundo) !important; display: none;">
        <div class="max-w-4xl mx-auto px-4 text-center">
            <div class="bg-white rounded-2xl p-8 shadow-xl">
                <div class="text-6xl mb-4">🍕</div>
                <h3 class="text-2xl font-bold mb-3" style="color: var(--cor-texto) !important;">Gostou da nossa pizza?</h3>
                <p class="mb-6" style="color: var(--cor-texto-secundario) !important;">Sua avaliação nos ajuda a melhorar e alcançar mais pessoas!</p>
                <a id="google-reviews-link" href="" target="_blank" 
                   class="inline-flex items-center space-x-2 px-8 py-4 rounded-full font-bold text-lg transition-all transform hover:scale-105 shadow-lg" style="background-color: var(--cor-secundaria) !important; color: white !important;" onmouseover="this.style.backgroundColor='var(--cor-terciaria-hover)'" onmouseout="this.style.backgroundColor='var(--cor-terciaria)'">
                    <span>⭐</span>
                    <span>Avaliar no Google</span>
                </a>
               
            </div>
        </div>
    </section>

    <!-- Footer -->
    <footer class="py-8" style="background-color: var(--cor-fundo) !important; border-top: 5px solid transparent !important; background-image: linear-gradient(var(--cor-fundo), var(--cor-fundo)), linear-gradient(45deg, var(--cor-primaria), var(--cor-secundaria), var(--cor-terciaria), var(--cor-secundaria), var(--cor-primaria)) !important; background-origin: border-box !important; background-clip: padding-box, border-box !important; background-size: 100% 100%, 400% 400% !important; box-shadow: 0 -4px 20px rgba(0, 0, 0, 0.08) !important; position: relative; overflow: hidden;">
        <div class="max-w-4xl mx-auto px-4">
            <!-- Main Info -->
            <div class="text-center mb-6">
                <div class="mb-3">
                    <h3 id="footer-company-name" class="text-2xl font-bold" style="color: var(--cor-texto) !important; font-weight: 700; text-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);">🍕 Pizzaria Fantástica</h3>
                </div>
                <p id="footer-address" class="mb-4 text-sm" style="color: var(--cor-texto-secundario) !important; font-weight: 500; opacity: 0.9;">Rua das Flores, 123 • Centro - Campinas/SP</p>
                
                <!-- Contact & Hours in compact format -->
                <div class="flex flex-wrap justify-center items-center gap-6 text-sm mb-6" style="color: var(--cor-texto-secundario) !important;">
                    <a id="footer-phone" href="" class="flex items-center space-x-2 transition-all duration-300" style="display: none; color: var(--cor-primaria) !important; text-decoration: none; font-weight: 500;" onmouseover="this.style.color='var(--cor-secundaria)'; this.style.transform='translateY(-2px)'" onmouseout="this.style.color='var(--cor-primaria)'; this.style.transform='translateY(0)'">
                        <svg class="w-5 h-5" fill="currentColor" viewBox="0 0 24 24" style="color: var(--cor-primaria) !important; transition: all 0.3s ease;">
                            <path d="M6.62,10.79C8.06,13.62 10.38,15.94 13.21,17.38L15.41,15.18C15.69,14.9 16.08,14.82 16.43,14.93C17.55,15.3 18.75,15.5 20,15.5A1,1 0 0,1 21,16.5V20A1,1 0 0,1 20,21A17,17 0 0,1 3,4A1,1 0 0,1 4,3H7.5A1,1 0 0,1 8.5,4C8.5,5.25 8.7,6.45 9.07,7.57C9.18,7.92 9.1,8.31 8.82,8.59L6.62,10.79Z"/>
                        </svg>
                        <span style="color: var(--cor-primaria) !important; transition: color 0.3s ease;"></span>
                    </a>

                    <div id="footer-email" class="cursor-pointer transition-all duration-300" style="display: none; color: var(--cor-primaria) !important;" onclick="window.location.href='mailto:' + this.dataset.email" title="Enviar email" onmouseover="this.style.color='var(--cor-secundaria)'; this.style.transform='translateY(-2px)'" onmouseout="this.style.color='var(--cor-primaria)'; this.style.transform='translateY(0)'">
                        <svg class="w-5 h-5" fill="currentColor" viewBox="0 0 24 24" style="color: var(--cor-primaria) !important; transition: all 0.3s ease;">
                            <path d="M20 4H4c-1.1 0-1.99.9-1.99 2L2 18c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm0 4l-8 5-8-5V6l8 5 8-5v2z"/>
                        </svg>
                    </div>
                    
                    <div id="footer-qrcode" class="cursor-pointer transition-all duration-300" style="color: var(--cor-primaria) !important;" onclick="openQRCodeModal()" title="Ver QR Code do cardápio" onmouseover="this.style.color='var(--cor-secundaria)'; this.style.transform='translateY(-2px)'" onmouseout="this.style.color='var(--cor-primaria)'; this.style.transform='translateY(0)'">
                        <svg class="w-5 h-5" fill="currentColor" viewBox="0 0 16 16" style="color: var(--cor-primaria) !important; transition: all 0.3s ease;">
                            <path d="M2 2h2v2H2z"/>
                            <path d="M6 0v6H0V0zM5 1H1v4h4zM4 12H2v2h2z"/>
                            <path d="M6 10v6H0v-6zm-5 1v4h4v-4zm11-9h2v2h-2z"/>
                            <path d="M10 0v6h6V0zm5 1v4h-4V1zM8 1V0h1v2H8v2H7V1zm0 5V4h1v2zM6 8V7h1V6h1v2h1V7h5v1h-4v1H7V8zm0 0v1H2V8H1v1H0V7h3v1zm10 1h-1V7h1zm-1 0h-1v2h2v-1h-1zm-4 0h2v1h-1v1h-1zm2 3v-1h-1v1h-1v1H9v1h3v-2zm0 0h3v1h-2v1h-1zm-4-1v1h1v-2H7v1z"/>
                            <path d="M7 12h1v3h4v1H7zm9 2v2h-3v-1h2v-1z"/>
                        </svg>
                    </div>
                    <!-- Indicador removido para evitar IDs duplicados -->
                    
                    <div class="flex items-center space-x-2 cursor-pointer transition-all duration-300" onclick="openHoursModal()" title="Ver horários de funcionamento" onmouseover="this.style.transform='translateY(-2px)'; this.querySelector('span').style.color='var(--cor-primaria)'" onmouseout="this.style.transform='translateY(0)'; this.querySelector('span').style.color='var(--cor-primaria)'">
                        <svg class="w-5 h-5" fill="currentColor" viewBox="0 0 24 24" style="color: var(--cor-primaria) !important; transition: all 0.3s ease;">
                            <path d="M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2M16.2,16.2L11,13V7H12.5V12.2L17,14.9L16.2,16.2Z"/>
                        </svg>
                        <span class="font-medium" style="color: var(--cor-primaria) !important; font-weight: 500; transition: color 0.3s ease; font-size: 0.9em;">Ver Horários</span>
                    </div>
                </div>
                
                <!-- Social Icons -->
                <div class="flex justify-center space-x-3">
                    <a id="footer-instagram" href="" target="_blank" style="display: none; background: linear-gradient(135deg, var(--cor-primaria), var(--cor-secundaria)); color: white; padding: 0.75rem; border-radius: 50%; transition: all 0.3s ease; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);" onmouseover="this.style.background='linear-gradient(135deg, var(--cor-secundaria), var(--cor-terciaria))'; this.style.transform='translateY(-3px) scale(1.05)'; this.style.boxShadow='0 8px 25px rgba(0, 0, 0, 0.2)'" onmouseout="this.style.background='linear-gradient(135deg, var(--cor-primaria), var(--cor-secundaria))'; this.style.transform='translateY(0) scale(1)'; this.style.boxShadow='0 4px 12px rgba(0, 0, 0, 0.15)'">
                        <svg class="w-5 h-5" fill="currentColor" viewBox="0 0 24 24" style="color: white;">
                            <path d="M12 2.163c3.204 0 3.584.012 4.85.07 3.252.148 4.771 1.691 4.919 4.919.058 1.265.069 1.645.069 4.849 0 3.205-.012 3.584-.069 4.849-.149 3.225-1.664 4.771-4.919 4.919-1.266.058-1.644.07-4.85.07-3.204 0-3.584-.012-4.849-.07-3.26-.149-4.771-1.699-4.919-4.92-.058-1.265-.07-1.644-.07-4.849 0-3.204.013-3.583.07-4.849.149-3.227 1.664-4.771 4.919-4.919 1.266-.057 1.645-.069 4.849-.069zm0-2.163c-3.259 0-3.667.014-4.947.072-4.358.2-6.78 2.618-6.98 6.98-.059 1.281-.073 1.689-.073 4.948 0 3.259.014 3.668.072 4.948.2 4.358 2.618 6.78 6.98 6.98 1.281.058 1.689.072 4.948.072 3.259 0 3.668-.014 4.948-.072 4.354-.2 6.782-2.618 6.979-6.98.059-1.28.073-1.689.073-4.948 0-3.259-.014-3.667-.072-4.947-.196-4.354-2.617-6.78-6.979-6.98-1.281-.059-1.69-.073-4.949-.073zm0 5.838c-3.403 0-6.162 2.759-6.162 6.162s2.759 6.163 6.162 6.163 6.162-2.759 6.162-6.163c0-3.403-2.759-6.162-6.162-6.162zm0 10.162c-2.209 0-4-1.79-4-4 0-2.209 1.791-4 4-4s4 1.791 4 4c0 2.21-1.791 4-4 4zm6.406-11.845c-.796 0-1.441.645-1.441 1.44s.645 1.44 1.441 1.44c.795 0 1.439-.645 1.439-1.40s-.644-1.44-1.439-1.44z"/>
                        </svg>
                    </a>
                    <a id="footer-facebook" href="" target="_blank" style="display: none; background: linear-gradient(135deg, var(--cor-primaria), var(--cor-secundaria)); color: white; padding: 0.75rem; border-radius: 50%; transition: all 0.3s ease; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);" onmouseover="this.style.background='linear-gradient(135deg, var(--cor-secundaria), var(--cor-terciaria))'; this.style.transform='translateY(-3px) scale(1.05)'; this.style.boxShadow='0 8px 25px rgba(0, 0, 0, 0.2)'" onmouseout="this.style.background='linear-gradient(135deg, var(--cor-primaria), var(--cor-secundaria))'; this.style.transform='translateY(0) scale(1)'; this.style.boxShadow='0 4px 12px rgba(0, 0, 0, 0.15)'">
                        <svg class="w-5 h-5" fill="currentColor" viewBox="0 0 24 24" style="color: white;">
                            <path d="M24 12.073c0-6.627-5.373-12-12-12s-12 5.373-12 12c0 5.99 4.388 10.954 10.125 11.854v-8.385H7.078v-3.47h3.047V9.43c0-3.007 1.792-4.669 4.533-4.669 1.312 0 2.686.235 2.686.235v2.953H15.83c-1.491 0-1.956.925-1.956 1.874v2.25h3.328l-.532 3.47h-2.796v8.385C19.612 23.027 24 18.062 24 12.073z"/>
                        </svg>
                    </a>
                    <a id="footer-whatsapp" href="" target="_blank" style="display: none; background: linear-gradient(135deg, var(--cor-primaria), var(--cor-secundaria)); color: white; padding: 0.75rem; border-radius: 50%; transition: all 0.3s ease; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);" onmouseover="this.style.background='linear-gradient(135deg, var(--cor-secundaria), var(--cor-terciaria))'; this.style.transform='translateY(-3px) scale(1.05)'; this.style.boxShadow='0 8px 25px rgba(0, 0, 0, 0.2)'" onmouseout="this.style.background='linear-gradient(135deg, var(--cor-primaria), var(--cor-secundaria))'; this.style.transform='translateY(0) scale(1)'; this.style.boxShadow='0 4px 12px rgba(0, 0, 0, 0.15)'">
                        <svg class="w-5 h-5" fill="currentColor" viewBox="0 0 24 24" style="color: white;">
                            <path d="M17.472 14.382c-.297-.149-1.758-.867-2.03-.967-.273-.099-.471-.148-.67.15-.197.297-.767.966-.94 1.164-.173.199-.347.223-.644.075-.297-.15-1.255-.463-2.39-1.475-.883-.788-1.48-1.761-1.653-2.059-.173-.297-.018-.458.13-.606.134-.133.298-.347.446-.52.149-.174.198-.298.298-.497.099-.198.05-.371-.025-.52-.075-.149-.669-1.612-.916-2.207-.242-.579-.487-.5-.669-.51-.173-.008-.371-.01-.57-.01-.198 0-.52.074-.792.372-.272.297-1.04 1.016-1.04 2.479 0 1.462 1.065 2.875 1.213 3.074.149.198 2.096 3.2 5.077 4.487.709.306 1.262.489 1.694.625.712.227 1.36.195 1.871.118.571-.085 1.758-.719 2.006-1.413.248-.694.248-1.289.173-1.413-.074-.124-.272-.198-.57-.347m-5.421 7.403h-.004a9.87 9.87 0 01-5.031-1.378l-.361-.214-3.741.982.998-3.648-.235-.374a9.86 9.86 0 01-1.51-5.26c.001-5.45 4.436-9.884 9.888-9.884 2.64 0 5.122 1.03 6.988 2.898a9.825 9.825 0 012.893 6.994c-.003 5.45-4.437 9.884-9.885 9.884m8.413-18.297A11.815 11.815 0 0012.05 0C5.495 0 .16 5.335.157 11.892c0 2.096.547 4.142 1.588 5.945L.057 24l6.305-1.654a11.882 11.882 0 005.683 1.448h.005c6.554 0 11.890-5.335 11.893-11.893A11.821 11.821 0 0020.893 3.488"/>
                        </svg>
                    </a>
                    <a id="footer-email-link" href="" style="display: none; background: linear-gradient(135deg, var(--cor-primaria), var(--cor-secundaria)); color: white; padding: 0.75rem; border-radius: 50%; transition: all 0.3s ease; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);" onmouseover="this.style.background='linear-gradient(135deg, var(--cor-secundaria), var(--cor-terciaria))'; this.style.transform='translateY(-3px) scale(1.05)'; this.style.boxShadow='0 8px 25px rgba(0, 0, 0, 0.2)'" onmouseout="this.style.background='linear-gradient(135deg, var(--cor-primaria), var(--cor-secundaria))'; this.style.transform='translateY(0) scale(1)'; this.style.boxShadow='0 4px 12px rgba(0, 0, 0, 0.15)'">
                        <svg class="w-5 h-5" fill="currentColor" viewBox="0 0 24 24" style="color: white;">
                            <path d="M20 4H4c-1.1 0-1.99.9-1.99 2L2 18c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm0 4l-8 5-8-5V6l8 5 8-5v2z"/>
                        </svg>
                    </a>
                    

                </div>
            </div>
            
            <!-- Versão do Aplicativo (discreto, abaixo dos ícones sociais) -->
            <div id="footer-app-version" class="text-center mt-2" style="color: var(--cor-texto-secundario) !important; opacity: 0.55; font-size: 0.65rem;">
                <span>Versão V4.0.6</span>
                
                <!-- <a href="#" onclick="openHelpModal(); return false;" title="Abrir atalhos (F1)" style="color: inherit; text-decoration: none;"
                   onmouseover="this.style.color='var(--cor-primaria)'; this.style.textDecoration='underline'"
                   onmouseout="this.style.color='var(--cor-texto-secundario)'; this.style.textDecoration='none'">
                    Atalhos
                </a> 
                <span aria-hidden="true" style="margin: 0 8px; opacity: 0.5;">•</span>
                <a href="#" onclick="clearStorageAndReload(); return false;" title="Limpar cache" style="color: inherit; text-decoration: none;"
                   onmouseover="this.style.color='var(--cor-primaria)'; this.style.textDecoration='underline'"
                   onmouseout="this.style.color='var(--cor-texto-secundario)'; this.style.textDecoration='none'">
                    Limpar cache
                </a>-->
            </div>

             <!-- Developer Credits -->
             <div id="footer-credits-container" class="border-t pt-6 text-center" style="border-color: rgba(200, 200, 200, 0.3) !important; margin-top: 2rem; padding-top: 1.5rem;">
                <p id="footer-credits" class="text-xs" style="color: var(--cor-texto-secundario) !important; font-weight: 300; opacity: 0.7; font-size: 0.75rem;">
                    <!-- Créditos serão preenchidos dinamicamente via CSV -->
                    Desenvolvido com <span style="color: #e74c3c; font-size: 0.8rem;">♥</span> por <a href="#" target="_blank" class="transition-all duration-300" style="color: var(--cor-primaria) !important; text-decoration: none; font-weight: 400; position: relative; font-size: 0.75rem;" onmouseover="this.style.color='var(--cor-secundaria)'; this.style.transform='translateY(-1px)'" onmouseout="this.style.color='var(--cor-primaria)'; this.style.transform='translateY(0)'">Carregando...</a> <span style="color: var(--cor-texto-secundario); opacity: 0.5; font-size: 0.7rem;">👨‍💻</span>
                </p>
                
       
            </div>
        </div>
    </footer>

    <!-- Share FAB -->
    <button id="share-fab" class="fixed left-4 text-white p-3 rounded-full shadow-lg z-50 transition-all duration-300" style="bottom: 92px; background: linear-gradient(135deg, var(--cor-primaria), var(--cor-secundaria)) !important; box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2) !important;" onclick="shareGeneral()" title="Compartilhar cardápio" onmouseover="this.style.background='linear-gradient(135deg, var(--cor-secundaria), var(--cor-primaria))'; this.style.transform='translateY(-2px)'; this.style.boxShadow='0 8px 25px rgba(0, 0, 0, 0.3)'; this.querySelector('svg').style.animation='smoothSpin 0.6s ease-in'" onmouseout="this.style.background='linear-gradient(135deg, var(--cor-primaria), var(--cor-secundaria))'; this.style.transform='translateY(0)'; this.style.boxShadow='0 4px 15px rgba(0, 0, 0, 0.2)'; this.querySelector('svg').style.animation='none'">
        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" style="transition: all 0.3s ease;">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8.684 13.342C8.886 12.938 9 12.482 9 12c0-.482-.114-.938-.316-1.342m0 2.684a3 3 0 110-2.684m0 2.684l6.632 3.316m-6.632-6l6.632-3.316m0 0a3 3 0 105.367-2.684 3 3 0 00-5.367 2.684zm0 9.316a3 3 0 105.367 2.684 3 3 0 00-5.367-2.684z"></path>
        </svg>
    </button>

    <!-- Cart FAB -->
    <button id="cart-fab" class="cart-fab text-white shadow-lg hidden" style="background-color: var(--cor-whatsapp) !important;" onclick="openCart()" onmouseover="this.style.backgroundColor='var(--cor-whatsapp-hover)'" onmouseout="this.style.backgroundColor='var(--cor-whatsapp)'">
        <div class="flex items-center space-x-4 px-5">
            <div class="relative">
                <svg class="w-9 h-9 flex-shrink-0" fill="none" stroke="currentColor" viewBox="0 0 24 24" style="margin-top: 6px;">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 3h2l.4 2M7 13h10l4-8H5.4m1.6 8L6 5H3m4 8a2 2 0 100 4 2 2 0 000-4zm10 0a2 2 0 100 4 2 2 0 000-4z"/>
                </svg>
                <div id="cart-count" class="absolute -top-2 -right-2 bg-white rounded-full w-6 h-6 flex items-center justify-center text-sm font-bold border-2" style="color: green !important; border-color: green !important;">0</div>
            </div>
            <div class="text-left">
                <div class="text-xs opacity-90 font-medium">Ver carrinho</div>
                <div class="font-bold text-base" id="cart-total">R$ 0,00</div>
            </div>
        </div>
    </button>

    <!-- Product Modal -->
    <div id="product-modal" class="fixed inset-0 bg-black bg-opacity-50 modal-overlay hidden z-50" onclick="closeModal(event)">
        <div class="flex items-start justify-center min-h-screen p-4 pt-8">
            <div class="relative bg-white rounded-2xl w-full max-w-md slide-up max-h-[85vh] overflow-visible" onclick="event.stopPropagation()">
                <!-- Close Button positioned at modal edge -->
                <button onclick="closeModal()" class="absolute -top-3 -right-3 bg-white shadow-lg rounded-full p-2 text-gray-700 hover:text-gray-900 hover:bg-gray-50 transition-all duration-200 z-20 w-10 h-10 flex items-center justify-center font-bold text-xl">
                    ✕
                </button>
                <div class="overflow-y-auto overflow-x-hidden max-h-[85vh] rounded-2xl">
                     <div id="modal-content">
                         <!-- Modal content will be populated here -->
                     </div>
                 </div>
             </div>
         </div>
     </div>

    <!-- Cart Modal -->
    <div id="cart-modal" class="fixed inset-0 bg-black bg-opacity-50 modal-overlay hidden z-50" onclick="closeCart(event)">
        <div class="flex items-start justify-center min-h-screen p-4 pt-8">
            <div class="rounded-2xl w-full max-w-md slide-up" style="background-color: var(--cor-fundo) !important;" onclick="event.stopPropagation()">
                <div class="p-4">
                    <div class="flex items-center justify-between mb-6">
                        <div class="flex items-center space-x-3">
                            <h3 class="text-xl font-bold">Seu Carrinho</h3>
                            <button onclick="clearCart()" class="text-xs px-2 py-1 rounded-md transition-colors" style="color: var(--cor-texto-secundario); background-color: var(--cor-fundo-secundario);" onmouseover="this.style.backgroundColor='var(--cor-borda)'; this.style.color='var(--cor-erro)'" onmouseout="this.style.backgroundColor='var(--cor-fundo-secundario)'; this.style.color='var(--cor-texto-secundario)'" title="Limpar carrinho">
                                        🗑️ Esvaziar Carrinho
                            </button>
                        </div>
                        <button onclick="closeCart()" class="text-gray-400 hover:text-gray-600">✕</button>
                    </div>
                    <div id="cart-items" class="space-y-3 mb-6 max-h-80 sm:max-h-96 overflow-y-auto" style="overflow-x: visible;">
                        <!-- Cart items will be populated here -->
                    </div>
                    <div class="border-t pt-4">
                        <!-- Contador de itens -->
                        <div class="flex justify-between items-center mb-2">
                            <span class="text-sm" style="color: var(--cor-texto) !important;">Itens no carrinho:</span>
                            <span class="text-sm font-medium" style="color: var(--cor-texto) !important;" id="cart-modal-items-count">0 itens</span>
                        </div>
                        <!-- Total -->
                        <div class="flex justify-between items-center mb-3">
                            <span class="text-lg font-bold">Total:</span>
                            <span class="text-xl font-bold" style="color: var(--cor-secundaria) !important;" id="cart-modal-total">R$ 0,00</span>
                        </div>
                        <button onclick="proceedToCheckout()" class="w-full text-white py-3 rounded-lg font-medium transition-colors" style="background-color: var(--cor-primaria) !important;" onmouseover="this.style.backgroundColor='var(--cor-primaria-hover)'" onmouseout="this.style.backgroundColor='var(--cor-primaria)'">
                            Finalizar Pedido →
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Image Lightbox Modal -->
    <div id="image-lightbox" class="fixed inset-0 bg-black bg-opacity-90 hidden z-50" onclick="closeLightbox(event)">
        <div class="flex items-center justify-center min-h-screen p-4">
            <div class="relative max-w-4xl max-h-[90vh] w-full">
                <button onclick="closeLightbox()" class="absolute -top-12 right-0 text-white text-2xl font-bold z-10 transition-colors" onmouseover="this.style.color='var(--cor-texto-secundario)'" onmouseout="this.style.color='white'">
                    ✕
                </button>
                <img id="lightbox-image" src="" alt="" class="w-full h-full object-contain rounded-lg">
                <div id="lightbox-title" class="absolute bottom-0 left-0 right-0 text-white p-4 rounded-b-lg" style="background-color: rgba(0,0,0,0.7) !important;">
                    <!-- Title will be populated here -->
                </div>
            </div>
        </div>
    </div>

    <!-- Edit Notes Modal -->
    <div id="edit-notes-modal" class="fixed inset-0 bg-black bg-opacity-50 modal-overlay hidden z-50" onclick="closeEditNotes(event)">
        <div class="flex items-center justify-center min-h-screen p-4">
            <div class="bg-white rounded-2xl w-full max-w-md slide-up" onclick="event.stopPropagation()">
                <div class="p-6">
                    <div class="flex items-center justify-between mb-6">
                        <h3 class="text-xl font-bold">Editar Observações</h3>
                        <button onclick="closeEditNotes()" class="text-gray-400 hover:text-gray-600">✕</button>
                    </div>
                    
                    <div id="edit-item-info" class="mb-4 p-3 rounded-lg" style="background-color: var(--cor-fundo-secundario) !important;">
                        <!-- Item info will be populated here -->
                    </div>
                    
                    <div class="mb-6">
                        <label class="block text-sm font-medium mb-2" style="color: var(--cor-texto) !important;">Observações</label>
                        <textarea id="edit-item-notes" class="w-full px-3 py-2 rounded-lg focus:ring-2 focus:border-transparent" style="border: 1px solid var(--cor-borda) !important; --tw-ring-color: var(--cor-secundaria) !important;" rows="3" placeholder="Digite suas observações para este item..."></textarea>
                    </div>
                    
                    <div class="flex space-x-3">
                        <button onclick="closeEditNotes()" class="flex-1 py-3 rounded-lg font-medium transition-colors" style="background-color: var(--cor-fundo-secundario) !important; color: var(--cor-texto) !important;" onmouseover="this.style.backgroundColor='var(--cor-borda)'" onmouseout="this.style.backgroundColor='var(--cor-fundo-secundario)'">
                            Cancelar
                        </button>
                        <button onclick="saveItemNotes()" class="flex-1 text-white py-3 rounded-lg font-medium transition-colors" style="background-color: var(--cor-secundaria) !important;" onmouseover="this.style.backgroundColor='var(--cor-secundaria-hover)'" onmouseout="this.style.backgroundColor='var(--cor-secundaria)'">
                            Salvar
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Checkout Modal -->
    <div id="checkout-modal" class="fixed inset-0 bg-black bg-opacity-50 modal-overlay hidden z-50" onclick="closeCheckout(event)">
        <div class="flex items-start justify-center min-h-screen p-4 pt-8">
            <div class="rounded-2xl w-full max-w-lg slide-up max-h-[85vh] overflow-y-auto" style="background-color: var(--cor-fundo) !important;" onclick="event.stopPropagation()">
                


                <!-- Step 2: Delivery Type -->
                <div id="checkout-step-2" class="checkout-step p-6 hidden">
                    <div class="flex items-center justify-between mb-6">
                        <div class="flex items-center space-x-3">
                            <div class="w-8 h-8 rounded-full flex items-center justify-center text-sm font-bold" style="background-color: var(--cor-primaria) !important; color: white !important;">1</div>
                            <h3 class="text-xl font-bold">Tipo de Recebimento</h3>
                        </div>
                        <button onclick="closeCheckout()" style="color: var(--cor-texto-secundario) !important;" onmouseover="this.style.color='var(--cor-texto)'" onmouseout="this.style.color='var(--cor-texto-secundario)'">✕</button>
                    </div>
                    
                    <div id="delivery-options" class="space-y-3 mb-6">
                        <label class="flex items-center p-4 rounded-lg cursor-pointer" style="border: 1px solid var(--cor-borda) !important; background-color: white !important;" onmouseover="this.style.backgroundColor='#f9f9f9'" onmouseout="this.style.backgroundColor='white'">
                            <input type="radio" name="delivery-type" value="local" class="mr-3" onchange="handleDeliveryTypeChange()">
                            <div>
                                <div class="font-medium">🍽️ Consumir no Local</div>
                                <div class="text-sm" style="color: var(--cor-texto) !important;">Comer no restaurante</div>
                            </div>
                        </label>
                        
                        <label class="flex items-center p-4 rounded-lg cursor-pointer" style="border: 1px solid var(--cor-borda) !important; background-color: white !important;" onmouseover="this.style.backgroundColor='#f9f9f9'" onmouseout="this.style.backgroundColor='white'">
                            <input type="radio" name="delivery-type" value="pickup" class="mr-3" onchange="handleDeliveryTypeChange()">
                            <div>
                                <div class="font-medium">🥡 Retirar no Balcão</div>
                                <div class="text-sm" style="color: var(--cor-texto) !important;">Buscar no restaurante</div>
                            </div>
                        </label>
                        
                        <label class="flex items-center p-4 rounded-lg cursor-pointer" style="border: 1px solid var(--cor-borda) !important; background-color: white !important;" onmouseover="this.style.backgroundColor='#f9f9f9'" onmouseout="this.style.backgroundColor='white'">
                            <input type="radio" name="delivery-type" value="delivery" class="mr-3" onchange="handleDeliveryTypeChange()">
                            <div>
                                <div class="font-medium">🛵 Delivery</div>
                                <div class="text-sm" style="color: var(--cor-texto) !important;">Entrega em casa</div>
                            </div>
                        </label>
                        
                        <label class="flex items-center p-4 rounded-lg cursor-pointer" style="border: 1px solid var(--cor-borda) !important; background-color: white !important;" onmouseover="this.style.backgroundColor='#f9f9f9'" onmouseout="this.style.backgroundColor='white'">
                            <input type="radio" name="delivery-type" value="default" class="mr-3" onchange="handleDeliveryTypeChange()">
                            <div>
                                <div class="font-medium">📋 Padrão</div>
                                <div class="text-sm" style="color: var(--cor-texto) !important;">Sem especificação</div>
                            </div>
                        </label>
                    </div>
                    
                    <!-- Dynamic fields based on delivery type -->
                    <div id="delivery-fields" class="mb-6">
                        <!-- Fields will be populated based on selection -->
                    </div>
                    
                    <div class="flex space-x-3">
                        <button onclick="backToCart()" class="flex-1 py-3 rounded-lg font-medium transition-colors" style="background-color: var(--cor-fundo-secundario) !important; color: var(--cor-texto) !important;" onmouseover="this.style.backgroundColor='var(--cor-borda)'" onmouseout="this.style.backgroundColor='var(--cor-fundo-secundario)'">
                            ← Voltar
                        </button>
                        <button onclick="nextStep(3)" id="step2-continue" class="flex-1 py-3 rounded-lg font-medium transition-colors" style="background-color: var(--cor-primaria) !important; color: white !important;" onmouseover="this.style.backgroundColor='var(--cor-primaria-hover)'" onmouseout="this.style.backgroundColor='var(--cor-primaria)'">
                            Continuar →
                        </button>
                    </div>
                </div>

                <!-- Step 3: Customer Info -->
                <div id="checkout-step-3" class="checkout-step p-6 hidden">
                    <div class="flex items-center justify-between mb-6">
                        <div class="flex items-center space-x-3">
                            <div class="w-8 h-8 rounded-full flex items-center justify-center text-sm font-bold" style="background-color: var(--cor-primaria) !important; color: white !important;">2</div>
                            <h3 class="text-xl font-bold">Finalizar Pedido</h3>
                        </div>
                        <button onclick="closeCheckout()" style="color: var(--cor-texto-secundario) !important;" onmouseover="this.style.color='var(--cor-texto)'" onmouseout="this.style.color='var(--cor-texto-secundario)'">✕</button>
                    </div>
                    
                    <!-- RESUMO DO PEDIDO - VERSÃO COMPACTA -->
                    <div class="bg-white border border-gray-200 rounded-lg shadow-sm p-4 mb-4">
                        
                        <!-- Título -->
                        <div class="flex items-center space-x-2 mb-3">
                            <svg class="w-5 h-5 text-gray-600" fill="currentColor" viewBox="0 0 20 20">
                                <path fill-rule="evenodd" d="M4 4a2 2 0 00-2 2v4a2 2 0 002 2V6h10a2 2 0 00-2-2H4zm2 6a2 2 0 012-2h8a2 2 0 012 2v4a2 2 0 01-2 2H8a2 2 0 01-2-2v-4zm6 4a2 2 0 100-4 2 2 0 000 4z" clip-rule="evenodd"></path>
                            </svg>
                            <h3 class="text-sm font-semibold text-gray-800">Resumo do Pedido</h3>
                        </div>
                        
                        <!-- BREAKDOWN DETALHADO -->
                        <div class="space-y-2 mb-3">
                            
                            <!-- Subtotal Produtos -->
                            <div class="flex justify-between items-center">
                                <span class="text-sm text-gray-600">Subtotal</span>
                                <span id="order-subtotal" class="text-sm font-medium text-gray-800">R$ 0,00</span>
                            </div>
                            
                            <!-- Frete (quando aplicável) -->
                            <div id="delivery-row" class="flex justify-between items-center hidden">
                                <span class="text-sm text-gray-600">Frete</span>
                                <span id="order-delivery-fee" class="text-sm font-medium text-gray-800">R$ 0,00</span>
                            </div>
                            
                            <!-- Desconto (quando aplicável) -->
                            <div id="discount-row" class="flex justify-between items-center hidden">
                                <span class="text-green-600 flex items-center space-x-1">
                                    <span class="text-xs">💸</span>
                                    <span id="discount-label" class="text-xs sm:text-sm">Desconto</span>
                                </span>
                                <span id="order-discount" class="text-xs sm:text-sm font-medium text-green-600">-R$ 0,00</span>
                            </div>
                            
                        </div>
                        
                        <!-- LINHA SEPARADORA -->
                        <div class="border-t border-gray-200 pt-3 mb-3">
                            <div class="flex justify-between items-center">
                                <span class="text-base font-semibold text-gray-800">Total</span>
                                <span id="checkout-order-total" class="text-xl font-bold" style="color: var(--cor-secundaria) !important;">R$ 0,00</span>
                            </div>
                        </div>
                        
                        <!-- CAMPO DE CUPOM EXPANSÍVEL -->
                        <div class="border-t border-gray-200 pt-3">
                            
                            <!-- Botão para expandir cupom -->
                            <div id="coupon-toggle-btn" class="cursor-pointer transition-all duration-200" onclick="toggleCouponField()">
                                <div class="flex items-center justify-center space-x-2 py-2 px-3 rounded-lg border border-dashed transition-all duration-200" style="border-color: var(--cor-primaria) !important; background-color: rgba(var(--cor-primaria-rgb), 0.05) !important;" onmouseover="this.style.backgroundColor='rgba(var(--cor-primaria-rgb), 0.1)'; this.style.transform='translateY(-1px)'" onmouseout="this.style.backgroundColor='rgba(var(--cor-primaria-rgb), 0.05)'; this.style.transform='translateY(0)'">
                                    <span class="text-xs font-medium" style="color: var(--cor-primaria) !important;">🎟️ Tenho um cupom de desconto</span>
                                    <svg id="coupon-arrow" class="w-3 h-3 transition-transform duration-200" style="color: var(--cor-primaria) !important;" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
                                    </svg>
                                </div>
                            </div>
                            
                            <!-- Campo expansível (inicialmente oculto) -->
                            <div id="coupon-field-container" class="overflow-hidden transition-all duration-300" style="max-height: 0; opacity: 0;">
                                <div class="pt-3">
                                    
                                    <div class="flex space-x-2">
                                        <!-- Input com botão de limpar inline -->
                                        <div class="flex-1 relative">
                                            <input 
                                                type="text" 
                                                id="coupon-code" 
                                                class="w-full px-2 sm:px-3 py-2 pr-8 text-xs sm:text-sm border border-gray-300 rounded-lg focus:ring-2 focus:ring-red-500 focus:border-transparent uppercase" 
                                                placeholder="Código do cupom"
                                                style="text-transform: uppercase;"
                                                oninput="this.value = this.value.toUpperCase(); toggleClearButton()"
                                                onkeypress="if(event.key==='Enter') applyCouponFromButton()">
                                            <!-- Botão de limpar dentro do input -->
                                            <button 
                                                id="clear-coupon-btn"
                                                onclick="clearCouponInput()" 
                                                class="absolute right-2 top-1/2 transform -translate-y-1/2 w-5 h-5 rounded-full flex items-center justify-center text-gray-400 hover:text-gray-600 hover:bg-gray-100 transition-colors hidden"
                                                title="Limpar código"
                                                type="button">
                                                <span class="text-xs font-bold">×</span>
                                            </button>
                                        </div>
                                        <button 
                                            onclick="applyCouponFromButton()" 
                                            class="px-3 sm:px-4 py-2 text-xs sm:text-sm text-white rounded-lg transition-colors whitespace-nowrap"
                                            style="background-color: var(--cor-primaria) !important;"
                                            onmouseover="this.style.backgroundColor='var(--cor-primaria-hover)'"
                                            onmouseout="this.style.backgroundColor='var(--cor-primaria)'">
                                            Aplicar
                                        </button>
                                    </div>
                                    
                                    <!-- Feedback do Cupom -->
                                    <div id="coupon-feedback" class="mt-2 text-xs hidden"></div>
                                </div>
                            </div>
                            
                        </div>
                        
                    </div>
                    
                    <div class="space-y-4 mb-6">
                        <div>
                            <label class="block text-sm font-medium mb-2" style="color: var(--cor-texto) !important;">Nome *</label>
                            <input type="text" id="customer-name" class="w-full px-3 py-2 rounded-lg" style="border: 1px solid var(--cor-borda) !important; --tw-ring-color: var(--cor-primaria) !important;" placeholder="Seu nome completo" autocomplete="off" oninput="clearFieldError('customer-name')" onfocus="this.style.borderColor='var(--cor-primaria)'; this.style.outline='2px solid var(--cor-primaria)'; this.style.outlineOffset='2px'" onblur="this.style.borderColor='var(--cor-borda)'; this.style.outline='none'">
                        </div>
                        
                        <div id="whatsapp-field">
                            <label class="block text-sm font-medium mb-2" style="color: var(--cor-texto) !important;">WhatsApp *</label>
                            <div class="flex space-x-2">
                                <select id="country-code" class="px-3 py-2 rounded-lg" style="border: 1px solid var(--cor-borda) !important; --tw-ring-color: var(--cor-primaria) !important; min-width: 120px;" onfocus="this.style.borderColor='var(--cor-primaria)'; this.style.outline='2px solid var(--cor-primaria)'; this.style.outlineOffset='2px'" onblur="this.style.borderColor='var(--cor-borda)'; this.style.outline='none'" onchange="updatePhonePlaceholder()">
                                    <option value="55" data-flag="🇧🇷" data-format="(99) 9 9999-9999">🇧🇷 +55</option>
                                    <option value="351" data-flag="🇵🇹" data-format="999 999 999">🇵🇹 +351</option>
                                    <option value="244" data-flag="🇦🇴" data-format="999 999 999">🇦🇴 +244</option>
                                    <option value="258" data-flag="🇲🇿" data-format="99 999 9999">🇲🇿 +258</option>
                                    <option value="238" data-flag="🇨🇻" data-format="999 99 99">🇨🇻 +238</option>
                                    <option value="245" data-flag="🇬🇼" data-format="999 9999">🇬🇼 +245</option>
                                    <option value="239" data-flag="🇸🇹" data-format="99 99999">🇸🇹 +239</option>
                                    <option value="670" data-flag="🇹🇱" data-format="999 9999">🇹🇱 +670</option>
                                    <option value="853" data-flag="🇲🇴" data-format="9999 9999">🇲🇴 +853</option>
                                    <option value="1" data-flag="🇺🇸" data-format="(999) 999-9999">🇺🇸 +1</option>
                                    <option value="54" data-flag="🇦🇷" data-format="9 9999-9999">🇦🇷 +54</option>
                                    <option value="56" data-flag="🇨🇱" data-format="9 9999 9999">🇨🇱 +56</option>
                                    <option value="57" data-flag="🇨🇴" data-format="999 999 9999">🇨🇴 +57</option>
                                    <option value="51" data-flag="🇵🇪" data-format="999 999 999">🇵🇪 +51</option>
                                    <option value="598" data-flag="🇺🇾" data-format="9999 9999">🇺🇾 +598</option>
                                    <option value="595" data-flag="🇵🇾" data-format="999 999999">🇵🇾 +595</option>
                                    <option value="591" data-flag="🇧🇴" data-format="9999 9999">🇧🇴 +591</option>
                                    <option value="593" data-flag="🇪🇨" data-format="99 999 9999">🇪🇨 +593</option>
                                    <option value="58" data-flag="🇻🇪" data-format="999-999-9999">🇻🇪 +58</option>
                                    <option value="592" data-flag="🇬🇾" data-format="999 9999">🇬🇾 +592</option>
                                    <option value="597" data-flag="🇸🇷" data-format="999-9999">🇸🇷 +597</option>
                                    <option value="594" data-flag="🇬🇫" data-format="999 99 99 99">🇬🇫 +594</option>
                                    <option value="34" data-flag="🇪🇸" data-format="999 99 99 99">🇪🇸 +34</option>
                                    <option value="33" data-flag="🇫🇷" data-format="99 99 99 99 99">🇫🇷 +33</option>
                                    <option value="39" data-flag="🇮🇹" data-format="999 999 9999">🇮🇹 +39</option>
                                    <option value="49" data-flag="🇩🇪" data-format="999 99999999">🇩🇪 +49</option>
                                    <option value="44" data-flag="🇬🇧" data-format="9999 999999">🇬🇧 +44</option>
                                </select>
                                <input type="tel" id="customer-whatsapp" class="flex-1 px-3 py-2 rounded-lg" style="border: 1px solid var(--cor-borda) !important; --tw-ring-color: var(--cor-primaria) !important;" placeholder="(28) 9 9999-9999" autocomplete="off" oninput="formatWhatsAppWithCountry(this); clearFieldError('customer-whatsapp')" onfocus="this.style.borderColor='var(--cor-primaria)'; this.style.outline='2px solid var(--cor-primaria)'; this.style.outlineOffset='2px'" onblur="this.style.borderColor='var(--cor-borda)'; this.style.outline='none'" inputmode="numeric">
                            </div>
                        </div>
                        
                        <!-- Forma de Pagamento e Switcher de Troco - Layout responsivo -->
                        <div class="flex flex-col space-y-4">
                            <!-- Linha 1: Forma de Pagamento e Switcher (lado a lado no desktop) -->
                            <div class="flex flex-col space-y-4 md:flex-row md:space-y-0 md:space-x-4">
                                <!-- Forma de Pagamento (lado esquerdo) -->
                                <div class="w-full md:flex-1">
                                    <label class="block text-sm font-medium mb-2" style="color: var(--cor-texto) !important;">Forma de Pagamento *</label>
                                    <select id="payment-method" class="w-full px-3 py-2 rounded-lg" style="border: 1px solid var(--cor-borda) !important; --tw-ring-color: var(--cor-primaria) !important;" onchange="clearFieldError('payment-method'); handlePaymentMethodChange()" onfocus="this.style.borderColor='var(--cor-primaria)'; this.style.outline='2px solid var(--cor-primaria)'; this.style.outlineOffset='2px'" onblur="this.style.borderColor='var(--cor-borda)'; this.style.outline='none'">
                                        <option value="">Selecione...</option>
                                        <!-- Options will be populated dynamically by setupPaymentMethods() from spreadsheet -->
                                    </select>
                                </div>
                                
                                <!-- Switcher "Precisa de troco?" (lado direito - só aparece quando for dinheiro) -->
                                <div id="change-toggle-container" class="w-full md:flex-1 hidden">
                                    <label class="block text-sm font-medium mb-2" style="color: var(--cor-texto) !important;">Precisa de troco?</label>
                                    <div class="flex items-center space-x-3 h-10">
                                        <!-- Toggle Switch -->
                                        <label class="relative inline-flex items-center cursor-pointer">
                                            <input type="checkbox" id="change-toggle" class="sr-only peer" onchange="handleChangeToggle()">
                                            <div class="w-11 h-6 bg-gray-200 peer-focus:outline-none peer-focus:ring-4 peer-focus:ring-blue-300 rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-blue-600"></div>
                                        </label>
                                        <span class="text-sm" style="color: var(--cor-texto-secundario) !important;" id="change-toggle-label">Não</span>
                                    </div>
                                </div>
                            </div>
                            
                            <!-- Linha 2: Campo de Valor do Troco (aparece embaixo quando switcher ativado) -->
                            <div id="money-change" class="w-full hidden">
                                <label class="block text-sm font-medium mb-2" style="color: var(--cor-texto) !important;">Valor para Troco</label>
                                <input type="tel" id="change-amount" class="w-full px-3 py-2 rounded-lg" style="border: 1px solid var(--cor-borda) !important; --tw-ring-color: var(--cor-primaria) !important;" placeholder="Ex: R$ 50,00" autocomplete="off" inputmode="numeric" onfocus="this.style.borderColor='var(--cor-primaria)'; this.style.outline='2px solid var(--cor-primaria)'; this.style.outlineOffset='2px'" onblur="this.style.borderColor='var(--cor-borda)'; this.style.outline='none'">
                                <p class="text-xs mt-1" style="color: var(--cor-texto-secundario) !important; font-size: 11px;">Informe o valor que você tem para receber o troco</p>
                            </div>
                        </div>
                        
                        <div>
                            <label class="block text-sm font-medium mb-2" style="color: var(--cor-texto) !important;">Observações</label>
                            <textarea id="order-notes" class="w-full px-3 py-2 rounded-lg" style="border: 1px solid var(--cor-borda) !important; --tw-ring-color: var(--cor-primaria) !important;" rows="3" placeholder="Alguma observação especial?" onfocus="focusOrderNotesField(this)" onblur="this.style.borderColor='var(--cor-borda)'; this.style.outline='none'"></textarea>
                        </div>
                    </div>
                    
                    <div class="flex space-x-3">
                        <button onclick="prevStep(2)" class="w-2/5 py-3 rounded-lg font-medium transition-colors" style="background-color: var(--cor-fundo-secundario) !important; color: var(--cor-texto) !important;" onmouseover="this.style.backgroundColor='var(--cor-borda)'" onmouseout="this.style.backgroundColor='var(--cor-fundo-secundario)'">
                            ← Voltar
                        </button>
                        <button onclick="finalizeOrder()" class="w-3/5 py-3 rounded-lg font-medium transition-colors flex items-center justify-center" style="background-color: var(--cor-primaria) !important; color: white !important;" onmouseover="this.style.backgroundColor='var(--cor-primaria-hover)'" onmouseout="this.style.backgroundColor='var(--cor-primaria)'">
                            <span>Enviar Pedido</span>
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Hours Modal -->
    <div id="hours-modal" class="fixed inset-0 bg-black bg-opacity-50 z-[1100] hidden">
        <div class="flex items-center justify-center min-h-screen p-4">
            <div class="rounded-lg max-w-md w-full max-h-[90vh] overflow-y-auto" style="background-color: var(--cor-fundo) !important;">
                <div class="p-4">
                    <div class="flex justify-between items-center mb-3">
                        <h2 class="text-lg font-bold" style="color: var(--cor-texto) !important;">Horários de Funcionamento</h2>
                        <button onclick="closeHoursModal()" style="color: var(--cor-texto) !important;" onmouseover="this.style.color='var(--cor-texto)'" onmouseout="this.style.color='var(--cor-texto-secundario)'">
                            <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                            </svg>
                        </button>
                    </div>
                    
                    <!-- Relógio com Timezone -->
                    <div class="mb-3 text-center p-2 rounded-lg" style="background-color: var(--cor-fundo-secundario); border: 1px solid var(--cor-primaria-clara);">
                        <div class="flex items-center justify-center space-x-1 mb-1">
                            <svg class="w-3 h-3" style="color: var(--cor-texto-primario);" fill="currentColor" viewBox="0 0 20 20">
                                <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm1-12a1 1 0 10-2 0v4a1 1 0 00.293.707l2.828 2.829a1 1 0 101.415-1.415L11 9.586V6z" clip-rule="evenodd"></path>
                            </svg>
                            <span class="text-xs font-medium" style="color: var(--cor-texto-primario);">Horário Atual</span>
                        </div>
                        <div id="timezone-clock" class="text-lg font-bold" style="color: var(--cor-texto-primario); font-family: 'Courier New', monospace;">
                            --:--:--
                        </div>
                        <div id="timezone-info" class="text-xs" style="color: var(--cor-texto-primario); opacity: 0.8;">
                            Carregando timezone...
                        </div>
                    </div>
                    
                    <div id="hours-content" class="space-y-1">
                        <!-- Hours content will be loaded here -->
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Modal Estabelecimento Fechado -->
    <div id="closed-modal" class="fixed inset-0 bg-black bg-opacity-50 z-[1100] hidden">
        <div class="flex items-center justify-center min-h-screen p-4">
            <div class="rounded-lg max-w-md w-full" style="background-color: var(--cor-fundo) !important;">
                <div class="p-4 text-center">
                    <!-- Ícone de Fechado -->
                    <div class="text-4xl mb-3">🕒</div>
                    
                    <!-- Título -->
                    <h2 class="text-lg font-bold mb-3" style="color: var(--cor-texto) !important;">
                        Estabelecimento Fechado
                    </h2>
                    
                    <!-- Mensagem -->
                    <p class="text-sm mb-4" style="color: var(--cor-texto-secundario) !important;">
                        Não estamos recebendo pedidos no momento.<br>
                        Volte no próximo horário de funcionamento.
                    </p>
                    
                    <!-- Próximo Horário -->
                    <div class="p-3 rounded-lg mb-4" style="background-color: var(--cor-fundo-secundario); border: 1px solid var(--cor-primaria-clara);">
                        <div class="flex items-center justify-center space-x-1 mb-1">
                            <svg class="w-3 h-3" style="color: var(--cor-texto-primario);" fill="currentColor" viewBox="0 0 20 20">
                                <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm1-12a1 1 0 10-2 0v4a1 1 0 00.293.707l2.828 2.829a1 1 0 101.415-1.415L11 9.586V6z" clip-rule="evenodd"></path>
                            </svg>
                            <span class="text-xs font-medium" style="color: var(--cor-texto-primario);">Próximo Atendimento</span>
                        </div>
                        <p class="font-bold text-sm" style="color: var(--cor-texto-primario);" id="next-open-time">
                            Carregando...
                        </p>
                    </div>
                    
                    <!-- Botões -->
                    <div class="flex space-x-2">
                        <button onclick="closeClosedModal()" class="flex-1 py-2 px-3 rounded-lg text-sm font-medium transition-colors" style="background-color: var(--cor-fundo-secundario) !important; color: var(--cor-texto) !important;" onmouseover="this.style.backgroundColor='var(--cor-borda)'" onmouseout="this.style.backgroundColor='var(--cor-fundo-secundario)'">
                            Entendi
                        </button>
                        <button onclick="closeClosedModal(); openHoursModal();" class="flex-1 py-2 px-3 rounded-lg text-sm font-medium transition-colors" style="background-color: var(--cor-primaria) !important; color: white !important;" onmouseover="this.style.backgroundColor='var(--cor-primaria-escura)'" onmouseout="this.style.backgroundColor='var(--cor-primaria)'">
                            Ver Horários
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Modal QR Code -->
    <div id="qrcode-modal" class="fixed inset-0 bg-black bg-opacity-50 z-50 hidden">
        <div class="flex items-center justify-center min-h-screen p-4">
            <div class="rounded-lg max-w-md w-full max-h-[90vh] overflow-y-auto" style="background-color: var(--cor-fundo) !important;">
                <div class="p-6">
                    <div class="flex justify-between items-center mb-4">
                        <h2 class="text-xl font-bold" style="color: var(--cor-texto) !important;">🔗 QR Code do Cardápio</h2>
                        <button onclick="closeQRCodeModal()" style="color: var(--cor-texto) !important;" onmouseover="this.style.color='var(--cor-texto)'" onmouseout="this.style.color='var(--cor-texto-secundario)'">
                            <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                            </svg>
                        </button>
                    </div>
                    
                    <div class="text-center space-y-4">
                        <!-- QR Code Container -->
                        <div id="qrcode-container" class="flex justify-center p-4 rounded-lg" style="background-color: var(--cor-fundo-secundario); border: 2px solid var(--cor-primaria-clara);">
                            <div id="qrcode-display" class="bg-white p-4 rounded-lg shadow-lg">
                                <!-- QR Code será gerado aqui -->
                            </div>
                        </div>
                        
                        <!-- URL Display -->
                        <div class="p-3 rounded-lg" style="background-color: var(--cor-fundo-secundario); border: 1px solid var(--cor-primaria-clara);">
                            <p class="text-sm font-medium mb-2" style="color: var(--cor-texto) !important;">📱 Link do Cardápio:</p>
                            <div class="flex items-center space-x-2">
                                <input id="qrcode-url" type="text" readonly class="flex-1 p-2 text-sm rounded border" style="background-color: var(--cor-fundo); color: var(--cor-texto); border-color: var(--cor-primaria-clara);" />
                                <button onclick="copyQRCodeURL(event)" class="px-3 py-2 text-sm font-medium rounded transition-all duration-300" style="background: linear-gradient(135deg, var(--cor-primaria), var(--cor-secundaria)); color: white;" onmouseover="this.style.background='linear-gradient(135deg, var(--cor-secundaria), var(--cor-terciaria))'" onmouseout="this.style.background='linear-gradient(135deg, var(--cor-primaria), var(--cor-secundaria))'">
                                    📋 Copiar
                                </button>
                            </div>
                        </div>
                        
                        <!-- Action Buttons -->
                        <div class="flex flex-col space-y-3">
                            <button id="download-qr-button" onclick="downloadQRCode(event)" disabled class="w-full py-3 px-4 font-medium rounded-lg transition-all duration-300" style="background: linear-gradient(135deg, #ccc, #999); color: #666; cursor: not-allowed;">
                                ⏳ Aguarde o QR Code...
                            </button>
                        </div>
                        
                        <!-- Info -->
                        <div class="text-xs text-center" style="color: var(--cor-texto-secundario); opacity: 0.8;">
                            <p>📱 Escaneie com a câmera do celular</p>
                            <p>🔗 Ou compartilhe o link diretamente</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Modal de Rastreio de Pedido -->
<div id="tracking-modal" class="fixed inset-0 bg-black bg-opacity-50 z-[1100] hidden" onclick="closeTrackingModal(event)">
    <div class="absolute bottom-0 left-0 right-0 md:relative md:flex md:items-center md:justify-center md:min-h-screen md:p-4">
        <div id="tracking-modal-content" class="bg-white rounded-t-2xl md:rounded-2xl shadow-xl w-full max-w-md transition-transform duration-300 transform translate-y-full md:translate-y-0 max-h-[90vh] flex flex-col" onclick="event.stopPropagation()">
            <div class="p-6 md:p-8 overflow-y-auto">
                <!-- Cabeçalho do Modal -->
                <div class="flex justify-between items-center mb-6 border-b pb-4" style="border-color: var(--cor-borda);">
                    <h2 class="text-2xl font-bold" style="color: var(--cor-primaria);">Rastrear Pedido</h2>
                    <button onclick="closeTrackingModal()" class="text-gray-400 hover:text-gray-600 transition-colors">
                        <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
                    </button>
                </div>
                <p class="text-gray-500 mb-6 text-center text-sm">Digite o código do seu pedido para ver o status.</p>

                <!-- Formulário de Busca -->
                <div id="search-form" class="space-y-4">
                    <div>
                        <label for="order-id-input" class="block text-sm font-medium text-gray-700 mb-1">Código do Pedido</label>
                        <input type="text" id="order-id-input" class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:border-transparent uppercase" placeholder="Ex: A1B2C3D4" autocomplete="off" style="text-transform: uppercase; --tw-ring-color: var(--cor-primaria);" oninput="this.value = this.value.toUpperCase()" onkeypress="if(event.key === 'Enter') trackOrder()">
                    </div>
                    <button onclick="trackOrder()" id="track-btn" class="w-full text-white py-3 rounded-lg font-semibold transition-transform transform hover:scale-105 flex items-center justify-center" style="background: var(--gradiente-primario);">
                        <svg id="search-icon" class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"></path></svg>
                        <svg id="loading-spinner" class="animate-spin h-5 w-5 mr-2 hidden" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg>
                        <span>Rastrear</span>
                    </button>
                    <div class="flex items-center justify-center pt-2">
                        <input type="checkbox" id="sound-toggle" class="h-4 w-4 rounded" style="color: var(--cor-primaria);" checked>
                        <label for="sound-toggle" class="ml-2 block text-sm text-gray-700">Tocar som quando o pedido ficar pronto 🔔</label>
                    </div>
                </div>

                <!-- Resultado do Rastreio -->
                <div id="order-status-result" class="mt-8 text-center hidden"></div>
            </div>
        </div>
    </div>

    <!-- Modal de Ajuda com Atalhos -->
    <div id="help-modal" class="fixed inset-0 bg-black bg-opacity-50 z-50 hidden">
        <div class="flex items-center justify-center min-h-screen p-4">
            <div class="rounded-lg max-w-lg w-full max-h-[90vh] overflow-y-auto" style="background-color: var(--cor-fundo) !important; box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);">
                <div class="p-6">
                    <!-- Header -->
                    <div class="flex justify-between items-center mb-6">
                        <div class="flex items-center space-x-3">
                            <div class="p-2 rounded-full" style="background: linear-gradient(135deg, var(--cor-primaria), var(--cor-secundaria));">
                                <svg class="w-6 h-6 text-white" fill="currentColor" viewBox="0 0 24 24">
                                    <path d="M12,2C6.48,2 2,6.48 2,12C2,17.52 6.48,22 12,22C17.52,22 22,17.52 22,12C22,6.48 17.52,2 12,2M12,20C7.59,20 4,16.41 4,12C4,7.59 7.59,4 12,4C16.41,4 20,7.59 20,12C20,16.41 16.41,20 12,20M11,16H13V18H11V16M12.61,6.04C10.55,6.04 8.99,7.59 8.99,9.65H10.96C10.96,8.65 11.7,7.96 12.61,7.96C13.52,7.96 14.26,8.65 14.26,9.65C14.26,10.1 14.05,10.5 13.75,10.79L12.79,11.75C12.35,12.19 12.14,12.63 12.14,13.54H14.11C14.11,13.04 14.32,12.6 14.76,12.16L15.72,11.2C16.23,10.69 16.69,10.04 16.69,9.65C16.69,7.59 15.13,6.04 12.61,6.04Z"/>
                                </svg>
                            </div>
                            <h2 class="text-2xl font-bold" style="color: var(--cor-texto) !important;">🛠️ Ferramentas do Sistema</h2>
                        </div>
                        <button onclick="closeHelpModal()" class="p-2 rounded-full transition-all duration-300" style="color: var(--cor-texto-secundario) !important;" onmouseover="this.style.backgroundColor='var(--cor-fundo-secundario)'; this.style.color='var(--cor-texto)'" onmouseout="this.style.backgroundColor='transparent'; this.style.color='var(--cor-texto-secundario)'">
                            <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                            </svg>
                        </button>
                    </div>
                    
                    <!-- Descrição -->
                    <div class="mb-6 p-4 rounded-lg" style="background-color: var(--cor-fundo-secundario); border-left: 4px solid var(--cor-primaria);">
                        <p class="text-sm" style="color: var(--cor-texto-secundario) !important;">Acesse as ferramentas de desenvolvimento do sistema.</p>
                    </div>
                    
                    <!-- Lista de Atalhos -->
                    <div class="space-y-3">
                        <!-- Gerador de Múltiplos Preços -->
                        <div class="flex items-center justify-between p-3 rounded-lg transition-all duration-300" style="background-color: var(--cor-fundo-secundario); border: 1px solid var(--cor-primaria-clara);" onmouseover="this.style.backgroundColor='var(--cor-primaria-clara)'; this.style.transform='translateY(-2px)'" onmouseout="this.style.backgroundColor='var(--cor-fundo-secundario)'; this.style.transform='translateY(0)'">
                            <div class="flex items-center space-x-3">
                                <div>
                                    <h3 class="font-semibold" style="color: var(--cor-texto) !important;">💰 Gerador de Múltiplos Preços</h3>
                                    <p class="text-sm" style="color: var(--cor-texto-secundario) !important;">Ferramenta para criar múltiplos preço baseado em um preço único</p>
                                </div>
                            </div>
                            <a href="https://dantetesta.com.br/gerador-de-precos/" target="_blank" class="px-4 py-2 text-sm font-medium rounded-lg transition-all duration-300" style="background: linear-gradient(135deg, var(--cor-primaria), var(--cor-secundaria)); color: white; text-decoration: none;" onmouseover="this.style.background='linear-gradient(135deg, var(--cor-secundaria), var(--cor-terciaria))'; this.style.transform='scale(1.05)'" onmouseout="this.style.background='linear-gradient(135deg, var(--cor-primaria), var(--cor-secundaria))'; this.style.transform='scale(1)'">
                                Abrir
                            </a>
                        </div>

                        <!-- Gerador de Variações -->
                        <div class="flex items-center justify-between p-3 rounded-lg transition-all duration-300" style="background-color: var(--cor-fundo-secundario); border: 1px solid var(--cor-primaria-clara);" onmouseover="this.style.backgroundColor='var(--cor-primaria-clara)'; this.style.transform='translateY(-2px)'" onmouseout="this.style.backgroundColor='var(--cor-fundo-secundario)'; this.style.transform='translateY(0)'">
                            <div class="flex items-center space-x-3">
                                <div>
                                    <h3 class="font-semibold" style="color: var(--cor-texto) !important;">🔧 Gerador de Variações</h3>
                                    <p class="text-sm" style="color: var(--cor-texto-secundario) !important;">Crie variações de produtos</p>
                                </div>
                            </div>
                            <button onclick="openVariationGenerator()" class="px-4 py-2 text-sm font-medium rounded-lg transition-all duration-300" style="background: linear-gradient(135deg, var(--cor-primaria), var(--cor-secundaria)); color: white;" onmouseover="this.style.background='linear-gradient(135deg, var(--cor-secundaria), var(--cor-terciaria))'; this.style.transform='scale(1.05)'" onmouseout="this.style.background='linear-gradient(135deg, var(--cor-primaria), var(--cor-secundaria))'; this.style.transform='scale(1)'">
                                Abrir
                            </button>
                        </div>

                        <!-- Gerador de QR Code -->
                        <div class="flex items-center justify-between p-3 rounded-lg transition-all duration-300" style="background-color: var(--cor-fundo-secundario); border: 1px solid var(--cor-primaria-clara);" onmouseover="this.style.backgroundColor='var(--cor-primaria-clara)'; this.style.transform='translateY(-2px)'" onmouseout="this.style.backgroundColor='var(--cor-fundo-secundario)'; this.style.transform='translateY(0)'">
                            <div class="flex items-center space-x-3">
                                <div>
                                    <h3 class="font-semibold" style="color: var(--cor-texto) !important;">📱 Gerador de QR Code</h3>
                                    <p class="text-sm" style="color: var(--cor-texto-secundario) !important;">Crie QR Codes personalizados</p>
                                </div>
                            </div>
                            <button onclick="openQRCodeGenerator()" class="px-4 py-2 text-sm font-medium rounded-lg transition-all duration-300" style="background: linear-gradient(135deg, var(--cor-primaria), var(--cor-secundaria)); color: white;" onmouseover="this.style.background='linear-gradient(135deg, var(--cor-secundaria), var(--cor-terciaria))'; this.style.transform='scale(1.05)'" onmouseout="this.style.background='linear-gradient(135deg, var(--cor-primaria), var(--cor-secundaria))'; this.style.transform='scale(1)'">
                                Abrir
                            </button>
                        </div>

                        <!-- Gerador de Cores -->
                        <div class="flex items-center justify-between p-3 rounded-lg transition-all duration-300" style="background-color: var(--cor-fundo-secundario); border: 1px solid var(--cor-primaria-clara);" onmouseover="this.style.backgroundColor='var(--cor-primaria-clara)'; this.style.transform='translateY(-2px)'" onmouseout="this.style.backgroundColor='var(--cor-fundo-secundario)'; this.style.transform='translateY(0)'">
                            <div class="flex items-center space-x-3">
                                <div>
                                    <h3 class="font-semibold" style="color: var(--cor-texto) !important;">🎨 Gerador de Cores</h3>
                                    <p class="text-sm" style="color: var(--cor-texto-secundario) !important;">Crie paletas de cores personalizadas</p>
                                </div>
                            </div>
                            <button onclick="openColorGenerator()" class="px-4 py-2 text-sm font-medium rounded-lg transition-all duration-300" style="background: linear-gradient(135deg, var(--cor-primaria), var(--cor-secundaria)); color: white;" onmouseover="this.style.background='linear-gradient(135deg, var(--cor-secundaria), var(--cor-terciaria))'; this.style.transform='scale(1.05)'" onmouseout="this.style.background='linear-gradient(135deg, var(--cor-primaria), var(--cor-secundaria))'; this.style.transform='scale(1)'">
                                Abrir
                            </button>
                        </div>

                        <!-- Limpar Cache -->
                        <div class="flex items-center justify-between p-3 rounded-lg transition-all duration-300" style="background-color: var(--cor-fundo-secundario); border: 1px solid var(--cor-primaria-clara);" onmouseover="this.style.backgroundColor='var(--cor-primaria-clara)'; this.style.transform='translateY(-2px)'" onmouseout="this.style.backgroundColor='var(--cor-fundo-secundario)'; this.style.transform='translateY(0)'">
                            <div class="flex items-center space-x-3">
                                <div>
                                    <h3 class="font-semibold" style="color: var(--cor-texto) !important;">🧹 Limpar Cache</h3>
                                    <p class="text-sm" style="color: var(--cor-texto-secundario) !important;">Limpa o cache e recarrega os dados</p>
                                </div>
                            </div>
                            <button onclick="clearStorageAndReload()" class="px-4 py-2 text-sm font-medium rounded-lg transition-all duration-300" style="background: linear-gradient(135deg, var(--cor-primaria), var(--cor-secundaria)); color: white;" onmouseover="this.style.background='linear-gradient(135deg, var(--cor-secundaria), var(--cor-terciaria))'; this.style.transform='scale(1.05)'" onmouseout="this.style.background='linear-gradient(135deg, var(--cor-primaria), var(--cor-secundaria))'; this.style.transform='scale(1)'">
                                Executar
                            </button>
                        </div>
                                </div>
                                <div>
                                    <h3 class="font-semibold" style="color: var(--cor-texto) !important;">❌ Fechar Lightbox</h3>
                                    <p class="text-sm" style="color: var(--cor-texto-secundario) !important;">Fecha a visualização ampliada de imagens</p>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Footer -->
                    <div class="mt-6 pt-4 border-t text-center" style="border-color: var(--cor-primaria-clara);">
                        <p class="text-xs" style="color: var(--cor-texto-secundario) !important; opacity: 0.8;">💡 Pressione <strong>F1</strong> a qualquer momento para ver esta ajuda</p>
                        <p id="help-modal-credits" class="text-xs mt-1" style="color: var(--cor-texto-secundario) !important; opacity: 0.6;">
                            <!-- Créditos serão preenchidos dinamicamente via CSV -->
                            Desenvolvido por <a href="#" target="_blank" style="color: var(--cor-primaria); text-decoration: none;" onmouseover="this.style.textDecoration='underline'" onmouseout="this.style.textDecoration='none'">Carregando...</a>
                        </p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ====================================================================
        // INICIALIZAÇÃO DO SUPABASE
        // ====================================================================
        const SUPABASE_URL = 'https://pqoafjslbvfhwbvepuox.supabase.co';
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InBxb2FmanNsYnZmaHdidmVwdW94Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjA0NTY5MTYsImV4cCI6MjA3NjAzMjkxNn0.oGIuSfm1BFIB1X079Bb4uz4Pz8z_todLeveO_6AZsHc';
        const supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
        
        // Tratamento global de erros de refresh token
        (async () => {
            try {
                const { data: { session }, error } = await supabase.auth.getSession();
                if (error) {
                    // Se houver erro ao obter sessão (token inválido), limpar localStorage
                    if (error.message && (error.message.includes('refresh') || error.message.includes('token'))) {
                        console.warn('⚠️ Token inválido detectado, limpando sessão...');
                        await supabase.auth.signOut();
                        localStorage.clear();
                    }
                }
            } catch (err) {
                console.error('Erro ao verificar sessão:', err);
            }
        })();

        /**
         * Gera um ID de pedido aleatório e único.
         * @returns {string} - Um ID de 8 caracteres.
         */
        function generateOrderId() {
            const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
            let result = '';
            for (let i = 0; i < 8; i++) {
                result += chars.charAt(Math.floor(Math.random() * chars.length));
            }
            return result;
        }
        // Global variables for menu data
        // --- INÍCIO: Variáveis para Rastreio ---
        let orderChannel = null;
        let soundEnabled = true;
        let audioUnlocked = false;
        // Som de notificação de pedido pronto
        const orderReadySound = new Audio('https://cdn.pixabay.com/audio/2025/05/06/audio_2fd68b9a9a.mp3');
        let currentOrderStatus = null;
        const cancellationWindowMs = (typeof CANCELLATION_WINDOW_SECONDS !== 'undefined' ? CANCELLATION_WINDOW_SECONDS : 60) * 1000;
        let cancellationTimer = null;
        let cancellationCountdownInterval = null;
        
        document.addEventListener('DOMContentLoaded', () => {
            const orderIdInput = document.getElementById('order-id-input');
            if(orderIdInput) orderIdInput.addEventListener('keypress', (e) => { if (e.key === 'Enter') trackOrder(); });
        });
        // --- FIM: Variáveis para Rastreio ---
        const APP_VERSION = '4.0.6';
        let menuData = {};
        let categoriesData = [];
        let hoursData = [];
        let configData = {};
        let neighborhoodsData = []; // Dados dos bairros para taxa de delivery
        let currentDeliveryFee = null; // Taxa de delivery atual
        let isDataLoaded = false;
        
        // Variável global para armazenar o timezone configurado (vem do config.js)
        let globalTimezone = TIMEZONE;
        
        // Sistema de Cupons - Variáveis Globais
        let couponsData = []; // Dados dos cupons carregados da planilha
        let appliedCoupon = null; // Cupom atualmente aplicado
        let couponDiscount = 0; // Valor do desconto aplicado
        let couponTimeout = null; // Timeout para aplicação automática

        // ===== FUNÇÃO UTILITÁRIA PARA VERIFICAÇÃO DEFENSIVA DE DOM =====
        
        /**
         * Verifica se um elemento DOM existe e opcionalmente loga um aviso se não existir
         * @param {string} elementId - ID do elemento a ser verificado
         * @param {string} functionName - Nome da função que está fazendo a verificação (para log)
         * @returns {HTMLElement|null} - O elemento se existir, null caso contrário
         */
        function safeGetElement(elementId, functionName = 'unknown') {
            const element = document.getElementById(elementId);
            if (!element) {
                if (typeof warnLog === 'function') {
                    warnLog(`⚠️ Element '${elementId}' not found in function '${functionName}'`);
                }
            }
            return element;
        }
        
        // CSV URLs - agora importadas do config.js
        // As URLs das planilhas estão definidas no arquivo config.js

        // Global configuration object
        let appConfig = {
            identidade_visual: {},
            cores: {},
            contato: {},
            horario: {},
            redes_sociais: {},
            seo: {},
            checkout: {},
            envio: {},
            promocao: {}
        };

        // Function to parse CSV data with proper handling of quoted fields and line breaks
        function parseCSV(csvText) {
            if (!csvText || csvText.trim().length === 0) return [];
            
            // Normalizar quebras de linha
            csvText = csvText.replace(/\r\n/g, '\n').replace(/\r/g, '\n');
            
            const rows = [];
            let currentRow = [];
            let currentField = '';
            let inQuotes = false;
            let i = 0;
            
            while (i < csvText.length) {
                const char = csvText[i];
                const nextChar = csvText[i + 1];
                
                if (char === '"') {
                    if (inQuotes && nextChar === '"') {
                        // Aspas duplas escapadas dentro de campo com aspas
                        currentField += '"';
                        i += 2; // Pular as duas aspas
                        continue;
                    } else {
                        // Início ou fim de campo com aspas
                        inQuotes = !inQuotes;
                    }
                } else if (char === ',' && !inQuotes) {
                    // Fim do campo
                    currentRow.push(currentField.trim());
                    currentField = '';
                } else if (char === '\n' && !inQuotes) {
                    // Fim da linha
                    currentRow.push(currentField.trim());
                    if (currentRow.some(field => field.length > 0)) {
                        rows.push(currentRow);
                    }
                    currentRow = [];
                    currentField = '';
                } else {
                    // Caractere normal (incluindo quebras de linha dentro de aspas)
                    currentField += char;
                }
                
                i++;
            }
            
            // Adicionar último campo e linha se necessário
            if (currentField.length > 0 || currentRow.length > 0) {
                currentRow.push(currentField.trim());
                if (currentRow.some(field => field.length > 0)) {
                    rows.push(currentRow);
                }
            }
            
            if (rows.length === 0) return [];
            
            // Processar cabeçalhos
            const headers = rows[0].map(header => {
                let cleanHeader = header.replace(/^"|"$/g, '').trim();
                return cleanHeader;
            });
            
            // Processar dados
            const data = [];
            for (let rowIndex = 1; rowIndex < rows.length; rowIndex++) {
                const row = {};
                const values = rows[rowIndex];
                
                headers.forEach((header, colIndex) => {
                    let value = values[colIndex] || '';
                    
                    // Remover aspas externas se presentes
                    if (value.startsWith('"') && value.endsWith('"')) {
                        value = value.slice(1, -1);
                    }
                    
                    // Processar aspas duplas escapadas
                    value = value.replace(/""/g, '"');
                    
                    row[header] = value;
                });
                
                data.push(row);
            }
            
            return data;
        }

        // Function to load CSV data
        async function loadCSVData(url) {
            try {
                debugLog('Loading CSV from:', url);
                
                const response = await fetch(url);
                debugLog('Response status:', response.status);
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const csvText = await response.text();
                debugLog('CSV loaded:', csvText.length, 'chars');
                
                const parsedData = parseCSV(csvText);
                infoLog('Data loaded:', parsedData.length, 'items from', url.split('/').pop());
                
                return parsedData;
            } catch (error) {
                errorLog('Error loading CSV data from', url, ':', error);

                
                throw error;
            }
        }

        // Function to process configuration data
        function processConfigData(configItems) {
            const config = {
                identidade_visual: {},
                cores: {},
                contato: {},
                horario: {},
                redes_sociais: {},
                seo: {},
                checkout: {},
                envio: {},
            setup: {},
            promocao: {} // Garante que a seção de promoção seja sempre reconhecida
            };

            configItems.forEach(item => {
                const section = item.section;
                const key = item.key;
                const value = item.value;

                if (config[section]) {
                    config[section][key] = value;
                }
            });

            return config;
        }

        // Function to apply configuration to the page
        function applyConfiguration() {
            try {
                // Apply header configuration
                updateHeaderWithConfig();
                updateFooterWithConfig();
                
                // Apply SEO configuration
                if (appConfig.seo.titulo_pagina) {
                    document.title = appConfig.seo.titulo_pagina;
                }
                
                if (appConfig.seo.descricao_seo) {
                    let metaDescription = document.querySelector('meta[name="description"]');
                    if (!metaDescription) {
                        metaDescription = document.createElement('meta');
                        metaDescription.name = 'description';
                        document.head.appendChild(metaDescription);
                    }
                    metaDescription.content = appConfig.seo.descricao_seo;
                }

                if (appConfig.seo.palavras_chave) {
                    let metaKeywords = document.querySelector('meta[name="keywords"]');
                    if (!metaKeywords) {
                        metaKeywords = document.createElement('meta');
                        metaKeywords.name = 'keywords';
                        document.head.appendChild(metaKeywords);
                    }
                    metaKeywords.content = appConfig.seo.palavras_chave;
                }

                // Apply favicon
                if (appConfig.identidade_visual.favicon_url) {
                    let favicon = document.querySelector('link[rel="icon"]');
                    if (!favicon) {
                        favicon = document.createElement('link');
                        favicon.rel = 'icon';
                        document.head.appendChild(favicon);
                    }
                    // Process favicon URL to handle Google Drive, Dropbox and external links
                    favicon.href = processImageUrl(appConfig.identidade_visual.favicon_url);
                }

                /**
                 * Função para calcular uma cor 20% mais escura
                 */
                function darkenColor(color, percent = 20) {
                    // Remove # se presente
                    color = color.replace('#', '');
                    
                    // Converte para RGB
                    const r = parseInt(color.substr(0, 2), 16);
                    const g = parseInt(color.substr(2, 2), 16);
                    const b = parseInt(color.substr(4, 2), 16);
                    
                    // Aplica o escurecimento
                    const factor = (100 - percent) / 100;
                    const newR = Math.round(r * factor);
                    const newG = Math.round(g * factor);
                    const newB = Math.round(b * factor);
                    
                    // Converte de volta para hex
                    return `#${newR.toString(16).padStart(2, '0')}${newG.toString(16).padStart(2, '0')}${newB.toString(16).padStart(2, '0')}`;
                }
                
                /**
                 * Aplica cores escuras automaticamente para hover dos botões
                 */
                function applyDarkerColors() {
                    const root = document.documentElement;
                    
                    // Obter cores atuais
                    const primaryColor = getComputedStyle(root).getPropertyValue('--cor-primaria').trim();
                    const secondaryColor = getComputedStyle(root).getPropertyValue('--cor-secundaria').trim();
                    const tertiaryColor = getComputedStyle(root).getPropertyValue('--cor-terciaria').trim();
                    const whatsappColor = getComputedStyle(root).getPropertyValue('--cor-whatsapp').trim();
                    
                    // Calcular e aplicar cores escuras
                    if (primaryColor) {
                        const darkerPrimary = darkenColor(primaryColor, 20);
                        root.style.setProperty('--cor-primaria-hover', darkerPrimary, 'important');
                    }
                    
                    if (secondaryColor) {
                        const darkerSecondary = darkenColor(secondaryColor, 20);
                        root.style.setProperty('--cor-secundaria-hover', darkerSecondary, 'important');
                    }
                    
                    if (tertiaryColor) {
                        const darkerTertiary = darkenColor(tertiaryColor, 20);
                        root.style.setProperty('--cor-terciaria-hover', darkerTertiary, 'important');
                    }
                    
                    if (whatsappColor) {
                        const darkerWhatsapp = darkenColor(whatsappColor, 20);
                        root.style.setProperty('--cor-whatsapp-hover', darkerWhatsapp, 'important');
                    }
                    
                    debugLog('Cores de hover aplicadas:', {
                        primary: primaryColor + ' → ' + darkenColor(primaryColor, 20),
                        secondary: secondaryColor + ' → ' + darkenColor(secondaryColor, 20),
                        tertiary: tertiaryColor + ' → ' + darkenColor(tertiaryColor, 20),
                        whatsapp: whatsappColor + ' → ' + darkenColor(whatsappColor, 20)
                    });
                }

                // Apply colors as CSS custom properties with !important
                if (appConfig.cores) {
                    const root = document.documentElement;
                    
                    // Cores principais
                    if (appConfig.cores.cor_primaria) {
                        root.style.setProperty('--cor-primaria', appConfig.cores.cor_primaria, 'important');
                    }
                    if (appConfig.cores.cor_secundaria) {
                        root.style.setProperty('--cor-secundaria', appConfig.cores.cor_secundaria, 'important');
                    }
                    if (appConfig.cores.cor_terciaria) {
                        root.style.setProperty('--cor-terciaria', appConfig.cores.cor_terciaria, 'important');
                    }
                    
                    // Cores de fundo
                    if (appConfig.cores.cor_fundo) {
                        root.style.setProperty('--cor-fundo', appConfig.cores.cor_fundo, 'important');
                        // Também aplicar ao body com !important
                        document.body.style.setProperty('background-color', appConfig.cores.cor_fundo, 'important');
                    }
                    
                    // Cores de texto
                    if (appConfig.cores.cor_texto) {
                        root.style.setProperty('--cor-texto', appConfig.cores.cor_texto, 'important');
                    }
                    if (appConfig.cores.cor_texto_secundario) {
                        root.style.setProperty('--cor-texto-secundario', appConfig.cores.cor_texto_secundario, 'important');
                    }
                    
                    // Cores escuras para gradientes
                    if (appConfig.cores.cor_primaria_escura) {
                        root.style.setProperty('--cor-primaria-escura', appConfig.cores.cor_primaria_escura, 'important');
                    }
                    if (appConfig.cores.cor_secundaria_escura) {
                        root.style.setProperty('--cor-secundaria-escura', appConfig.cores.cor_secundaria_escura, 'important');
                    }
                    if (appConfig.cores.cor_terciaria_escura) {
                        root.style.setProperty('--cor-terciaria-escura', appConfig.cores.cor_terciaria_escura, 'important');
                    }
                    
                    // Atualizar gradientes baseados nas cores principais
                    if (appConfig.cores.cor_primaria && appConfig.cores.cor_primaria_escura) {
                        root.style.setProperty('--gradiente-primario', 
                            `linear-gradient(135deg, ${appConfig.cores.cor_primaria}, ${appConfig.cores.cor_primaria_escura})`, 'important');
                    }
                    if (appConfig.cores.cor_secundaria && appConfig.cores.cor_secundaria_escura) {
                        root.style.setProperty('--gradiente-secundario', 
                            `linear-gradient(135deg, ${appConfig.cores.cor_secundaria}, ${appConfig.cores.cor_secundaria_escura})`, 'important');
                    }
                    if (appConfig.cores.cor_terciaria && appConfig.cores.cor_terciaria_escura) {
                        root.style.setProperty('--gradiente-terciario', 
                            `linear-gradient(135deg, ${appConfig.cores.cor_terciaria}, ${appConfig.cores.cor_terciaria_escura})`, 'important');
                    }
                }
                
                // Aplicar cores escuras automaticamente (20% mais escuro)
                applyDarkerColors();

                // Apply delivery options configuration
                setupDeliveryOptions();
                
                // Apply checkout mode configuration
                applyCheckoutMode();

                debugLog('Configuration applied successfully');
            } catch (error) {
                errorLog('Error applying configuration:', error);
            }
        }

        // Function to update header with config data
        function updateHeaderWithConfig() {
            const companyNameElement = document.getElementById('header-company-name');

            // Apply promotional banner configuration
            applyPromoBanner();
            const sloganElement = document.getElementById('header-slogan');
            const logoElement = document.getElementById('header-logo');
            
            // Update company name
            if (companyNameElement) {
                companyNameElement.textContent = getCompanyName();
            }
            
            // Update slogan
            if (sloganElement) {
                sloganElement.textContent = getSlogan();
            }
            
            // Update logo
            if (logoElement) {
                const logoUrl = getLogoUrl();
                if (logoUrl) {
                    logoElement.src = processImageUrl(logoUrl);
                    logoElement.style.display = 'block';
                } else {
                    logoElement.style.display = 'none';
                }
            }
        }

        // Function to apply promotional banner
        function applyPromoBanner() {
            const promoConfig = appConfig.promocao || {};
            const banner = document.getElementById('promo-banner');
            const promoTextEl = document.getElementById('promo-text');
            const promoIconEl = document.getElementById('promo-icon');

            if (!banner || !promoTextEl || !promoIconEl) {
                warnLog('Elementos do banner promocional não encontrados.');
                return;
            }

            const showBanner = promoConfig.mostrar_banner && promoConfig.mostrar_banner.toLowerCase() === 'sim';
            const promoText = promoConfig.texto_banner || '';

            // Verifica se o banner já foi fechado hoje
            const bannerClosedTimestamp = localStorage.getItem('promoBannerClosed');
            const today = new Date().toDateString();

            if (showBanner && promoText && bannerClosedTimestamp !== today) {
                // Extrai o ícone do texto, se houver
                const emojiRegex = /^\p{Emoji}/u;
                const match = promoText.match(emojiRegex);
                let icon = '🎉';
                let text = promoText;

                if (match) {
                    icon = match[0];
                    text = promoText.substring(icon.length).trim();
                }

                promoIconEl.textContent = icon;
                promoTextEl.textContent = text;
                banner.classList.remove('hidden');
                infoLog('Banner promocional exibido.');
            } else {
                banner.classList.add('hidden');
                infoLog('Banner promocional não será exibido (desativado, sem texto ou já fechado hoje).');
            }
        }

        // Function to apply checkout mode configuration
        function applyCheckoutMode() {
            try {
                debugLog('🛍️ Applying checkout mode...');
                
                const checkoutConfig = getCheckoutConfig();
                const checkoutMode = checkoutConfig.checkout_mode;
                debugLog('🛍️ Checkout mode:', checkoutMode);
                
                // Get cart elements
                const cartFab = document.getElementById('cart-fab');
                const cartCount = document.getElementById('cart-count');
                
                // Determine if checkout should be enabled
                const isCheckoutEnabled = checkoutMode && checkoutMode.toLowerCase() === 'sim';
                
                if (cartFab) {
                    if (!isCheckoutEnabled) {
                        cartFab.style.display = 'none';
                        debugLog('🛍️ Cart FAB hidden - checkout disabled');
                    } else {
                        const cartCount = cart.reduce((sum, item) => sum + item.quantity, 0);
                        cartFab.style.display = cartCount > 0 ? 'flex' : 'none';
                        debugLog('🛍️ Cart FAB will show when items added');
                    }
                }
                
                // Add CSS class to control add to cart buttons
                const body = document.body;
                if (isCheckoutEnabled) {
                    body.classList.remove('checkout-disabled');
                } else {
                    body.classList.add('checkout-disabled');
                }
                
                debugLog('🛍️ Checkout mode applied successfully');
            } catch (error) {
                errorLog('Error applying checkout mode:', error);
            }
        }

        // Function to setup delivery options based on configuration
        function setupDeliveryOptions() {
            try {
                debugLog('🔧 Setting up delivery options...');
                
                const checkoutConfig = getCheckoutConfig();
                debugLog('✅ Checkout config retrieved');
                
                const deliveryOptionsContainer = document.getElementById('delivery-options');
                if (!deliveryOptionsContainer) {
                    warnLog('❌ Delivery options container not found');
                    return;
                }
                
                // Get delivery option elements by finding inputs and their parent labels
                const localOption = deliveryOptionsContainer?.querySelector('input[value="local"]')?.closest('label');
                const pickupOption = deliveryOptionsContainer?.querySelector('input[value="pickup"]')?.closest('label');
                const deliveryOption = deliveryOptionsContainer?.querySelector('input[value="delivery"]')?.closest('label');
                const defaultOption = deliveryOptionsContainer?.querySelector('input[value="default"]')?.closest('label');
                
                debugLog('🎯 Delivery options available:', {
                    local: !!localOption,
                    pickup: !!pickupOption,
                    delivery: !!deliveryOption,
                    default: !!defaultOption
                });

                // Helper function to extract visibility and labels from CSV value
                function parseOptionConfig(csvValue) {
                    if (!csvValue || !csvValue.includes('/')) {
                        return { shouldShow: false, label1: '', label2: '' };
                    }
                    const parts = csvValue.split('/');
                    const visibility = parts[0] ? parts[0].trim().toLowerCase() : '';
                    return {
                        shouldShow: visibility === 'sim',
                        label1: parts[1] ? parts[1].trim() : '',
                        label2: parts[2] ? parts[2].trim() : ''
                    };
                }

                // Configure local option (step2_opc1)
                if (localOption) {
                    const config = parseOptionConfig(checkoutConfig.step2_opc1);
                    localOption.style.display = config.shouldShow ? 'flex' : 'none';
                    
                    if (config.shouldShow) {
                        const titleElement = localOption.querySelector('.font-medium');
                        const subtitleElement = localOption.querySelector('.text-sm');
                        
                        if (titleElement && config.label1) {
                            titleElement.textContent = `🍽️ ${config.label1}`;
                        }
                        if (subtitleElement && config.label2) {
                            subtitleElement.textContent = config.label2;
                        }
                        debugLog(`🏠 Local option labels updated: "${config.label1}" / "${config.label2}"`);
                    }
                    debugLog(`🏠 Local option: ${config.shouldShow ? 'VISIBLE' : 'HIDDEN'} (${checkoutConfig.step2_opc1})`);
                }

                // Configure pickup option (step2_opc2)
                if (pickupOption) {
                    const config = parseOptionConfig(checkoutConfig.step2_opc2);
                    pickupOption.style.display = config.shouldShow ? 'flex' : 'none';
                    
                    if (config.shouldShow) {
                        const titleElement = pickupOption.querySelector('.font-medium');
                        const subtitleElement = pickupOption.querySelector('.text-sm');
                        
                        if (titleElement && config.label1) {
                            titleElement.textContent = `🥡 ${config.label1}`;
                        }
                        if (subtitleElement && config.label2) {
                            subtitleElement.textContent = config.label2;
                        }
                        debugLog(`🥡 Pickup option labels updated: "${config.label1}" / "${config.label2}"`);
                    }
                    debugLog(`🥡 Pickup option: ${config.shouldShow ? 'VISIBLE' : 'HIDDEN'} (${checkoutConfig.step2_opc2})`);
                }

                // Configure delivery option (step2_opc3)
                if (deliveryOption) {
                    const config = parseOptionConfig(checkoutConfig.step2_opc3);
                    deliveryOption.style.display = config.shouldShow ? 'flex' : 'none';
                    
                    if (config.shouldShow) {
                        const titleElement = deliveryOption.querySelector('.font-medium');
                        const subtitleElement = deliveryOption.querySelector('.text-sm');
                        
                        if (titleElement && config.label1) {
                            titleElement.textContent = `🛵 ${config.label1}`;
                        }
                        if (subtitleElement && config.label2) {
                            subtitleElement.textContent = config.label2;
                        }
                        debugLog(`🛵 Delivery option labels updated: "${config.label1}" / "${config.label2}"`);
                    }
                    debugLog(`🛵 Delivery option: ${config.shouldShow ? 'VISIBLE' : 'HIDDEN'} (${checkoutConfig.step2_opc3})`);
                }

                // Configure default option (step2_opc4)
                if (defaultOption) {
                    const config = parseOptionConfig(checkoutConfig.step2_opc4);
                    defaultOption.style.display = config.shouldShow ? 'flex' : 'none';
                    
                    if (config.shouldShow) {
                        const titleElement = defaultOption.querySelector('.font-medium');
                        const subtitleElement = defaultOption.querySelector('.text-sm');
                        
                        if (titleElement && config.label1) {
                            titleElement.textContent = `📋 ${config.label1}`;
                        }
                        if (subtitleElement && config.label2) {
                            subtitleElement.textContent = config.label2;
                        }
                        debugLog(`📋 Default option labels updated: "${config.label1}" / "${config.label2}"`);
                    }
                    debugLog(`📋 Default option: ${config.shouldShow ? 'VISIBLE' : 'HIDDEN'} (${checkoutConfig.step2_opc4})`);
                }

                debugLog('✅ Delivery options configuration completed');

            } catch (error) {
                errorLog('❌ Error setting up delivery options:', error);
            }
        }

        // Function to update footer with configuration data
        function updateFooterWithConfig() {
            const contactInfo = getContactInfo();
            const socialMedia = getSocialMedia();
            
            // Update footer company name
            const footerCompanyNameElement = document.getElementById('footer-company-name');
            if (footerCompanyNameElement) {
                footerCompanyNameElement.textContent = getCompanyName();
            }
            
            // Update footer address
            const footerAddressElement = document.getElementById('footer-address');
            if (footerAddressElement && contactInfo.endereco) {
                footerAddressElement.textContent = contactInfo.endereco;
                footerAddressElement.style.display = 'block';
            } else if (footerAddressElement) {
                footerAddressElement.style.display = 'none';
            }
            
            // Update footer phone
            const footerPhoneElement = document.getElementById('footer-phone');
            if (footerPhoneElement && contactInfo.telefone) {
                footerPhoneElement.querySelector('span:last-child').textContent = contactInfo.telefone;
                footerPhoneElement.href = `tel:${contactInfo.telefone}`;
                footerPhoneElement.style.display = 'flex';
            } else if (footerPhoneElement) {
                footerPhoneElement.style.display = 'none';
            }
            

            
            // Update footer email
            const footerEmailElement = document.getElementById('footer-email');
            if (footerEmailElement && contactInfo.email) {
                footerEmailElement.dataset.email = contactInfo.email;
                footerEmailElement.style.display = 'block';
            } else if (footerEmailElement) {
                footerEmailElement.style.display = 'none';
            }
            
            // Update social media links
            const footerInstagramElement = document.getElementById('footer-instagram');
            if (footerInstagramElement && socialMedia.instagram) {
                footerInstagramElement.href = socialMedia.instagram;
                footerInstagramElement.style.display = 'block';
            } else if (footerInstagramElement) {
                footerInstagramElement.style.display = 'none';
            }
            
            const footerFacebookElement = document.getElementById('footer-facebook');
            if (footerFacebookElement && socialMedia.facebook) {
                footerFacebookElement.href = socialMedia.facebook;
                footerFacebookElement.style.display = 'block';
            } else if (footerFacebookElement) {
                footerFacebookElement.style.display = 'none';
            }
            
            const footerWhatsappElement = document.getElementById('footer-whatsapp');
            if (footerWhatsappElement && contactInfo.whatsapp) {
                const whatsappNumber = contactInfo.whatsapp.replace(/\D/g, '');
                footerWhatsappElement.href = `https://wa.me/${whatsappNumber}`;
                footerWhatsappElement.style.display = 'block';
            } else if (footerWhatsappElement) {
                footerWhatsappElement.style.display = 'none';
            }
            
            const footerEmailLinkElement = document.getElementById('footer-email-link');
            if (footerEmailLinkElement && contactInfo.email) {
                footerEmailLinkElement.href = `mailto:${contactInfo.email}`;
                footerEmailLinkElement.style.display = 'block';
            } else if (footerEmailLinkElement) {
                footerEmailLinkElement.style.display = 'none';
            }
            
            // Update Google Reviews section
            const googleReviewsSection = document.getElementById('google-reviews-section');
            const googleReviewsLink = document.getElementById('google-reviews-link');
            if (googleReviewsSection && googleReviewsLink && socialMedia.google) {
                googleReviewsLink.href = socialMedia.google;
                googleReviewsSection.style.display = 'block';
            } else if (googleReviewsSection) {
                googleReviewsSection.style.display = 'none';
            }
            
            // Update author credits dynamically
            updateAuthorCredits();
        }

        // Helper functions to access configuration data
        function getConfig(section, key, defaultValue = '') {
            return appConfig[section]?.[key] || defaultValue;
        }

        function getCompanyName() {
            return getConfig('identidade_visual', 'nome_empresa', 'Cardápio Digital');
        }

        function getSlogan() {
            return getConfig('identidade_visual', 'slogan', 'Delivery');
        }

        function getLogoUrl() {
            return getConfig('identidade_visual', 'logo_url', '');
        }

        function getLogoMobileUrl() {
            return getConfig('identidade_visual', 'logo_mobile_url', '');
        }

        function getContactInfo() {
            return {
                endereco: getConfig('contato', 'endereco_completo', ''),
                telefone: getConfig('contato', 'telefone', ''),
                whatsapp: getConfig('contato', 'whatsapp', ''),
                email: getConfig('contato', 'email', '')
            };
        }

        function getSocialMedia() {
            return {
                instagram: getConfig('redes_sociais', 'instagram_url', ''),
                facebook: getConfig('redes_sociais', 'facebook_url', ''),
                google: getConfig('redes_sociais', 'google_negocio_url', '')
            };
        }

        function getCheckoutConfig() {
            return {
                step2_opc1: getConfig('checkout', 'step2_opc1', ''),
                step2_opc2: getConfig('checkout', 'step2_opc2', ''),
                step2_opc3: getConfig('checkout', 'step2_opc3', ''),
                step2_opc4: getConfig('checkout', 'step2_opc4', ''),
                step2_taxa_delivery: getConfig('checkout', 'step2_taxa_delivery', ''),
                step3_show_formas_pag: getConfig('checkout', 'step3_show_formas_pag', 'Sim'),
                step3_formas_pag: getConfig('checkout', 'step3_formas_pag', ''),
                step3_mesa_comanda: getConfig('checkout', 'step3_mesa_comanda', 'Sim'),
                step1_itens_obs: getConfig('checkout', 'step1_itens_obs', 'Sim'),                step2_show_cep: getConfig('checkout', 'step2_show_cep', 'Sim'), // Novo comando para CEP
                checkout_mode: getConfig('checkout', 'checkout_mode', 'Sim'),
                checkout_currency: getConfig('checkout', 'checkout_currency', 'BRL'),
                step3_chave_pix: getConfig('checkout', 'step3_chave_pix', ''), // ✅ CHAVE PIX
                only_bairro_mode: getConfig('checkout', 'only_bairro_mode', 'Não') // 🔒 MODO RESTRIÇÃO BAIRRO
            };
        }
        
        /**
         * Obtém configurações de contato
         * @returns {Object} Configurações de contato
         */
        function getContactConfig() {
            return {
                whatsapp: getConfig('contato', 'whatsapp', '5519998021956'),
                telefone: getConfig('contato', 'telefone', ''),
                email: getConfig('contato', 'email', ''),
                endereco: getConfig('contato', 'endereco', '')
            };
        }

        function getEnvioConfig() {
            return {
                whatsapp_web: getConfig('envio', 'whatsapp_web', 'Sim'),
                webhook_url: getConfig('envio', 'webhook_url', ''),
                webhook_token: getConfig('envio', 'webhook_token', '')
            };
        }
        
        // ✅ FUNÇÕES PARA CHAVE PIX
        
        // Função para validar CPF usando dígitos verificadores
        function isValidCPF(cpf) {
            // Remove caracteres não numéricos
            const cleanCPF = cpf.replace(/\D/g, '');
            
            // Verifica se tem 11 dígitos
            if (cleanCPF.length !== 11) return false;
            
            // Verifica se todos os dígitos são iguais (CPFs inválidos como 11111111111)
            if (/^(\d)\1{10}$/.test(cleanCPF)) return false;
            
            // Calcula o primeiro dígito verificador
            let sum = 0;
            for (let i = 0; i < 9; i++) {
                sum += parseInt(cleanCPF.charAt(i)) * (10 - i);
            }
            let remainder = sum % 11;
            let digit1 = remainder < 2 ? 0 : 11 - remainder;
            
            // Verifica o primeiro dígito
            if (parseInt(cleanCPF.charAt(9)) !== digit1) return false;
            
            // Calcula o segundo dígito verificador
            sum = 0;
            for (let i = 0; i < 10; i++) {
                sum += parseInt(cleanCPF.charAt(i)) * (11 - i);
            }
            remainder = sum % 11;
            let digit2 = remainder < 2 ? 0 : 11 - remainder;
            
            // Verifica o segundo dígito
            return parseInt(cleanCPF.charAt(10)) === digit2;
        }
        
        function detectPixKeyType(pixKey) {
            if (!pixKey || pixKey.trim() === '') return 'empty';
            
            const cleanKey = pixKey.trim();
            
            // Email: formato de email (verificar primeiro para evitar conflitos)
            if (/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(cleanKey)) {
                return 'email';
            }
            
            // Telefone: formato +5511999999999 ou similar
            if (/^\+\d{10,15}$/.test(cleanKey)) {
                return 'telefone';
            }
            
            // Verificar se são 11 dígitos numéricos
            if (/^\d{11}$/.test(cleanKey)) {
                // ✅ LÓGICA MELHORADA: Usar validação de CPF
                if (isValidCPF(cleanKey)) {
                    return 'cpf';
                } else {
                    // Se não é um CPF válido, assumir como telefone
                    return 'telefone';
                }
            }
            
            // CNPJ: 14 dígitos numéricos
            if (/^\d{14}$/.test(cleanKey)) {
                return 'cnpj';
            }
            
            // Chave aleatória: formato UUID ou similar
            if (/^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$/i.test(cleanKey)) {
                return 'aleatoria';
            }
            
            // Se não se encaixa em nenhum padrão conhecido, assumir como chave aleatória
            return 'aleatoria';
        }

        function formatPixKey(pixKey, type) {
            const cleanKey = pixKey.trim();
            
            switch (type) {
                case 'cpf':
                    // Formatar CPF: 000.000.000-00
                    return cleanKey.replace(/(\d{3})(\d{3})(\d{3})(\d{2})/, '$1.$2.$3-$4');
                
                case 'cnpj':
                    // Formatar CNPJ: 00.000.000/0000-00
                    return cleanKey.replace(/(\d{2})(\d{3})(\d{3})(\d{4})(\d{2})/, '$1.$2.$3/$4-$5');
                
                case 'telefone':
                    // ✅ FORMATAÇÃO INTELIGENTE DE TELEFONE
                    if (/^\d{11}$/.test(cleanKey)) {
                        // Formato celular: (19) 9 9999-9999
                        return cleanKey.replace(/(\d{2})(\d{1})(\d{4})(\d{4})/, '($1) $2 $3-$4');
                    } else if (/^\d{10}$/.test(cleanKey)) {
                        // Formato fixo: (19) 9999-9999
                        return cleanKey.replace(/(\d{2})(\d{4})(\d{4})/, '($1) $2-$3');
                    }
                    return cleanKey; // Para telefones com + ou outros formatos
                
                case 'email':
                case 'aleatoria':
                default:
                    return cleanKey;
            }
        }

        function getPixKeyIcon(type) {
            switch (type) {
                case 'cpf': return '👤';
                case 'cnpj': return '🏢';
                case 'email': return '📧';
                case 'telefone': return '📱';
                case 'aleatoria': return '🔑';
                default: return '📱';
            }
        }

        function getPixKeyLabel(type) {
            switch (type) {
                case 'cpf': return 'CPF';
                case 'cnpj': return 'CNPJ';
                case 'email': return 'E-mail';
                case 'telefone': return 'Telefone';
                case 'aleatoria': return 'Chave Aleatória';
                default: return 'Chave PIX';
            }
        }

        function copyPixKey(pixKey) {
            const button = document.getElementById('copy-pix-btn');
            const originalText = button.innerHTML;
            const originalClass = button.className;
            
            // ✅ FEEDBACK VISUAL IMEDIATO
            button.innerHTML = '✅ Copiado!';
            button.className = button.className.replace('bg-blue-600', 'bg-green-600').replace('hover:bg-blue-700', 'hover:bg-green-700');
            button.disabled = true;
            
            if (navigator.clipboard && window.isSecureContext) {
                // Método moderno
                navigator.clipboard.writeText(pixKey).then(() => {
                    // Sucesso - manter feedback visual
                    setTimeout(() => {
                        button.innerHTML = originalText;
                        button.className = originalClass;
                        button.disabled = false;
                    }, 2000);
                }).catch(() => {
                    fallbackCopyPixKey(pixKey, button, originalText, originalClass);
                });
            } else {
                // Fallback para navegadores mais antigos
                fallbackCopyPixKey(pixKey, button, originalText, originalClass);
            }
        }

        function fallbackCopyPixKey(pixKey, button, originalText, originalClass) {
            const textArea = document.createElement('textarea');
            textArea.value = pixKey;
            textArea.style.position = 'fixed';
            textArea.style.left = '-999999px';
            textArea.style.top = '-999999px';
            document.body.appendChild(textArea);
            textArea.focus();
            textArea.select();
            
            try {
                document.execCommand('copy');
                // Sucesso - manter feedback visual
                setTimeout(() => {
                    button.innerHTML = originalText;
                    button.className = originalClass;
                    button.disabled = false;
                }, 2000);
            } catch (err) {
                // Erro - feedback visual de erro
                button.innerHTML = '❌ Erro';
                button.className = button.className.replace('bg-green-600', 'bg-red-600').replace('hover:bg-green-700', 'hover:bg-red-700');
                setTimeout(() => {
                    button.innerHTML = originalText;
                    button.className = originalClass;
                    button.disabled = false;
                }, 2000);
            }
            
            document.body.removeChild(textArea);
        }

        function showPixInfo() {
            const checkoutConfig = getCheckoutConfig();
            const pixKey = checkoutConfig.step3_chave_pix;
            let pixDiv = document.getElementById('pix-info');
            
            if (!pixDiv) {
                // Criar elemento se não existir
                pixDiv = document.createElement('div');
                pixDiv.id = 'pix-info';
                pixDiv.className = 'mt-4 p-4 border rounded-lg transition-all duration-300';
                
                // ✅ POSICIONAMENTO DEFINITIVO: Inserir após o container flex do pagamento
                const paymentSelect = document.getElementById('payment-method');
                const paymentFieldDiv = paymentSelect.parentElement; // div com label e select (w-full md:flex-1)
                const flexContainer = paymentFieldDiv.parentElement; // div flex com payment e troco
                const checkoutContainer = flexContainer.parentElement; // container do checkout
                
                // Inserir após o container flex inteiro (payment + troco)
                checkoutContainer.insertBefore(pixDiv, flexContainer.nextSibling);
            }
            
            if (pixKey && pixKey.trim() !== '') {
                const keyType = detectPixKeyType(pixKey);
                const formattedKey = formatPixKey(pixKey, keyType);
                const icon = getPixKeyIcon(keyType);
                const label = getPixKeyLabel(keyType);
                
                // ✅ LAYOUT MELHORADO: Stack vertical em mobile, horizontal em desktop
                pixDiv.className = 'mt-4 p-4 bg-blue-50 border border-blue-200 rounded-lg transition-all duration-300';
                pixDiv.innerHTML = `
                    <div class="flex flex-col sm:flex-row sm:items-center sm:justify-between gap-3">
                        <div class="flex-1">
                            <h4 class="font-medium text-blue-800 flex items-center gap-2 mb-1">
                                ${icon} Chave PIX (${label})
                            </h4>
                            <p class="text-blue-700 font-mono text-sm break-all">${formattedKey}</p>
                        </div>
                        <button id="copy-pix-btn" onclick="copyPixKey('${pixKey}')" 
                                class="bg-blue-600 text-white px-4 py-2 rounded text-sm hover:bg-blue-700 transition-all duration-300 flex-shrink-0 self-start sm:self-center">
                            📋 Copiar
                        </button>
                    </div>
                    <p class="text-xs text-blue-600 mt-3">💡 Use esta chave para fazer o pagamento via PIX</p>
                `;
                
                debugLog('📱 Chave PIX detectada:', { pixKey, keyType, formattedKey });
            } else {
                // Mostrar mensagem para solicitar
                pixDiv.className = 'mt-4 p-4 bg-yellow-50 border border-yellow-200 rounded-lg transition-all duration-300';
                pixDiv.innerHTML = `
                    <div class="text-center">
                        <p class="text-yellow-700 flex items-center justify-center gap-2">
                            💬 Solicite a chave PIX no WhatsApp com o estabelecimento
                        </p>
                    </div>
                `;
                
                debugLog('📱 Chave PIX não configurada - mostrando mensagem alternativa');
            }
            
            pixDiv.classList.remove('hidden');
        }
        
        function getAuthorInfo() {
            return {
                name: getConfig('setup', 'autor_name', ''),
                link: getConfig('setup', 'autor_link', '')
            };
        }
        
        /**
         * Atualiza os créditos do autor dinamicamente em todos os locais
         * Se não configurado no CSV, oculta completamente os créditos
         */
        function updateAuthorCredits() {
            const authorInfo = getAuthorInfo();
            debugLog('🎨 Verificando créditos do autor:', authorInfo);
            
            // Verificar se há dados de autor configurados
            const hasAuthorData = authorInfo.name.trim() !== '' && authorInfo.link.trim() !== '';
            
            // 1. Footer - mostrar ou ocultar o container inteiro
            const footerCreditsContainer = document.getElementById('footer-credits-container');
            if (footerCreditsContainer) {
                if (hasAuthorData) {
                    // Mostrar container e atualizar créditos
                    footerCreditsContainer.style.display = 'block';
                    const footerLink = footerCreditsContainer.querySelector('a');
                    if (footerLink) {
                        footerLink.textContent = authorInfo.name;
                        footerLink.href = authorInfo.link;
                        debugLog('✅ Container de créditos do footer exibido:', authorInfo.name);
                    }
                } else {
                    // Ocultar container inteiro (sem borda, padding, etc.)
                    footerCreditsContainer.style.display = 'none';
                    debugLog('🙈 Container de créditos do footer ocultado - sem linha vazia');
                }
            }
            
            // 2. Modal de ajuda - mostrar ou ocultar
            const helpModalCredits = document.getElementById('help-modal-credits');
            if (helpModalCredits) {
                if (hasAuthorData) {
                    // Mostrar e atualizar créditos
                    helpModalCredits.style.display = 'block';
                    const helpLink = helpModalCredits.querySelector('a');
                    if (helpLink) {
                        helpLink.textContent = authorInfo.name;
                        helpLink.href = authorInfo.link;
                        debugLog('✅ Créditos do modal exibidos:', authorInfo.name);
                    }
                } else {
                    // Ocultar completamente
                    helpModalCredits.style.display = 'none';
                    debugLog('🙈 Créditos do modal ocultados - dados não configurados');
                }
            }
            
            debugLog('🎉 Sistema de créditos dinâmicos atualizado! Oculta se vazio.');
        }

        function getAppConfig() {
            return {
                nome_restaurante: getConfig('identidade_visual', 'nome_empresa', 'Cardápio Digital')
            };
        }

        // Function to process menu items and organize by category
        function processMenuData(menuItems, categories) {
            const processedData = {};
            
            // Initialize categories
            categories.forEach(category => {
                if (category.status === 'Ativo') {
                    processedData[category.nome_categoria] = [];
                }
            });

            // Process menu items
            menuItems.forEach((item, index) => {
                if (item.status === 'Ativo') {
                    // Support multiple categories separated by comma or semicolon
                    const itemCategories = item.categoria
                        .split(/[,;]/) // Split by comma or semicolon
                        .map(cat => cat.trim()) // Remove whitespace
                        .filter(cat => cat && processedData[cat]); // Only valid active categories
                    
                    // Create the processed item once
                    const processedItem = {
                        id: index + 1,
                        nome: item.item,
                        sku: item.SKU,
                        descricao: item.descricao,
                        preco: item.preco, // Manter como string para suportar preços múltiplos
                        imagem: processImageUrl(item.foto_url),
                        disponivel: true,
                        classificacaoAdicional: item.classificacao_adicional,
                        observacoes: item.observacoes,
                        destaque: item.destaque // Adiciona o campo de destaque
                    };
                    
                    // Add the item to each valid category
                    itemCategories.forEach(categoryName => {
                        // Create a copy of the item for each category to avoid reference issues
                        const itemCopy = { ...processedItem };
                        processedData[categoryName].push(itemCopy);
                    });
                }
            });

            return processedData;
        }

        // Function to show preloader
        function showPreloader() {
            // Verificar se a variável PRELOADER_LOGO_URL existe e não está vazia
            let logoURL = '';
            
            // Verificação rigorosa da variável do config.js
            if (typeof PRELOADER_LOGO_URL !== 'undefined' && PRELOADER_LOGO_URL && PRELOADER_LOGO_URL.trim() !== '') {
                logoURL = PRELOADER_LOGO_URL.trim();
                
                if (typeof debugLog === 'function') {
                    debugLog('🖼️ URL do logo encontrada no config.js:', logoURL);
                }
                
                // Processar URLs do Google Drive para formato direto
                if (logoURL.includes('drive.google.com/file/d/')) {
                    const fileId = logoURL.match(/\/d\/([a-zA-Z0-9-_]+)/)?.[1];
                    if (fileId) {
                        logoURL = `https://drive.google.com/thumbnail?id=${fileId}&sz=w300`;
                        if (typeof debugLog === 'function') {
                            debugLog('🔄 URL do Google Drive processada:', logoURL);
                        }
                    }
                }
                
                // Processar URLs do Dropbox
                if (logoURL.includes('dropbox.com') && !logoURL.includes('?raw=1')) {
                    logoURL = logoURL.replace('?dl=0', '?raw=1').replace('?dl=1', '?raw=1');
                    if (!logoURL.includes('?raw=1')) {
                        logoURL += '?raw=1';
                    }
                    if (typeof debugLog === 'function') {
                        debugLog('🔄 URL do Dropbox processada:', logoURL);
                    }
                }
            } else {
                if (typeof debugLog === 'function') {
                    debugLog('❌ PRELOADER_LOGO_URL não definida, vazia ou comentada - logo será omitido');
                }
            }
            
            // Gerar HTML do logo apenas se URL válida existir
            const logoHTML = logoURL ? 
                `<div class="preloader-logo-container mb-4">
                    <img src="${logoURL}" alt="Logo" class="preloader-logo" 
                         style="max-width: 150px; max-height: 150px; object-fit: contain;" 
                         onerror="if (typeof warnLog === 'function') warnLog('❌ Logo do preloader falhou ao carregar:', '${logoURL}'); this.parentElement.style.display='none';" 
                         onload="if (typeof debugLog === 'function') debugLog('✅ Logo do preloader carregado com sucesso'); this.style.opacity='1';">
                </div>` : '';
            
            const preloaderHTML = `
                <div id="preloader" class="fixed inset-0 z-50 flex items-center justify-center" style="background: rgba(255, 255, 255, 0.95); backdrop-filter: blur(10px);">
                    <div class="text-center">
                        ${logoHTML}
                        
                        <!-- Texto "Carregando" com efeito snake -->
                        <div class="loading-text mb-6">
                            <span class="loading-letter" style="animation-delay: 0s;">C</span>
                            <span class="loading-letter" style="animation-delay: 0.1s;">a</span>
                            <span class="loading-letter" style="animation-delay: 0.2s;">r</span>
                            <span class="loading-letter" style="animation-delay: 0.3s;">r</span>
                            <span class="loading-letter" style="animation-delay: 0.4s;">e</span>
                            <span class="loading-letter" style="animation-delay: 0.5s;">g</span>
                            <span class="loading-letter" style="animation-delay: 0.6s;">a</span>
                            <span class="loading-letter" style="animation-delay: 0.7s;">n</span>
                            <span class="loading-letter" style="animation-delay: 0.8s;">d</span>
                            <span class="loading-letter" style="animation-delay: 0.9s;">o</span>
                        </div>
                        
                        <!-- Barra de progresso minimalista -->
                        <div class="progress-container-minimal">
                            <div id="progress-bar" class="progress-fill-minimal"></div>
                        </div>
                        <div id="progress-percentage" class="progress-percentage">0%</div>
                    </div>
                </div>
                
                <style>
                /* Container do logo - centralizado */
                .preloader-logo-container {
                    display: flex;
                    justify-content: center;
                    align-items: center;
                }
                
                /* Logo do preloader - flat design */
                .preloader-logo {
                    animation: logoFloat 3s ease-in-out infinite;
                    opacity: 0;
                    transition: opacity 0.3s ease;
                    display: block;
                }
                
                @keyframes logoFloat {
                    0%, 100% { transform: translateY(0px); }
                    50% { transform: translateY(-5px); }
                }
                
                /* Texto com efeito de pulsação suave */
                .loading-text {
                    font-size: 14px;
                    font-weight: 300;
                    letter-spacing: 0.5px;
                    color: #333;
                    animation: textPulse 3s ease-in-out infinite;
                }
                
                .loading-letter {
                    display: inline-block;
                    animation: letterGlow 2s ease-in-out infinite;
                    transform-origin: center;
                }
                
                /* Pulsação suave do texto inteiro */
                @keyframes textPulse {
                    0%, 100% { 
                        transform: scale(1);
                        opacity: 0.8;
                    }
                    50% { 
                        transform: scale(1.05);
                        opacity: 1;
                    }
                }
                
                /* Efeito de brilho nas letras com tons da cor primária */
                @keyframes letterGlow {
                    0%, 100% { 
                        color: #666;
                        opacity: 0.7;
                    }
                    25% { 
                        color: ${PRELOADER_COLOR};
                        opacity: 1;
                    }
                    50% { 
                        color: #999;
                        opacity: 0.8;
                    }
                    75% { 
                        color: rgba(51, 51, 51, 0.9);
                        opacity: 0.9;
                    }
                }
                
                /* Barra de progresso minimalista - flat design */
                .progress-container-minimal {
                    width: 200px;
                    height: 2px;
                    background: rgba(0, 0, 0, 0.1);
                    border-radius: 2px;
                    margin: 0 auto;
                    overflow: hidden;
                    position: relative;
                }
                
                .progress-fill-minimal {
                    height: 4px;
                    width: 0%;
                    background: ${PRELOADER_COLOR};
                    border-radius: 2px;
                    transition: width 0.3s ease;
                    position: absolute;
                    top: -1px;
                }
                
                /* Porcentagem abaixo da barra */
                .progress-percentage {
                    font-size: 10px;
                    font-weight: 400;
                    color: #666;
                    text-align: center;
                    margin-top: 8px;
                    letter-spacing: 0.5px;
                }
                
                /* Responsividade */
                @media (max-width: 640px) {
                    .loading-text {
                        font-size: 12px;
                        letter-spacing: 0.3px;
                    }
                    
                    .progress-container-minimal {
                        width: 150px;
                    }
                    
                    .progress-text {
                        font-size: 9px;
                        margin-top: 6px;
                    }
                    
                    .preloader-logo {
                        max-width: 120px !important;
                        max-height: 120px !important;
                    }
                }
                </style>
            `;
            document.body.insertAdjacentHTML('beforeend', preloaderHTML);
            
            // Desabilitar scroll do body durante o preloader
            document.body.style.overflow = 'hidden';
            if (typeof debugLog === 'function') {
                debugLog('🚫 Scroll do body desabilitado durante preloader');
            }
        }

        // Function to update progress
        function updateProgress(percentage) {
            const progressBar = document.getElementById('progress-bar');
            const progressPercentage = document.getElementById('progress-percentage');
            
            if (progressBar) {
                progressBar.style.width = percentage + '%';
            }
            
            if (progressPercentage) {
                progressPercentage.textContent = Math.round(percentage) + '%';
            }
            
            if (typeof debugLog === 'function') {
                debugLog('📋 Progresso atualizado:', Math.round(percentage) + '%');
            }
        }

        // Function to hide preloader
        function hidePreloader() {
            const preloader = document.getElementById('preloader');
            if (preloader) {
                preloader.style.opacity = '0';
                setTimeout(() => {
                    preloader.remove();
                    
                    // Reabilitar scroll do body
                    document.body.style.overflow = '';
                    
                    // Mostrar conteúdo principal (anti-flash)
                    document.body.classList.add('loaded');
                    debugLog('✅ Conteúdo principal exibido (anti-flash)');
                    debugLog('✅ Scroll enabled after preloader');
                    
                    // Mostrar toast da mesa após carregamento completo
                    setTimeout(() => {
                        mostrarIndicadorMesaURL();
                    }, 500);
                }, 300);
            }
        }

        /**
         * Função para adicionar parâmetros anti-cache às URLs
         */
        function addCacheBuster(url) {
            const separator = url.includes('?') ? '&' : '?';
            return `${url}${separator}v=${Date.now()}&nocache=${Math.random()}`;
        }
        
        /**
         * Função para fazer fetch com cache busting
         */
        function fetchWithCacheBuster(url, options = {}) {
            const cacheBustedUrl = addCacheBuster(url);
            const fetchOptions = {
                ...options,
                cache: 'no-cache',
                headers: {
                    'Cache-Control': 'no-cache, no-store, must-revalidate',
                    'Pragma': 'no-cache',
                    'Expires': '0',
                    ...options.headers
                }
            };
            return fetch(cacheBustedUrl, fetchOptions);
        }
        
        // Função para limpar localStorage e recarregar página
        function clearStorageAndReload() {
            try {
                if (confirm('🧹 Limpar Cache\n\nIsso vai:\n• Limpar todos os dados salvos\n• Limpar cache do navegador\n• Recarregar a página\n\nDeseja continuar?')) {
                    debugLog('🧹 === LIMPEZA COMPLETA DE CACHE ===');
                    
                    // 1. Limpar localStorage
                    try {
                        if (typeof clearAllStorageData === 'function') {
                            clearAllStorageData();
                            debugLog('✅ clearAllStorageData() executado');
                        } else {
                            localStorage.clear();
                            debugLog('✅ localStorage.clear() executado');
                        }
                    } catch (e) {
                        errorLog('Erro ao limpar localStorage:', e);
                    }
                    
                    // 2. Limpar sessionStorage
                    try {
                        sessionStorage.clear();
                        debugLog('✅ sessionStorage limpo');
                    } catch (e) {
                        errorLog('Erro ao limpar sessionStorage:', e);
                    }
                    
                    // 3. Limpar cache do navegador (se suportado)
                    try {
                        if ('caches' in window) {
                            caches.keys().then(function(names) {
                                for (let name of names) {
                                    caches.delete(name);
                                }
                                debugLog('✅ Cache do navegador limpo');
                            });
                        }
                    } catch (e) {
                        warnLog('Não foi possível limpar cache do navegador:', e);
                    }
                    
                    // 4. Forçar recarregamento sem cache
                    debugLog('🔄 Recarregando página sem cache...');
                    debugLog('=== FIM LIMPEZA CACHE ===');
                    
                    // Forçar reload sem cache
                    window.location.reload(true);
                }
            } catch (e) {
                errorLog('Erro crítico ao limpar cache:', e);
                // Forçar reload mesmo com erro
                window.location.reload(true);
            }
        }

        // Função para mostrar erro de configuração
        function showConfigurationError() {
            errorLog('😫 Exibindo erro de configuração - dados não carregados');
            
            const errorHTML = `
                <div class="fixed inset-0 bg-white z-50 flex items-center justify-center">
                    <div class="text-center p-8 max-w-md mx-auto">
                        <div class="text-red-500 text-6xl mb-4">😕</div>
                        <h2 class="text-xl font-semibold text-gray-800 mb-2">Ops! Arquivo não configurado</h2>
                        <p class="text-gray-600 mb-4">Não foi possível carregar os dados do cardápio. Verifique se as URLs da planilha estão configuradas corretamente.</p>
                        <button onclick="clearStorageAndReload()" class="bg-red-500 text-white px-6 py-2 rounded-lg hover:bg-red-600 transition-colors">
                            Tentar Novamente
                        </button>
                    </div>
                </div>
            `;
            document.body.insertAdjacentHTML('beforeend', errorHTML);
        }

        // Function to load all data
        async function loadAllData() {
            try {
                showPreloader();
                updateProgress(5);
                
                // Inicializar sistema de localStorage
                if (typeof initializeStorageSystem === 'function') {
                    initializeStorageSystem();
                }

                // ====================================================================
                // 🚀 CARREGAMENTO PARALELO DE CSVs - V4.1.0 - OTIMIZAÇÃO DE PERFORMANCE
                // ====================================================================
                // Reduz tempo de carregamento em 60-80% usando Promise.all()
                
                infoLog('🚀 Starting parallel CSV loading...');
                const startTime = performance.now();
                
                // ETAPA 1: Carregar CONFIG primeiro (obrigatório para dependências)
                infoLog('Loading configuration data...');
                configData = await loadCSVData(CONFIG_CSV_URL);
                appConfig = processConfigData(configData);
                debugLog('Configuration loaded:', Object.keys(appConfig).length, 'sections');
                
                // DEBUG: Log detalhado do appConfig carregado
                debugLog('🔠 === DEBUG APP CONFIG CARREGADO ===');
                debugLog('appConfig completo:', appConfig);
                debugLog('appConfig.checkout:', appConfig.checkout);
                debugLog('orders_all_time:', appConfig?.checkout?.orders_all_time);
                debugLog('=== FIM DEBUG APP CONFIG ===');
                updateProgress(15);

                // Apply configuration to the page
                applyConfiguration();
                updateProgress(20);

                // ETAPA 2: Carregar todos os outros CSVs EM PARALELO
                infoLog('🔄 Loading remaining CSVs in parallel...');
                
                const parallelPromises = [
                    // CSVs obrigatórios
                    loadCSVData(CATEGORIES_CSV_URL).then(data => ({ type: 'categories', data })),
                    loadCSVData(MENU_CSV_URL).then(data => ({ type: 'menu', data })),
                    loadCSVData(HOURS_CSV_URL).then(data => ({ type: 'hours', data })),
                    
                    // CSVs opcionais com tratamento de erro
                    loadCSVData(NEIGHBORHOODS_CSV_URL)
                        .then(data => ({ type: 'neighborhoods', data }))
                        .catch(error => {
                            warnLog('❌ Neighborhoods CSV not available:', error.message);
                            return { type: 'neighborhoods', data: [] };
                        }),
                    
                    loadCSVData(COUPONS_CSV_URL)
                        .then(data => ({ type: 'coupons', data }))
                        .catch(error => {
                            warnLog('❌ Coupons CSV not available:', error.message);
                            return { type: 'coupons', data: [] };
                        })
                ];

                // Executar todos os carregamentos em paralelo
                const results = await Promise.all(parallelPromises);
                updateProgress(65);

                // ETAPA 3: Processar resultados
                let menuItems = [];
                results.forEach(result => {
                    switch (result.type) {
                        case 'categories':
                            categoriesData = result.data;
                            infoLog('✅ Categories loaded:', categoriesData.length, 'items');
                            break;
                            
                        case 'menu':
                            menuItems = result.data;
                            infoLog('✅ Menu items loaded:', menuItems.length, 'items');
                            break;
                            
                        case 'hours':
                            hoursData = result.data;
                            debugLog('✅ Hours data loaded:', hoursData.length, 'entries');
                            
                            if (hoursData.length > 0) {
                                // Inicializar timezone global
                                debugLog('🚀 Initializing global timezone...');
                                initializeGlobalTimezone();
                                
                                // Verificar se timezone foi configurado corretamente
                                if (globalTimezone) {
                                    debugLog('✅ Timezone system initialized:', globalTimezone);
                                } else {
                                    warnLog('❌ Timezone system not configured properly');
                                }
                            }
                            break;
                            
                        case 'neighborhoods':
                            if (result.data.length > 0) {
                                // Process neighborhoods data - mapear para formato consistente
                                neighborhoodsData = result.data.map(row => ({
                                    // Tentar várias possibilidades de nomes de colunas
                                    bairro: (row.bairro || row.nome_bairro || row.Bairro || row.BAIRRO || '').trim().toLowerCase(),
                                    taxa: parseFloat((row.taxa || row.valor_taxa || row.Taxa || row.TAXA || '0').toString().replace(',', '.')) || 0
                                })).filter(item => item.bairro); // Remove empty entries
                                
                                // Expor dados globalmente para acesso em outras funções
                                window.neighborhoodsData = neighborhoodsData;
                                
                                // Preparar lista para autocomplete
                                prepareNeighborhoodsAutocomplete();
                                
                                infoLog(`✅ Neighborhoods loaded:`, neighborhoodsData.length, 'items');
                            } else {
                                neighborhoodsData = [];
                                debugLog('ℹ️ No neighborhoods data available');
                            }
                            break;
                            
                        case 'coupons':
                            couponsData = result.data;
                            if (couponsData.length > 0) {
                                infoLog(`✅ Coupons loaded:`, couponsData.length, 'items');
                            } else {
                                debugLog('ℹ️ No coupons data available');
                            }
                            break;
                    }
                });

                // Calcular tempo de carregamento
                const endTime = performance.now();
                const loadTime = Math.round(endTime - startTime);
                
                infoLog(`🎯 Parallel loading completed in ${loadTime}ms`);
                perfLog('CSV Loading Performance', () => {
                    debugLog(`📊 Performance Metrics:`);
                    debugLog(`- Total CSVs loaded: ${results.length + 1}`); // +1 for config
                    debugLog(`- Loading time: ${loadTime}ms`);
                    debugLog(`- Average per CSV: ${Math.round(loadTime / (results.length + 1))}ms`);
                });

                updateProgress(80);

                // Process and organize data
                debugLog('Processing and organizing data...');
                menuData = processMenuData(menuItems, categoriesData);
                updateProgress(95);

                // Update operating hours display
                updateOperatingHours();
                
                // Set up periodic updates for operating hours (every minute)
                setInterval(updateOperatingHours, 60000);

                // Mark data as loaded
                isDataLoaded = true;
                updateProgress(100);

                infoLog('Data loaded successfully:', { categoriesData, menuData });
                
                // Hide preloader and initialize app
                setTimeout(() => {
                    hidePreloader();
                    initializeApp();
                }, 500);

            } catch (error) {
                errorLog('Error loading data:', error);
                hidePreloader();
                
                // Mostrar erro de configuração sem fallbacks
                showConfigurationError();
            }
        }

        // Function to initialize the app after data is loaded
        function initializeApp() {
            renderCategoryNavigation();
            renderMenu();
            initializeLazyLoading(); // Adicionado para iniciar o lazy loading
            setupEventListeners();
            toggleWhatsAppField(); // Show/hide WhatsApp field based on webhook status
            
            // Only detect country by IP if webhook is active (not using WhatsApp Web)
            if (isWebhookActive()) {
                detectCountryByIP(); // Detect country by IP and set default country code
            } else {
                debugLog('Skipping IP detection - WhatsApp Web mode active');
            }
            
            // Restaurar dados do usuário do localStorage
            restoreUserDataFromStorage();
        }
        // Atualiza o logo no pop-up de instalação
        function updateInstallPopupLogo() {
            const logoUrl = getLogoUrl();
            const installLogo = document.getElementById('install-logo');
            if (logoUrl && installLogo) installLogo.src = processImageUrl(logoUrl);
        }

        // --- INÍCIO: Otimização de Carregamento de Imagens (Lazy Loading) ---
        function initializeLazyLoading() {
            const lazyImages = document.querySelectorAll('.lazy-image');

            if ('IntersectionObserver' in window) {
                const observer = new IntersectionObserver((entries, observer) => {
                    entries.forEach(entry => {
                        if (entry.isIntersecting) {
                            const img = entry.target;
                            const src = img.getAttribute('data-src');
                            if (src) {
                                img.src = src;
                                img.onload = () => {
                                    img.classList.add('loaded');
                                    img.removeAttribute('data-src');
                                };
                            }
                            observer.unobserve(img);
                        }
                    });
                }, { rootMargin: '0px 0px 200px 0px' }); // Carrega 200px antes de entrar na tela

                lazyImages.forEach(img => observer.observe(img));
            } else {
                // Fallback para navegadores sem IntersectionObserver
                lazyImages.forEach(img => {
                    img.src = img.getAttribute('data-src');
                    img.classList.add('loaded');
                });
            }
        }
        
        // Restaurar dados do usuário do localStorage
        function restoreUserDataFromStorage() {
            debugLog('🔄 Restaurando dados do usuário do localStorage...');
            
            // Restaurar carrinho
            if (typeof loadCartFromStorage === 'function') {
                const cartRestored = loadCartFromStorage();
                if (cartRestored) {
                    updateCartUI(); // Atualizar UI do carrinho incluindo FAB
                    debugLog('🛍️ Carrinho restaurado e FAB atualizado');
                }
            }
            
            // Restaurar cupom
            if (typeof loadCouponFromStorage === 'function') {
                const couponRestored = loadCouponFromStorage();
                if (couponRestored) {
                    updateCheckoutOrderTotal();
                }
            }
            
            // Restaurar dados do formulário
            if (typeof loadOrderDataFromStorage === 'function') {
                loadOrderDataFromStorage();
            }
            
            // Restaurar taxa de delivery
            if (typeof loadDeliveryFeeFromStorage === 'function') {
                loadDeliveryFeeFromStorage();
            }
            
            debugLog('✅ Restauração de dados concluída');
        }

        let cart = [];
        let currentProduct = null;
        let currentStep = 1;
        let selectedVariations = {};
        let orderData = {
            deliveryType: '',
            tableNumber: '',
            address: {},
            customerName: '',
            paymentMethod: '',
            changeAmount: '',
            notes: ''
        };

        // Parse variations from classificacaoAdicional
        function parseVariations(classificacaoAdicional) {
            if (!classificacaoAdicional) return null;
            
            debugLog('🔍 parseVariations chamada com:', classificacaoAdicional);
            
            // Detectar se é o novo formato (múltiplas linhas com # ou Var:)
            const lines = classificacaoAdicional.split('\n').map(line => line.trim()).filter(line => line);
            debugLog('📝 Linhas detectadas:', lines);
            
            // Verificar se alguma linha tem o padrão do novo formato
            const hasNewFormatPattern = lines.some(line => 
                /^(#[^:]+:|~Var:\s*[^:]+:|Var:\s*[^:]+:)(radio|checkbox):/.test(line) ||
                /maxselect=\d+:/.test(line)
            );
            
            debugLog('🆕 Tem padrão novo formato?', hasNewFormatPattern);
            
            if (hasNewFormatPattern) {
                // Novo formato - múltiplas variações
                const variations = [];
                
                lines.forEach((line, lineIndex) => {
                    debugLog(`📋 Processando linha ${lineIndex}:`, line);
                    
                    // Padrão: [#|~Var:|Var:]Nome:tipo:opção1 valor/opção2 valor/... [limites]
                    // Novo padrão com limites: Nome:tipo:opções [min-max] ou [max]
                    const match = line.match(/^(#?)(?:(~)Var:\s*|Var:\s*)?([^:]+):(radio|checkbox):(.+?)(?:\s*\[(\d+)(?:-(\d+))?\])?$/);
                    
                    if (match) {
                        const [, isRequired, isRemoval, name, type, optionsStr, minSelect, maxSelect] = match;
                        debugLog('✅ Match encontrado:', { 
                            isRequired: !!isRequired, 
                            isRemoval: !!isRemoval, 
                            name, 
                            type, 
                            optionsStr,
                            minSelect: minSelect ? parseInt(minSelect) : undefined,
                            maxSelect: maxSelect ? parseInt(maxSelect) : (minSelect ? parseInt(minSelect) : undefined)
                        });
                        
                        // Parse das opções
                        const options = optionsStr.split('/').map(optionStr => {
                            const trimmed = optionStr.trim();
                            
                            // Verificar se a primeira opção contém maxselect=X (formato da planilha)
                            let maxSelectFromOption = null;
                            let cleanedOption = trimmed;
                            
                            const maxSelectMatch = trimmed.match(/maxselect=(\d+):(.+)/);
                            if (maxSelectMatch) {
                                maxSelectFromOption = parseInt(maxSelectMatch[1]);
                                cleanedOption = maxSelectMatch[2];
                                debugLog('🎨 Detectado maxselect na opção:', maxSelectFromOption, 'para:', cleanedOption);
                            }
                            
                            // Padrão para preços: +X,XX, -X,XX, +0,00
                            const priceMatch = cleanedOption.match(/([+-])(\d+(?:[,.]\d{2})?)/);
                            
                            let name = cleanedOption;
                            let price = 0;
                            
                            if (priceMatch) {
                                const [fullMatch, sign, valueStr] = priceMatch;
                                name = cleanedOption.replace(fullMatch, '').trim();
                                price = parseFloat(valueStr.replace(',', '.'));
                                if (sign === '-') price = -price;
                            }
                            
                            return { name, price, maxSelectFromOption };
                        }).filter(option => option.name);
                        
                        // Limpar as opções finais (remover maxSelectFromOption do objeto final)
                        const cleanOptions = options.map(opt => ({ name: opt.name, price: opt.price }));
                        
                        debugLog('🎯 Opções parseadas:', options);
                        
                        // Processar limites de seleção
                        let finalMinSelect = minSelect ? parseInt(minSelect) : undefined;
                        let finalMaxSelect = maxSelect ? parseInt(maxSelect) : (minSelect ? parseInt(minSelect) : undefined);
                        
                        // Verificar se alguma opção tem maxselect definido (formato da planilha)
                        const optionWithMaxSelect = options.find(opt => opt.maxSelectFromOption);
                        if (optionWithMaxSelect && !finalMaxSelect) {
                            finalMaxSelect = optionWithMaxSelect.maxSelectFromOption;
                            debugLog('🎨 Usando maxSelect da opção:', finalMaxSelect, 'para variação:', name);
                        }
                        
                        // Validação: checkbox deve ter limite mínimo de pelo menos 2 se especificado
                        if (type === 'checkbox' && finalMinSelect && finalMinSelect < 2) {
                            console.warn(`⚠️ Limite mínimo para checkbox "${name}" ajustado de ${finalMinSelect} para 2`);
                            finalMinSelect = 2;
                        }
                        
                        variations.push({
                            name: name.trim(),
                            type: type,
                            required: !!isRequired,
                            isRemoval: !!isRemoval,
                            minSelect: finalMinSelect,
                            maxSelect: finalMaxSelect,
                            options: cleanOptions
                        });
                    } else {
                        debugLog('❌ Linha não corresponde ao padrão:', line);
                    }
                });
                
                debugLog('🎉 Variações finais:', variations);
                
                return {
                    type: 'multiple_variations',
                    variations: variations
                };
            }
            
            // Verificar formato legado
            const isRequiredVariation = classificacaoAdicional.startsWith('#Var:');
            const isOptionalVariation = classificacaoAdicional.startsWith('Var:') && !isRequiredVariation;
            
            if (isRequiredVariation || isOptionalVariation) {
                debugLog('📜 Formato legado detectado');
                
                const variationsText = classificacaoAdicional.replace(/^#?Var:\s*/, '');
                
                const variations = variationsText.split('/').map(variation => {
                    const trimmed = variation.trim();
                    const priceMatch = trimmed.match(/\+(\d+(?:[,.]\d{2})?)/);
                    
                    let name = trimmed;
                    let price = 0;
                    
                    if (priceMatch) {
                        name = trimmed.replace(/\s*\+\d+(?:[,.]\d{2})?/, '').trim();
                        price = parseFloat(priceMatch[1].replace(',', '.'));
                    }
                    
                    return { name, price };
                }).filter(variation => variation.name);
                
                return {
                    type: 'variation',
                    required: isRequiredVariation,
                    options: variations
                };
            }
            
            // Texto informativo
            debugLog('ℹ️ Texto informativo detectado');
            return {
                type: 'info',
                text: classificacaoAdicional.trim()
            };
        }



        // Process image URL to handle different sources
        function processImageUrl(url) {
            if (!url || url.trim() === '') {
                warnLog('URL de imagem vazia ou inválida, usando placeholder visual.', url);
                return ''; // Retorna string vazia, o onerror cuidará disso
            }
            
            try {
                // Handle Google Drive URLs
                if (url.includes('drive.google.com')) {
                    // If it's already a thumbnail URL, return as is
                    if (url.includes('thumbnail?id=')) {
                        return url;
                    }
                    
                    // Extract file ID from various Google Drive URL formats
                    let fileId = null;
                    
                    // Format: https://drive.google.com/file/d/FILE_ID/view
                    if (url.includes('/file/d/')) {
                        fileId = url.match(/\/file\/d\/([a-zA-Z0-9_-]+)/)?.[1];
                    }
                    // Format: https://drive.google.com/open?id=FILE_ID
                    else if (url.includes('open?id=')) {
                        fileId = url.match(/[?&]id=([a-zA-Z0-9_-]+)/)?.[1];
                    }
                    
                    if (fileId) {
                        // Alta qualidade: Solicitar imagem com 800px para melhor qualidade visual
                        const processedUrl = `https://drive.google.com/thumbnail?id=${fileId}&sz=s800`;
                        debugLog('URL do Google Drive processada:', url, '->', processedUrl);
                        return processedUrl;
                    } else {
                        warnLog('Não foi possível extrair ID do Google Drive:', url);
                        return '';
                    }
                }
                
                // Handle Dropbox URLs
                if (url.includes('dropbox.com')) {
                    let processedUrl = url;
                    // Convert Dropbox share URL to direct image URL
                    if (url.includes('?dl=0')) {
                        processedUrl = url.replace('?dl=0', '?raw=1');
                    }
                    else if (url.includes('?dl=1')) {
                        processedUrl = url.replace('?dl=1', '?raw=1');
                    }
                    else if (!url.includes('raw=1')) {
                        processedUrl = url + (url.includes('?') ? '&raw=1' : '?raw=1');
                    }
                    debugLog('URL do Dropbox processada:', url, '->', processedUrl);
                    return processedUrl;
                }
                
                // For other URLs (Unsplash, direct image URLs, etc.), return as is
                debugLog('URL externa mantida:', url);
                return url;
                
            } catch (error) {
                errorLog('Erro ao processar URL da imagem:', error, 'URL:', url);
                return '';
            }
        }

        // Render category navigation
        function renderCategoryNavigation() {
            const container = document.getElementById('category-nav');
            if (!container || !categoriesData.length) return;

            // Sort categories by order
            const sortedCategories = categoriesData
                .filter(cat => cat.status === 'Ativo')
                .sort((a, b) => parseInt(a.ordem) - parseInt(b.ordem));

            // Add search button (lupa) first
            let html = `
                <button class="category-item search-button" data-action="search" title="Buscar produtos">
                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"></path>
                    </svg>
                </button>
            `;

            // Add category buttons
            html += sortedCategories.map(category => `
                <button class="category-item px-4 py-2 rounded-full text-sm font-medium border border-gray-300 transition-colors" 
                        data-category="${category.nome_categoria}">
                    ${category.titulo_exibicao}
                </button>
            `).join('');

            container.innerHTML = html;
            
            // Add event listeners after creating the buttons
            setupCategoryClickListeners();
            
            // Setup navigation arrows
            setupNavigationArrows();
            
            // Ativar primeira categoria real por padrão
            if (sortedCategories.length > 0) {
                setTimeout(() => {
                    updateActiveCategory(sortedCategories[0].nome_categoria);
                }, 200);
            }
        }
        
        // Função para controlar a visibilidade das setas de navegação
        function updateNavigationArrows() {
            // Só funciona no desktop
            if (window.innerWidth <= 768) return;
            
            const container = document.getElementById('category-nav');
            const leftArrow = document.getElementById('nav-arrow-left');
            const rightArrow = document.getElementById('nav-arrow-right');
            
            if (!container || !leftArrow || !rightArrow) return;
            
            const scrollLeft = container.scrollLeft;
            const scrollWidth = container.scrollWidth;
            const clientWidth = container.clientWidth;
            const maxScroll = scrollWidth - clientWidth;
            
            // Seta esquerda: visível se não estiver no início
            if (scrollLeft <= 5) {
                leftArrow.style.opacity = '0';
                leftArrow.style.pointerEvents = 'none';
            } else {
                leftArrow.style.opacity = '1';
                leftArrow.style.pointerEvents = 'auto';
            }
            
            // Seta direita: visível se não estiver no final
            if (scrollLeft >= maxScroll - 5) {
                rightArrow.style.opacity = '0';
                rightArrow.style.pointerEvents = 'none';
            } else {
                rightArrow.style.opacity = '1';
                rightArrow.style.pointerEvents = 'auto';
            }
        }
        
        // Função para rolar as categorias
        function scrollCategories(direction) {
            const container = document.getElementById('category-nav');
            if (!container) return;
            
            const scrollAmount = 200; // Quantidade de pixels para rolar
            const currentScroll = container.scrollLeft;
            
            if (direction === 'left') {
                container.scrollTo({
                    left: currentScroll - scrollAmount,
                    behavior: 'smooth'
                });
            } else {
                container.scrollTo({
                    left: currentScroll + scrollAmount,
                    behavior: 'smooth'
                });
            }
        }
        
        // Configurar event listeners das setas
        function setupNavigationArrows() {
            const leftArrow = document.getElementById('nav-arrow-left');
            const rightArrow = document.getElementById('nav-arrow-right');
            const container = document.getElementById('category-nav');
            
            if (!leftArrow || !rightArrow || !container) return;
            
            // Event listeners para as setas
            leftArrow.addEventListener('click', () => scrollCategories('left'));
            rightArrow.addEventListener('click', () => scrollCategories('right'));
            
            // Event listener para scroll do container
            container.addEventListener('scroll', updateNavigationArrows);
            
            // Event listener para resize da janela
            window.addEventListener('resize', updateNavigationArrows);
            
            // Atualizar setas inicialmente
            setTimeout(updateNavigationArrows, 100);
        }
        
        // Setup click listeners for category buttons
        function setupCategoryClickListeners() {
            const categoryButtons = document.querySelectorAll('.category-item');
            categoryButtons.forEach(button => {
                button.addEventListener('click', function() {
                    // Verificar se é o botão de busca
                    if (this.getAttribute('data-action') === 'search') {
                        const searchInput = document.getElementById('search');
                        if (searchInput) {
                            searchInput.focus();
                            searchInput.scrollIntoView({
                                behavior: 'smooth',
                                block: 'center'
                            });
                        }
                        return;
                    }
                    
                    // Botão de categoria normal
                    const category = this.getAttribute('data-category');
                    if (category) {
                        scrollToCategory(category);
                    }
                });
            });
        }

        // Render menu sections
        function renderMenu() {
            const container = document.getElementById('menu-content');
            if (!container || !isDataLoaded) return;
            
            let html = '';

            // Sort categories by order and render
            const sortedCategories = categoriesData
                .filter(cat => cat.status === 'Ativo')
                .sort((a, b) => parseInt(a.ordem) - parseInt(b.ordem));

            sortedCategories.forEach(categoryInfo => {
                const categoryKey = categoryInfo.nome_categoria;
                const items = menuData[categoryKey] || [];
                
                if (items.length === 0) return;

                html += `
                    <section id="${categoryKey}" class="mb-8">
                        <div class="flex items-center justify-between mb-4 sticky top-[144px] py-2 z-20" style="background:var(--cor-fundo)">
                            <div>
                                <h2 class="text-xl font-bold text-gray-900">${categoryInfo.titulo_exibicao}</h2>
                                <p class="text-sm text-gray-600">${categoryInfo.descricao}</p>
                            </div>
                            <button onclick="shareCategory('${categoryKey}')" class="p-1 rounded transition-colors" style="color: var(--cor-texto)" onmouseenter="this.style.color='var(--cor-terciaria-escura)'" onmouseleave="this.style.color='var(--cor-texto)'" title="Compartilhar categoria">
                                <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8.684 13.342C8.886 12.938 9 12.482 9 12c0-.482-.114-.938-.316-1.342m0 2.684a3 3 0 110-2.684m0 2.684l6.632 3.316m-6.632-6l6.632-3.316m0 0a3 3 0 105.367-2.684 3 3 0 00-5.367 2.684zm0 9.316a3 3 0 105.367 2.684 3 3 0 00-5.367-2.684z"></path>
                                </svg>
                            </button>
                        </div>
                        <div class="space-y-3">
                            ${items.map(item => {
                                // Verificar se o item tem variações
                                const hasVariations = item.classificacaoAdicional && 
                                    (item.classificacaoAdicional.startsWith('#Var:') || 
                                     item.classificacaoAdicional.startsWith('Var:') ||
                                     item.classificacaoAdicional.startsWith('#'));
                                
                                // Verificar se o item tem preços múltiplos
                                const priceType = getPriceType(item.preco);
                                const needsModal = hasVariations || priceType === 'multiple';
                                
                                // Criar o selo de destaque se existir
                                let badgeHtml = '';
                                if (item.destaque && item.destaque.trim() !== '') {
                                    badgeHtml = `<div class="absolute top-0 left-0 bg-amber-500 text-white text-xs font-bold px-3 py-1 rounded-br-lg rounded-tl-lg shadow-md z-10">${item.destaque}</div>`;
                                }
                                
                                return `
                                <div class="food-card bg-white rounded-lg p-4 shadow-sm border border-gray-100 relative cursor-pointer hover:shadow-md transition-shadow duration-300" onclick="openProductModal(${item.id})">
                                    ${badgeHtml}
                                    <div class="flex items-center space-x-4">
                                        <div class="flex-shrink-0 w-24 h-24 bg-gray-100 rounded-lg" style="background: linear-gradient(90deg, #f0f0f0 25%, #e0e0e0 50%, #f0f0f0 75%); background-size: 200% 100%; animation: shimmer 1.5s infinite;">
                                            <img data-src="${processImageUrl(item.imagem)}" alt="${item.nome}" class="w-24 h-24 object-cover rounded-lg lazy-image" width="96" height="96" loading="lazy" onerror="this.style.display='none'; errorLog('Erro ao carregar imagem do item:', this.src, 'Item:', '${item.nome}');">
                                        </div>
                                        <div class="flex-1 min-w-0">
                                            <div class="flex items-start justify-between">
                                                <h3 class="font-semibold text-gray-900 truncate pr-2">${item.nome}</h3>
                                            </div>
                                            <p class="text-sm text-gray-600 line-clamp-2 mt-1">${item.descricao}</p>
                                            <!-- Preço em linha própria -->
                                            <div class="mt-3">
                                                <span class="text-base font-bold" style="color: var(--cor-secundaria)">${getPriceDisplay(item.preco)}</span>
                                            </div>
                                            <!-- Botão em linha própria -->
                                            <div class="mt-3 flex justify-end items-center">
                                                ${needsModal ? `<span class="text-xs text-gray-500 bg-gray-100 px-2 py-1 rounded-md flex items-center space-x-1 mr-8"><svg class="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16"/></svg><span>Opções</span></span>` : ''}
                                                <button class="add-to-cart-btn text-white px-4 py-2 rounded-lg text-sm font-medium transition-all duration-300" 
                                                    style="background-color: var(--cor-primaria)"
                                                    onmouseenter="this.style.backgroundColor='var(--cor-primaria-escura)'" onmouseleave="this.style.backgroundColor='var(--cor-primaria)'"
                                                    onclick="event.stopPropagation(); ${needsModal ? 'openProductModal(' + item.id + ')' : 'addToCart(' + item.id + ')'}">
                                                    <div class="flex items-center space-x-1.5">
                                                        <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 3h2l.4 2M7 13h10l4-8H5.4m1.6 8L6 5H3m4 8a2 2 0 100 4 2 2 0 000-4zm10 0a2 2 0 100 4 2 2 0 000-4z"/>
                                                        </svg>
                                                        <span>Add</span>
                                                    </div>
                                                </button>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                                `;
                            }).join('')}
                        </div>
                    </section>
                `;
            });

            container.innerHTML = html;
        }

        // Open product modal
        function openProductModal(productId) {
            const product = findProductById(productId);
            if (!product) return;

            currentProduct = product;
            selectedVariations = {};
            const modal = document.getElementById('product-modal');
            
            // Hide cart FAB when modal opens
            document.getElementById('cart-fab').style.display = 'none';
            const content = document.getElementById('modal-content');
            
            const variations = parseVariations(product.classificacaoAdicional);
            let variationsHtml = '';
            
            // ✅ VERIFICAR CHECKOUT MODE PARA VARIAÇÕES
            const checkoutConfig = getCheckoutConfig();
            const isCheckoutEnabled = checkoutConfig.checkout_mode && checkoutConfig.checkout_mode.toLowerCase() === 'sim';
            debugLog('🛍️ Checkout habilitado para variações:', isCheckoutEnabled);
            
            if (variations) {
                if (variations.type === 'multiple_variations') {
                    // Novo formato - múltiplas variações
                    debugLog('🎯 Renderizando múltiplas variações:', variations.variations);
                    
                    variationsHtml = variations.variations.map((variation, variationIndex) => {
                        const inputType = variation.type;
                        const requiredText = variation.required ? ' *' : '';
                        const removalBadge = variation.isRemoval ? ' <span class="text-xs bg-red-100 text-red-600 px-2 py-1 rounded ml-2">🚫 Remoção</span>' : '';
                        const inputName = variation.type === 'radio' ? `variation-${variationIndex}` : `variation-${variationIndex}`;
                        
                        // Criar texto de limites de seleção (apenas se checkout habilitado)
                        let limitsText = '';
                        if (isCheckoutEnabled && variation.type === 'checkbox') {
                            if (variation.minSelect && variation.maxSelect) {
                                if (variation.minSelect === variation.maxSelect) {
                                    limitsText = ` <span class="text-xs text-gray-500">(Selecione exatamente ${variation.minSelect})</span>`;
                                } else {
                                    limitsText = ` <span class="text-xs text-gray-500">(Selecione ${variation.minSelect}-${variation.maxSelect})</span>`;
                                }
                            } else if (variation.maxSelect) {
                                limitsText = ` <span class="text-xs text-gray-500">(Máximo ${variation.maxSelect})</span>`;
                            } else if (variation.minSelect) {
                                limitsText = ` <span class="text-xs text-gray-500">(Mínimo ${variation.minSelect})</span>`;
                            }
                        }
                        
                        return `
                            <div class="mb-6 border-t pt-4 variation-container" data-variation-index="${variationIndex}" data-variation-type="${variation.type}" data-min-select="${variation.minSelect || 0}" data-max-select="${variation.maxSelect || 0}">
                                <h4 class="font-medium text-gray-900 mb-3">${variation.name}${requiredText}${removalBadge}${limitsText}</h4>
                                <div class="space-y-2">
                                    ${variation.options.map((option, optionIndex) => {
                                        const uniqueId = `${variationIndex}-${optionIndex}`;
                                        const priceDisplay = option.price > 0 ? 
                                            `<span class="text-green-600 font-medium">+${formatCurrency(option.price)}</span>` : 
                                            option.price < 0 ? 
                                                `<span class="text-red-600 font-medium">${formatCurrency(option.price)}</span>` : 
                                                '';
                                        
                                        // ✅ RENDERIZAR COM OU SEM INPUT BASEADO NO CHECKOUT MODE
                                        if (isCheckoutEnabled) {
                                            // MODO LOJA: Variações selecionáveis
                                            return `
                                                <label class="flex items-center justify-between p-3 border rounded-lg cursor-pointer hover:bg-gray-50">
                                                    <div class="flex items-center">
                                                        <input type="${inputType}" 
                                                               name="${inputName}" 
                                                               value="${uniqueId}" 
                                                               id="variation-${uniqueId}"
                                                               onchange="handleMultipleVariationChange('${variationIndex}', '${optionIndex}', '${option.name}', ${option.price}, '${variation.type}', ${variation.required}, ${variation.isRemoval || false})" 
                                                               class="mr-3">
                                                        <span>${option.name}</span>
                                                    </div>
                                                    <div class="flex items-center space-x-2">
                                                        ${priceDisplay}
                                                        ${inputType === 'radio' ? `<button type="button" onclick="clearVariationSelection('${inputName}', '${variationIndex}')" class="clear-variation-btn text-xs text-gray-400 hover:text-red-500 ml-2 px-2 py-1 rounded transition-colors" title="Limpar seleção" style="display: none;">❌</button>` : ''}
                                                    </div>
                                                </label>
                                            `;
                                        } else {
                                            // MODO CATÁLOGO: Variações apenas informativas
                                            return `
                                                <div class="flex items-center justify-between p-3 border rounded-lg bg-gray-50">
                                                    <div class="flex items-center">
                                                        <span class="w-5 h-5 mr-3 flex items-center justify-center text-gray-400">
                                                            ${inputType === 'radio' ? '◦' : '▫'}
                                                        </span>
                                                        <span class="text-gray-700">${option.name}</span>
                                                    </div>
                                                    <div class="flex items-center space-x-2">
                                                        ${priceDisplay}
                                                    </div>
                                                </div>
                                            `;
                                        }
                                    }).join('')}
                                </div>
                            </div>
                        `;
                    }).join('');
                    
                } else if (variations.type === 'variation') {
                    // Formato legado - variação única
                    const inputType = variations.required ? 'radio' : 'checkbox';
                    const requiredText = variations.required ? ' *' : '';
                    
                    variationsHtml = `
                        <div class="mb-6 border-t pt-4">
                            <h4 class="font-medium text-gray-900 mb-3">Opções${requiredText}</h4>
                            <div class="space-y-2">
                                ${variations.options.map((option, index) => {
                                    const priceDisplay = option.price > 0 ? `<span class="text-green-600 font-medium">+${formatCurrency(option.price)}</span>` : '';
                                    
                                    // ✅ RENDERIZAR COM OU SEM INPUT BASEADO NO CHECKOUT MODE
                                    if (isCheckoutEnabled) {
                                        // MODO LOJA: Variações selecionáveis
                                        return `
                                            <label class="flex items-center justify-between p-3 border rounded-lg cursor-pointer hover:bg-gray-50">
                                                <div class="flex items-center">
                                                    <input type="${inputType}" name="variation-${productId}" value="${index}" 
                                                           onchange="handleVariationChange(${index}, '${option.name}', ${option.price}, ${variations.required})" 
                                                           class="mr-3">
                                                    <span>${option.name}</span>
                                                </div>
                                                ${priceDisplay}
                                            </label>
                                        `;
                                    } else {
                                        // MODO CATÁLOGO: Variações apenas informativas
                                        return `
                                            <div class="flex items-center justify-between p-3 border rounded-lg bg-gray-50">
                                                <div class="flex items-center">
                                                    <span class="w-5 h-5 mr-3 flex items-center justify-center text-gray-400">
                                                        ${inputType === 'radio' ? '◦' : '▫'}
                                                    </span>
                                                    <span class="text-gray-700">${option.name}</span>
                                                </div>
                                                ${priceDisplay}
                                            </div>
                                        `;
                                    }
                                }).join('')}
                            </div>
                        </div>
                    `;
                } else if (variations.type === 'info') {
                    // Texto informativo
                    variationsHtml = `
                        <div class="mb-6 border-t pt-4">
                            <div class="bg-blue-50 border border-blue-200 rounded-lg p-3">
                                <div class="flex items-start">
                                    <svg class="w-5 h-5 mt-0.5 mr-2 flex-shrink-0" style="color: var(--cor-terciaria)" fill="currentColor" viewBox="0 0 20 20">
                                        <path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2v-3a1 1 0 00-1-1H9z" clip-rule="evenodd"></path>
                                    </svg>
                                    <p class="text-sm text-blue-800">${variations.text}</p>
                                </div>
                            </div>
                        </div>
                    `;
                }
            }

            content.innerHTML = `
                <div class="relative">
                    <img src="${processImageUrl(product.imagem)}" alt="${product.nome}" class="w-full h-96 object-cover rounded-t-2xl sm:rounded-t-2xl cursor-pointer hover:opacity-90 transition-opacity lazy-image" loading="eager" onerror="errorLog('Erro ao carregar imagem do modal:', this.src, 'Produto:', '${product.nome}'); this.src='${getPlaceholderImage()}'" onload="this.classList.add('loaded'); debugLog('Imagem do modal carregada:', this.src)" onclick="openLightbox('${processImageUrl(product.imagem)}', '${product.nome}')" style="background: linear-gradient(90deg, #f0f0f0 25%, #e0e0e0 50%, #f0f0f0 75%); background-size: 200% 100%; animation: shimmer 1.5s infinite; max-height: 400px;">
                    <div class="absolute bottom-2 left-2 bg-black bg-opacity-70 text-white px-2 py-1 rounded text-xs font-mono">
                        ${product.sku}
                    </div>

                </div>
                <div class="px-6 pt-6 pb-4">
                    <h3 class="text-xl font-bold text-gray-900 mb-2">${product.nome}</h3>
                    <p class="text-gray-600 mb-4">${product.descricao}</p>
                    ${product.observacoes && product.observacoes.trim() ? `
                        <div class="flex items-start space-x-2 mb-4 py-1 px-2 rounded" style="background-color: var(--cor-fundo-secundario);">
                            <svg class="w-4 h-4 mt-0.5 flex-shrink-0" style="color: var(--cor-primaria);" fill="currentColor" viewBox="0 0 20 20">
                                <path fill-rule="evenodd" d="M7.293 14.707a1 1 0 010-1.414L10.586 10 7.293 6.707a1 1 0 011.414-1.414l4 4a1 1 0 010 1.414l-4 4a1 1 0 01-1.414 0z" clip-rule="evenodd"/>
                            </svg>
                            <p class="text-sm" style="color: var(--cor-texto); line-height: 1.4;">${product.observacoes}</p>
                        </div>
                    ` : ''}
                    <div class="flex items-center justify-between mb-6">
                        <span class="text-2xl font-bold" style="color: var(--cor-secundaria)"><span id="base-price">${getBasePriceDisplay(product.preco)}</span></span>
                    </div>
                    ${(() => {
                        const priceType = getPriceType(product.preco);
                        if (priceType === 'multiple') {
                            const prices = parseMultiplePrices(product.preco);
                            const dynamicLabel = getMultiplePricesLabel(product.preco);
                            return `
                                <div class="mb-6 border-t pt-4">
                                    <h4 class="text-lg font-semibold text-gray-900 mb-3">
                                        ${dynamicLabel} <span class="text-red-500">*</span>
                                    </h4>
                                    <div class="space-y-2">
                                        ${prices.map((priceOption, index) => `
                                            <label class="flex items-center justify-between p-3 border rounded-lg cursor-pointer hover:bg-gray-50 transition-colors base-price-option" data-price="${priceOption.price}" data-name="${priceOption.name}">
                                                <div class="flex items-center">
                                                    <input type="radio" name="base-price" value="${priceOption.price}" id="base-price-${index}" class="mr-3" onchange="updateBasePrice(${priceOption.price}, '${priceOption.name}')">
                                                    <span class="font-medium">${priceOption.name}</span>
                                                </div>
                                                <div class="flex items-center space-x-2">
                                                    <span class="font-bold" style="color: var(--cor-secundaria)">${formatCurrency(priceOption.price)}</span>
                                                    <button type="button" onclick="clearBasePriceSelection()" class="clear-price-btn text-xs text-gray-400 hover:text-red-500 ml-2 px-2 py-1 rounded transition-colors" title="Limpar seleção" style="display: none;">❌</button>
                                                </div>
                                            </label>
                                        `).join('')}
                                    </div>
                                </div>
                            `;
                        }
                        return '';
                    })()}
                    ${variationsHtml}
                    ${(() => {
                        const checkoutConfig = getCheckoutConfig();
                        // ✅ OCULTAR OBSERVAÇÕES QUANDO CHECKOUT_MODE = "NÃO"
                        const isCheckoutEnabled = checkoutConfig.checkout_mode && checkoutConfig.checkout_mode.toLowerCase() === 'sim';
                        const showObservations = checkoutConfig.step1_itens_obs === 'Sim' && isCheckoutEnabled;
                        debugLog('🗒️ Mostrar observações do produto:', showObservations, '(checkout:', isCheckoutEnabled, ', step1_itens_obs:', checkoutConfig.step1_itens_obs, ')');
                        
                        return showObservations ? `
                    <div class="mb-6">
                        <label class="block text-sm font-medium text-gray-700 mb-2">Observações</label>
                        <textarea id="product-notes" class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:border-transparent" style="--tw-ring-color: var(--cor-primaria)" rows="2" placeholder="Alguma observação especial para este item?" onfocus="scrollToField(this)" onblur="resetModalScroll()"></textarea>
                    </div>` : '';
                    })()}
                </div>
                <div class="modal-footer">
                    <!-- Layout Híbrido Minimalista -->
                    <div class="space-y-3">
                        <!-- Linha Superior: Quantidade e Subtotal Lado a Lado -->
                        <div class="grid grid-cols-2 gap-4">
                            <!-- Coluna 1: Controles de Quantidade -->
                            <div class="text-center">
                                <div class="text-sm font-medium text-gray-700 mb-2">Quantidade</div>
                                <div class="flex items-center justify-center">
                                    <div class="flex items-center space-x-2 bg-gray-50 rounded-full px-3 py-2">
                                        <button onclick="changeQuantity(-1)" class="bg-white hover:bg-gray-100 rounded-full w-9 h-9 flex items-center justify-center text-gray-600 shadow-sm transition-colors">
                                            <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M20 12H4"></path>
                                            </svg>
                                        </button>
                                        <span id="modal-quantity" class="font-bold text-lg min-w-[2rem] text-center">1</span>
                                        <button onclick="changeQuantity(1)" class="bg-white hover:bg-gray-100 rounded-full w-9 h-9 flex items-center justify-center text-gray-600 shadow-sm transition-colors">
                                            <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6v6m0 0v6m0-6h6m-6 0H6"></path>
                                            </svg>
                                        </button>
                                    </div>
                                </div>
                            </div>
                            
                            <!-- Coluna 2: Subtotal -->
                            <div class="text-center px-6">
                                <div class="text-sm font-medium text-gray-700 mb-2">Subtotal</div>
                                <div class="py-2">
                                    <div class="font-bold text-lg" style="color: var(--cor-secundaria)"><span id="modal-total">${formatCurrency(product.preco)}</span></div>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Linha Inferior: Botão Adicionar Full Width com Padding Aumentado -->
                        <div class="px-6">
                            <button onclick="addToCartFromModal()" id="add-to-cart-btn" class="w-full text-white py-3 px-6 rounded-lg font-medium transition-colors text-base" style="background-color: var(--cor-primaria)" onmouseenter="this.style.backgroundColor='var(--cor-primaria-hover)'" onmouseleave="this.style.backgroundColor='var(--cor-primaria)'">
                                <div class="flex items-center justify-center space-x-2">
                                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 3h2l.4 2M7 13h10l4-8H5.4m1.6 8L6 5H3m4 8a2 2 0 100 4 2 2 0 000-4zm10 0a2 2 0 000 4 2 2 0 000-4z"/>
                                    </svg>
                                    <span>Adicionar ao Carrinho</span>
                                </div>
                            </button>
                        </div>
                    </div>
                </div>
            `;

            modal.classList.remove('hidden');
            
            // Reset scroll do modal para sempre começar do topo
            const modalScrollContainer = modal.querySelector('.overflow-y-auto');
            if (modalScrollContainer) {
                modalScrollContainer.scrollTop = 0;
                if (typeof debugLog === 'function') {
                    debugLog('📜 Scroll do modal resetado para o topo');
                }
            }
            
            // Desabilitar scroll do body quando modal abre
            document.body.style.overflow = 'hidden';
            if (typeof debugLog === 'function') {
                debugLog('🚫 Scroll do body desabilitado durante modal');
            }
            
            // Inicializar cálculos do modal
            updateModalPricing();
            updateAddToCartButton();
            
            // Inicializar botões de limpar seleção
            setTimeout(toggleClearButtons, 200);
        }

        /**
         * Retorna uma imagem de placeholder em formato SVG (data URI).
         * Usado como fallback quando uma imagem de produto não carrega.
         * @returns {string} - A data URI da imagem SVG.
         */
        function getPlaceholderImage() {
            // Retorna um SVG cinza simples como placeholder
            return "data:image/svg+xml;charset=UTF-8,%3csvg width='80' height='80' xmlns='http://www.w3.org/2000/svg' viewBox='0 0 80 80'%3e%3crect fill='%23f0f0f0' width='80' height='80'/%3e%3c/svg%3e";
        }


        // Handle variation change (formato legado)
        function handleVariationChange(index, name, price, isRequired) {
            debugLog('🔧 handleVariationChange chamada:', { index, name, price, isRequired });
            
            const variations = parseVariations(currentProduct.classificacaoAdicional);
            
            if (isRequired) {
                // Radio button - single selection
                selectedVariations = { [index]: { name, price } };
                debugLog('🔘 Variação obrigatória selecionada:', selectedVariations);
            } else {
                // Checkbox - multiple selection
                const checkbox = event.target;
                if (checkbox.checked) {
                    selectedVariations[index] = { name, price };
                    debugLog('✅ Variação opcional marcada:', selectedVariations);
                } else {
                    delete selectedVariations[index];
                    debugLog('❌ Variação opcional desmarcada:', selectedVariations);
                }
            }
            
            updateModalPricing();
            updateAddToCartButton();
        }

        // Handle multiple variation change (novo formato)
        function handleMultipleVariationChange(variationIndex, optionIndex, name, price, type, isRequired, isRemoval) {
            debugLog('🎯 handleMultipleVariationChange chamada:', { 
                variationIndex, optionIndex, name, price, type, isRequired, isRemoval 
            });
            
            const uniqueKey = `${variationIndex}-${optionIndex}`;
            const variations = parseVariations(currentProduct.classificacaoAdicional);
            
            if (type === 'radio') {
                // Radio button - limpar outras seleções da mesma variação
                Object.keys(selectedVariations).forEach(key => {
                    if (key.startsWith(`${variationIndex}-`)) {
                        delete selectedVariations[key];
                    }
                });
                selectedVariations[uniqueKey] = { 
                    name, 
                    price, 
                    variationIndex: parseInt(variationIndex),
                    optionIndex: parseInt(optionIndex),
                    variationName: getCurrentVariationName(variationIndex),
                    isRemoval: isRemoval || false
                };
                debugLog('🔘 Radio selecionado:', selectedVariations);
            } else if (type === 'checkbox') {
                // Checkbox - validar limites antes de processar
                const checkbox = event.target;
                
                if (checkbox.checked) {
                    // Verificar limite máximo antes de adicionar
                    const currentVariation = variations?.variations?.[variationIndex];
                    if (currentVariation && currentVariation.maxSelect > 0) {
                        const currentSelections = Object.keys(selectedVariations).filter(key => 
                            key.startsWith(`${variationIndex}-`)
                        ).length;
                        
                        if (currentSelections >= currentVariation.maxSelect) {
                            checkbox.checked = false;
                            showNotification(`Máximo de ${currentVariation.maxSelect} opções permitidas em "${currentVariation.name}"!`, 'warning', 3000);
                            return; // Parar execução aqui
                        }
                    }
                    
                    // Se passou na validação, adicionar seleção
                    selectedVariations[uniqueKey] = { 
                        name, 
                        price, 
                        variationIndex: parseInt(variationIndex),
                        optionIndex: parseInt(optionIndex),
                        variationName: getCurrentVariationName(variationIndex),
                        isRemoval: isRemoval || false
                    };
                    debugLog('✅ Checkbox marcado:', selectedVariations);
                } else {
                    delete selectedVariations[uniqueKey];
                    debugLog('❌ Checkbox desmarcado:', selectedVariations);
                }
            }
            
            updateModalPricing();
            updateAddToCartButton();
            
            // Atualizar visibilidade dos botões de limpar
            setTimeout(toggleClearButtons, 100);
        }

        // Função auxiliar para obter o nome da variação
        function getCurrentVariationName(variationIndex) {
            const variations = parseVariations(currentProduct.classificacaoAdicional);
            if (variations && variations.type === 'multiple_variations') {
                return variations.variations[variationIndex]?.name || '';
            }
            return '';
        }

        // Atualizar preço base selecionado
        function updateBasePrice(price, name) {
            if (!currentProduct) return;
            
            // Armazenar preço base selecionado
            currentProduct.selectedBasePrice = price;
            currentProduct.selectedBaseName = name;
            
            // Atualizar display do preço
            const basePriceElement = document.getElementById('base-price');
            if (basePriceElement) {
                basePriceElement.textContent = formatCurrency(price);
            }
            
            // Atualizar cálculos do modal
            updateModalPricing();
            updateAddToCartButton();
            
            if (typeof debugLog === 'function') {
                debugLog('💰 Preço base atualizado:', { price, name });
            }
            
            // Atualizar visibilidade dos botões de limpar
            setTimeout(toggleClearButtons, 100);
        }

        // Update modal pricing
        function updateModalPricing() {
            const priceType = getPriceType(currentProduct.preco);
            let basePrice = 0;
            
            // Calcular preço base baseado no tipo
            if (priceType === 'multiple') {
                basePrice = currentProduct.selectedBasePrice || 0;
            } else if (priceType === 'fixed') {
                basePrice = parsePrice(currentProduct.preco);
            } else if (priceType === 'promotional') {
                const priceParts = currentProduct.preco.split('>');
                // Pega o novo preço (a parte depois do '>')
                basePrice = parsePrice(priceParts[1]);
            }
            // consultation = 0 (não soma)
            
            // Calcular preço das variações com debug detalhado
            const variationPrices = Object.values(selectedVariations).map(v => ({ name: v.name, price: v.price }));
            const variationPrice = variationPrices.reduce((sum, variation) => sum + variation.price, 0);
            const totalPrice = basePrice + variationPrice;
            const quantity = parseInt(document.getElementById('modal-quantity').textContent);
            
            // Debug detalhado
            if (typeof debugLog === 'function') {
                debugLog('📊 Detalhes do cálculo:', {
                    basePrice,
                    selectedVariations,
                    variationPrices,
                    variationPrice,
                    totalPrice,
                    quantity,
                    finalPrice: totalPrice * quantity
                });
            }
            
            const modalTotalElement = document.getElementById('modal-total');
            if (modalTotalElement) {
                if (priceType === 'consultation') {
                    modalTotalElement.innerHTML = '<span style="color: var(--cor-secundaria); font-weight: bold;">💬 Consulte</span>';
                } else if (priceType === 'multiple' && !currentProduct.selectedBasePrice) {
                    // Aguardando seleção de preço base
                    const dynamicLabel = getMultiplePricesLabel(currentProduct.preco);
                    modalTotalElement.innerHTML = `<span style="color: var(--cor-texto-secundario); font-style: italic; font-size: 0.6em;">Aguardando ${dynamicLabel.toLowerCase()}</span>`;
                } else {
                    modalTotalElement.textContent = formatCurrency(totalPrice * quantity);
                }
            }
        }

        // Update add to cart button
        function updateAddToCartButton() {
            const variations = parseVariations(currentProduct.classificacaoAdicional);
            const button = document.getElementById('add-to-cart-btn');
            const priceType = getPriceType(currentProduct.preco);
            
            // Verificar se preço base é obrigatório para preços múltiplos
            if (priceType === 'multiple' && (!currentProduct.selectedBasePrice || currentProduct.selectedBasePrice <= 0)) {
                button.disabled = true;
                button.classList.add('opacity-50', 'cursor-not-allowed');
                return;
            }
            
            if (variations && variations.type === 'multiple_variations') {
                // Novo formato - verificar variações obrigatórias
                const allRequiredSelected = variations.variations
                    .filter(v => v.required)
                    .every((requiredVar, index) => {
                        const variationIndex = variations.variations.indexOf(requiredVar);
                        return Object.keys(selectedVariations).some(key => key.startsWith(`${variationIndex}-`));
                    });
        
                button.disabled = !allRequiredSelected;
                button.classList.toggle('opacity-50', !allRequiredSelected);
                button.classList.toggle('cursor-not-allowed', !allRequiredSelected);
            } else if (variations && variations.type === 'variation' && variations.required) {
                // Formato legado - variação única obrigatória
                const hasSelection = Object.keys(selectedVariations).length > 0;
                button.disabled = !hasSelection;
                button.classList.toggle('opacity-50', !hasSelection);
                button.classList.toggle('cursor-not-allowed', !hasSelection);
            } else {
                // Sem variações
                button.disabled = false;
                button.classList.remove('opacity-50', 'cursor-not-allowed');
            }
        }

        // Close modal
        function closeModal(event) {
            if (event && event.target !== event.currentTarget) return;
            document.getElementById('product-modal').classList.add('hidden');
            currentProduct = null;
            selectedVariations = {};
            
            // Clear product notes field
            const notesField = document.getElementById('product-notes');
            if (notesField) {
                notesField.value = '';
            }
            
            // Show cart FAB again when modal closes (if cart has items)
            const cartCount = cart.reduce((sum, item) => sum + item.quantity, 0);
            if (cartCount > 0) {
                document.getElementById('cart-fab').style.display = 'flex';
            }
            
            // Reabilitar scroll do body quando modal fecha
            document.body.style.overflow = '';
            debugLog('✅ Scroll enabled after modal close');
        }

        // Change quantity in modal
        function changeQuantity(delta) {
            const quantityEl = document.getElementById('modal-quantity');
            let quantity = parseInt(quantityEl.textContent) + delta;
            
            if (quantity < 1) quantity = 1;
            
            quantityEl.textContent = quantity;
            updateModalPricing();
        }

        // Add to cart from modal
        function addToCartFromModal() {
            debugLog('=== INÍCIO addToCartFromModal ===');
            
            // Verificar estado do botão
            const button = document.getElementById('add-to-cart-btn');
            debugLog('🔘 Estado do botão:', {
                disabled: button.disabled,
                classList: Array.from(button.classList),
                style: button.style.cssText
            });
            
            debugLog('🛍️ Adding to cart from modal');
            debugLog('📦 Produto atual:', currentProduct);
            debugLog('🔧 Variações selecionadas:', selectedVariations);
            
            const variations = parseVariations(currentProduct.classificacaoAdicional);
            debugLog('📋 Variações parseadas:', variations);
            
            // Validar todas as variações usando a nova função de validação
            debugLog('🔍 Validando todas as variações...');
            
            if (!validateAllVariations()) {
                debugLog('❌ Validação de variações falhou - BLOQUEANDO!');
                return;
            }
            
            debugLog('✅ Validação de variações passou!');
            
            // Fallback para formato legado
            if (variations && variations.type === 'variation' && variations.required && Object.keys(selectedVariations).length === 0) {
                debugLog('❌ Variação obrigatória (formato legado) não selecionada - BLOQUEANDO!');
                showNotification('Por favor, selecione uma opção obrigatória', 'warning', 4000);
                return;
            }
            
            debugLog('✅ Verificação de variações obrigatórias passou!');
            
            const quantity = parseInt(document.getElementById('modal-quantity').textContent);
            const notesElement = document.getElementById('product-notes');
            const notes = notesElement ? notesElement.value.trim() : '';
            
            debugLog('📊 Quantidade:', quantity);
            debugLog('📝 Observações:', notes);
            debugLog('✅ Chamando addToCart...');
            
            addToCart(currentProduct.id, quantity, selectedVariations, notes, true); // true = chamada do modal
            closeModal();
        }

        // Add to cart
        function addToCart(productId, quantity = 1, variations = {}, notes = '', fromModal = false) {
            if (typeof debugLog === 'function') {
                debugLog('🛍️ Adding to cart:', productId, 'qty:', quantity);
            }
            
            const product = findProductById(productId);
            if (!product) {
                if (typeof debugLog === 'function') {
                    debugLog('❌ Produto não encontrado:', productId);
                }
                return;
            }
            
            if (typeof debugLog === 'function') {
                debugLog('📦 Produto encontrado:', product);
            }

            // Check if product has ANY variations (required or optional) and none are provided
            const productVariations = parseVariations(product.classificacaoAdicional);
            if (typeof debugLog === 'function') {
                debugLog('🔍 Variações do produto:', productVariations);
            }
            
            if (productVariations && (productVariations.type === 'variation' || productVariations.type === 'multiple_variations')) {
                // If no variations provided for a product with variations, open modal to show options
                // BUT only if the call is NOT from the modal itself
                if (Object.keys(variations).length === 0 && !fromModal) {
                    if (typeof debugLog === 'function') {
                        debugLog('🔄 Abrindo modal - produto tem variações mas nenhuma foi fornecida');
                    }
                    openProductModal(productId);
                    return;
                } else if (fromModal) {
                    if (typeof debugLog === 'function') {
                        debugLog('📝 Chamada do modal - prosseguindo mesmo sem variações selecionadas');
                    }
                }
            }
            
            if (typeof debugLog === 'function') {
                debugLog('✅ Prosseguindo para adicionar ao carrinho...');
            }

            // Calculate variation price
            const variationPrice = Object.values(variations).reduce((sum, variation) => sum + variation.price, 0);
            
            // Calcular preço total baseado no tipo de preço do produto
            let basePrice = 0;
            const priceType = getPriceType(product.preco);
            
            if (priceType === 'fixed') {
                basePrice = parsePrice(product.preco);
            } else if (priceType === 'multiple' && product.selectedBasePrice) {
                basePrice = product.selectedBasePrice;
            } else if (priceType === 'consultation') {
                basePrice = 0; // Preço de consulta não tem valor numérico
            } else if (priceType === 'promotional') {
                const priceParts = product.preco.split('>');
                // Pega o novo preço (a parte depois do '>') para o carrinho
                basePrice = parsePrice(priceParts[1]);
            }
            
            const totalPrice = basePrice + variationPrice;
            
            // Create variation key for grouping similar items (include notes in key if present)
            const variationKey = Object.keys(variations).sort().join('-');
            const basePriceKey = (priceType === 'multiple' && product.selectedBaseName) ? `-base-${product.selectedBaseName.replace(/[^a-zA-Z0-9]/g, '')}` : '';
            const notesKey = notes ? `-notes-${btoa(notes).replace(/[^a-zA-Z0-9]/g, '')}` : '';
            const itemKey = `${productId}-${variationKey}${basePriceKey}${notesKey}`;
            
            const existingItem = cart.find(item => item.itemKey === itemKey);
            
            if (existingItem) {
                existingItem.quantity += quantity;
                
                // Salvar carrinho no localStorage
                if (typeof saveCartToStorage === 'function') {
                    saveCartToStorage();
                }
            } else {
                // Criar texto das variações baseado no formato
                let variationText = '';
                let removalText = '';
                
                // Adicionar nome do preço base selecionado para preços múltiplos
                const priceType = getPriceType(product.preco);
                if (priceType === 'multiple' && product.selectedBaseName) {
                    variationText = product.selectedBaseName;
                }
                if (Object.keys(variations).length > 0) {
                    if (productVariations && productVariations.type === 'multiple_variations') {
                        // Novo formato - separar adições e remoções
                        const additionGroups = {};
                        const removalGroups = {};
                        
                        Object.values(variations).forEach(variation => {
                            const groupName = variation.variationName || 'Opções';
                            const isRemoval = variation.isRemoval || false;
                            
                            if (isRemoval) {
                                if (!removalGroups[groupName]) {
                                    removalGroups[groupName] = [];
                                }
                                removalGroups[groupName].push(variation.name);
                            } else {
                                if (!additionGroups[groupName]) {
                                    additionGroups[groupName] = [];
                                }
                                additionGroups[groupName].push(variation.name);
                            }
                        });
                        
                        // Criar texto das adições
                        if (Object.keys(additionGroups).length > 0) {
                            const additionsText = Object.entries(additionGroups)
                                .map(([groupName, options]) => `${groupName}: ${options.join(', ')}`)
                                .join('\n     '); // Quebra linha + indentação para WhatsApp
                            
                            // Combinar preço base com adições
                            if (variationText) {
                                variationText += '\n     ' + additionsText;
                            } else {
                                variationText = additionsText;
                            }
                        }
                        
                        // Criar texto das remoções
                        if (Object.keys(removalGroups).length > 0) {
                            removalText = Object.entries(removalGroups)
                                .map(([groupName, options]) => `${groupName}: ${options.join(', ')}`)
                                .join('\n     '); // Quebra linha + indentação para WhatsApp
                        }
                    } else {
                        // Formato legado
                        const variationNames = Object.values(variations).map(v => v.name);
                        const legacyVariationsText = variationNames.join(', ');
                        
                        // Combinar preço base com variações legadas
                        if (variationText && legacyVariationsText) {
                            variationText += ', ' + legacyVariationsText;
                        } else if (legacyVariationsText) {
                            variationText = legacyVariationsText;
                        }
                    }
                }
                
                cart.push({
                    ...product,
                    itemKey: itemKey,
                    quantity: quantity,
                    preco: totalPrice,
                    variations: variations,
                    variationText: variationText,
                    removalText: removalText,
                    notes: notes
                });
                
                // Salvar carrinho no localStorage
                if (typeof saveCartToStorage === 'function') {
                    saveCartToStorage();
                }
            }
            
            if (typeof debugLog === 'function') {
                debugLog('🎉 Produto adicionado ao carrinho!');
                debugLog('🛍️ Cart updated:', cart.length, 'items');
            }

            updateCartUI();
            showAddedToCartAnimation();
        }

        // Update cart UI
        function updateCartUI() {
            const cartCount = cart.reduce((sum, item) => sum + item.quantity, 0);
            
            // Calcular total apenas de itens com preço válido (ignora consultas)
            const cartTotal = cart.reduce((sum, item) => {
                const itemPrice = parseFloat(item.preco);
                if (isNaN(itemPrice) || itemPrice <= 0) {
                    return sum; // Ignora itens de consulta ou sem preço
                }
                return sum + (itemPrice * item.quantity);
            }, 0);
            
            // Verificar se há itens com preço válido
            const hasValidPriceItems = cart.some(item => {
                const itemPrice = parseFloat(item.preco);
                return !isNaN(itemPrice) && itemPrice > 0;
            });
            
            // Verificar se há itens de consulta
            const hasConsultationItems = cart.some(item => {
                const itemPrice = parseFloat(item.preco);
                return isNaN(itemPrice) || itemPrice <= 0;
            });
            
            document.getElementById('cart-count').textContent = cartCount;
            
            // Exibir total apenas se houver itens com preço válido
            const cartTotalElement = document.getElementById('cart-total');
            const cartModalTotalElement = document.getElementById('cart-modal-total');
            
            if (hasValidPriceItems) {
                const totalText = hasConsultationItems ? 
                    `${formatCurrency(cartTotal)} + consultas` : 
                    formatCurrency(cartTotal);
                cartTotalElement.textContent = totalText;
                cartModalTotalElement.textContent = totalText;
            } else if (hasConsultationItems) {
                // Apenas itens de consulta
                cartTotalElement.textContent = '💬 Consulte';
                cartModalTotalElement.textContent = '💬 Consulte';
            } else {
                // Carrinho vazio
                cartTotalElement.textContent = formatCurrency(0);
                cartModalTotalElement.textContent = formatCurrency(0);
            }
            
            // Atualizar contador de itens no modal do carrinho
            const itemsCountElement = document.getElementById('cart-modal-items-count');
            if (itemsCountElement) {
                const itemText = cartCount === 1 ? 'item' : 'itens';
                itemsCountElement.textContent = `${cartCount} ${itemText}`;
            }
            
            // Check if checkout is enabled
            const checkoutConfig = getCheckoutConfig();
            const isCheckoutEnabled = checkoutConfig.checkout_mode && checkoutConfig.checkout_mode.toLowerCase() === 'sim';
            
            const cartFab = document.getElementById('cart-fab');
            if (cartCount > 0 && isCheckoutEnabled) {
                cartFab.classList.remove('hidden');
                // Only show if no modals are open
                const isModalOpen = !document.getElementById('product-modal').classList.contains('hidden') ||
                                   !document.getElementById('cart-modal').classList.contains('hidden') ||
                                   !document.getElementById('checkout-modal').classList.contains('hidden');
                cartFab.style.display = isModalOpen ? 'none' : 'flex';
            } else {
                cartFab.classList.add('hidden');
                cartFab.style.display = 'none';
            }
        }

        // Show added to cart animation
        function showAddedToCartAnimation() {
            const cartFab = document.getElementById('cart-fab');
            cartFab.classList.add('bounce');
            setTimeout(() => cartFab.classList.remove('bounce'), 600);
        }

        // Open cart
        async function openCart() {
            // VERIFICAR SE ESTABELECIMENTO ESTÁ ABERTO
            const isOpen = await isCurrentlyOpen();
            
            if (!isOpen) {
                showClosedModal();
                return;
            }
            
            const modal = document.getElementById('cart-modal');
            const itemsContainer = document.getElementById('cart-items');
            
            // Hide cart FAB when cart modal opens
            document.getElementById('cart-fab').style.display = 'none';
            
            if (cart.length === 0) {
                itemsContainer.innerHTML = '<p class="text-gray-500 text-center py-8">Seu carrinho está vazio</p>';
            } else {
                itemsContainer.innerHTML = cart.map(item => {
                    // Verificar se o item tem preço válido
                    const itemPrice = parseFloat(item.preco);
                    const hasValidPrice = !isNaN(itemPrice) && itemPrice > 0;
                    const itemSubtotal = hasValidPrice ? itemPrice * item.quantity : 0;
                    
                    return `
                    <div class="border border-gray-100 rounded-xl p-4 shadow-sm hover:shadow-md transition-shadow" style="background-color: white !important;">
                        <!-- Header com SKU e botão de edição -->
                        <div class="flex items-center justify-between mb-3">
                            <div class="text-xs text-gray-400 font-mono bg-gray-50 px-2 py-1 rounded">${item.sku}</div>
                            ${(() => {
                                const checkoutConfig = getCheckoutConfig();
                                return checkoutConfig.step1_itens_obs === 'Sim' ? `
                            <button onclick="editItemNotes('${item.itemKey}')" class="bg-blue-500 hover:bg-blue-600 text-white rounded-full w-7 h-7 flex items-center justify-center shadow-sm transition-all hover:scale-105" title="Editar observações">
                                <svg class="w-3.5 h-3.5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z"></path>
                                </svg>
                            </button>` : '';
                            })()
                            }
                        </div>
                        
                        <!-- Conteúdo principal -->
                        <div class="flex items-start space-x-3">
                            <!-- Imagem -->
                            <div class="flex-shrink-0">
                                <img src="${processImageUrl(item.imagem)}" alt="${item.nome}" class="w-16 h-16 object-cover rounded-lg cursor-pointer hover:opacity-90 transition-opacity" onerror="this.src='${getPlaceholderImage()}'" onclick="openImageLightbox('${processImageUrl(item.imagem)}', '${item.nome}')">
                            </div>
                            
                            <!-- Informações do produto -->
                            <div class="flex-1 min-w-0">
                                <h4 class="font-semibold text-gray-900 text-base mb-1">${item.nome}</h4>
                                
                                <!-- Variações e observações -->
                                ${item.variationText ? `<div class="text-sm text-gray-600 mb-1">
                                    <span class="text-green-600 font-medium">✓</span> ${item.variationText}
                                </div>` : ''}
                                ${item.removalText ? `<div class="text-sm text-red-600 mb-1">
                                    <span class="font-medium">🚫</span> ${item.removalText}
                                </div>` : ''}
                                ${item.notes ? `<div class="text-sm italic bg-blue-50 text-blue-700 px-2 py-1 rounded mt-2">
                                    📝 ${item.notes}
                                </div>` : ''}
                            </div>
                        </div>
                        
                        <!-- Footer com preços e controles -->
                        <div class="flex items-center justify-between mt-4 pt-3 border-t border-gray-100">
                            <!-- Preços -->
                            <div class="flex flex-col">
                                ${hasValidPrice ? 
                                    `<div class="text-xs text-gray-500">${formatCurrency(itemPrice)} cada</div>
                                     <div class="font-bold text-lg" style="color: var(--cor-secundaria)">${formatCurrency(itemSubtotal)}</div>` :
                                    `<div class="text-xs text-gray-500">Consulte o preço</div>
                                     <div class="font-bold text-lg" style="color: var(--cor-secundaria)">💬 Consulte</div>`
                                }
                            </div>
                            
                            <!-- Controles de quantidade -->
                            <div class="flex items-center space-x-3 bg-gray-50 rounded-full px-3 py-2">
                                <button onclick="updateCartQuantity('${item.itemKey}', -1)" class="bg-white hover:bg-gray-100 rounded-full w-8 h-8 flex items-center justify-center text-gray-600 shadow-sm transition-colors">
                                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M20 12H4"></path>
                                    </svg>
                                </button>
                                <span class="font-bold text-lg min-w-[2rem] text-center">${item.quantity}</span>
                                <button onclick="updateCartQuantity('${item.itemKey}', 1)" class="bg-white hover:bg-gray-100 rounded-full w-8 h-8 flex items-center justify-center text-gray-600 shadow-sm transition-colors">
                                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6v6m0 0v6m0-6h6m-6 0H6"></path>
                                    </svg>
                                </button>
                            </div>
                        </div>
                    </div>
                `;
                }).join('');
            }
            
            // Bloquear scroll da página quando modal do carrinho abre
            document.body.style.overflow = 'hidden';
            if (typeof debugLog === 'function') {
                debugLog('😫 Scroll disabled during cart modal');
            }
            
            modal.classList.remove('hidden');
        }

        // Close cart
        function closeCart(event) {
            if (event && event.target !== event.currentTarget) return;
            document.getElementById('cart-modal').classList.add('hidden');
            
            // Reabilitar scroll do body quando modal do carrinho fecha
            document.body.style.overflow = '';
            debugLog('✅ Scroll enabled after cart close');
            
            // Show cart FAB again when cart modal closes (if cart has items and checkout is enabled)
            const cartCount = cart.reduce((sum, item) => sum + item.quantity, 0);
            const checkoutConfig = getCheckoutConfig();
            const isCheckoutEnabled = checkoutConfig.checkout_mode && checkoutConfig.checkout_mode.toLowerCase() === 'sim';
            
            if (cartCount > 0 && isCheckoutEnabled) {
                document.getElementById('cart-fab').style.display = 'flex';
            }
        }

        // Prevenir scroll durante checkout modal
        function preventScrollDuringCheckout(e) {
            const checkoutModal = document.getElementById('checkout-modal');
            if (checkoutModal && !checkoutModal.classList.contains('hidden')) {
                // Verificar se o scroll está acontecendo dentro do modal
                const modalContent = checkoutModal.querySelector('.overflow-y-auto');
                if (modalContent && modalContent.contains(e.target)) {
                    // Permitir scroll dentro do modal
                    return;
                }
                // Prevenir scroll fora do modal
                e.preventDefault();
                debugLog('😫 Scroll prevented during checkout');
            }
        }

        // Limpar carrinho completamente (sem confirmação)
        function clearCart() {
            // Verificar se carrinho já está vazio
            if (cart.length === 0) {
                showNotification('Carrinho já está vazio', 'info');
                return;
            }
            
            debugLog('🗑️ Limpando carrinho diretamente...');
            
            // Limpar array do carrinho
            cart.length = 0;
            
            // Limpar carrinho do localStorage
            if (typeof clearCartFromStorage === 'function') {
                clearCartFromStorage();
            }
            
            // Atualizar interface do carrinho
            const itemsContainer = document.getElementById('cart-items');
            if (itemsContainer) {
                itemsContainer.innerHTML = '<p class="text-gray-500 text-center py-8">Seu carrinho está vazio</p>';
            }
            
            // Atualizar FAB do carrinho (contador)
            const cartCountElement = document.getElementById('cart-count');
            if (cartCountElement) {
                cartCountElement.textContent = '0';
            }
            
            // Atualizar contador de itens no modal
            const itemsCountElement = document.getElementById('cart-modal-items-count');
            if (itemsCountElement) {
                itemsCountElement.textContent = '0 itens';
            }
            
            // Esconder FAB do carrinho
            document.getElementById('cart-fab').style.display = 'none';
            
            // Fechar modal do carrinho e reabilitar scroll
            document.getElementById('cart-modal').classList.add('hidden');
            document.body.style.overflow = '';
            debugLog('✅ Cart modal closed and scroll enabled after clear');
            
            // Mostrar notificação
            showNotification('Carrinho limpo com sucesso!', 'success');
            
            debugLog('✅ Carrinho limpo com sucesso');
        }

        // Reset Step 2 - Limpa completamente o estado do step 2
        function resetStep2() {
            debugLog('=== RESET STEP 2 ===');
            
            // ====================================================================
            // 🎟️ CORREÇÃO V4.1.2: LIMPAR CUPOM AO RESETAR STEP 2
            // ====================================================================
            // Limpar cupom quando usuário volta para escolher tipo de entrega
            if (appliedCoupon) {
                debugLog('🎟️ Limpando cupom ao resetar step 2');
                clearCoupon();
                updateOrderSummary();
            }
            
            // 1. Desmarcar todos os radio buttons de tipo de entrega
            const deliveryRadios = document.querySelectorAll('input[name="delivery-type"]');
            deliveryRadios.forEach(radio => {
                radio.checked = false;
            });
            
            // 2. Limpar o orderData.deliveryType
            orderData.deliveryType = '';
            
            // 3. Limpar campos dinâmicos
            const fieldsContainer = document.getElementById('delivery-fields');
            if (fieldsContainer) {
                fieldsContainer.innerHTML = '';
            }
            
            // 4. Ocultar campos de endereço
            const addressFields = document.getElementById('address-fields');
            if (addressFields) {
                addressFields.classList.add('hidden');
            }
            
            // 5. Limpar taxa de delivery
            clearDeliveryFee();
            
            // 6. Manter botão continuar habilitado para validação
            const continueBtn = document.getElementById('step2-continue');
            if (continueBtn) {
                continueBtn.disabled = false; // Manter habilitado para mostrar erro de validação
            }
            
            // 7. Mostrar todas as opções de delivery
            showAllDeliveryOptions();
            
            // 8. Ocultar botão "outras opções"
            hideOtherOptionsButton();
            
            // 9. Reset modo endereço manual - sempre voltar para modo CEP
            const cepContainer = document.getElementById('cep-mode-container');
            const manualContainer = document.getElementById('manual-address-container');
            if (cepContainer && manualContainer) {
                cepContainer.classList.remove('hidden');
                manualContainer.classList.add('hidden');
                clearManualAddressFields();
            }
            
            // 10. Limpar timeout de busca por bairro
            if (typeof neighborhoodSearchTimeout !== 'undefined' && neighborhoodSearchTimeout) {
                clearTimeout(neighborhoodSearchTimeout);
                neighborhoodSearchTimeout = null;
                debugLog('Timeout de busca limpo');
            }
            
            debugLog('Step 2 resetado completamente');
        }

        // Proceed to checkout
        async function proceedToCheckout() {
            if (cart.length === 0) return;
            
            // Verificar se o usuário está autenticado
            const { data: { session } } = await supabase.auth.getSession();
            if (!session) {
                alert('Para finalizar o seu pedido você precisa estar logado!');
                closeCart();
                openAuthModal();
                return;
            }
            
            closeCart();
            currentStep = 2;
            showStep(2);
            document.getElementById('checkout-modal').classList.remove('hidden');
            
            // Desabilitar scroll do body quando modal abre (seguindo padrão do modal produto)
            document.body.style.overflow = 'hidden';
            document.documentElement.style.overflow = 'hidden'; // Também bloquear no html
            debugLog('😫 Scroll do body desabilitado durante checkout modal');
            
            // Adicionar listener para prevenir scroll com mouse wheel
            document.addEventListener('wheel', preventScrollDuringCheckout, { passive: false });
            document.addEventListener('touchmove', preventScrollDuringCheckout, { passive: false });
            
            // RESET COMPLETO DO STEP 2 antes de configurar
            resetStep2();
            
            // Setup delivery options based on configuration
            setupDeliveryOptions();
            
            // ===== AUTOMAÇÃO MESA URL =====
            // Verificar se há parâmetro mesa na URL e automatizar
            const mesaAutomatizada = autoMesaCheckout();
            if (mesaAutomatizada) {
                debugLog('🪑 Checkout automatizado para mesa URL');
            }
            
            // Setup payment methods based on configuration
            setupPaymentMethods();
            
            // Hide cart FAB during checkout
            document.getElementById('cart-fab').style.display = 'none';
        }
        
        // Setup payment methods based on configuration
        function setupPaymentMethods() {
            const checkoutConfig = getCheckoutConfig();
            const paymentContainer = document.querySelector('#payment-method').parentElement;
            
            debugLog('🔍 DEBUG setupPaymentMethods:', {
                step3_show_formas_pag: checkoutConfig.step3_show_formas_pag,
                deliveryType: orderData.deliveryType
            });
            
            // Check if payment methods should be shown
            if (checkoutConfig.step3_show_formas_pag !== 'Sim') {
                debugLog('❌ Payment field HIDDEN - step3_show_formas_pag !== Sim');
                paymentContainer.style.display = 'none';
                return;
            }
            
            // Define delivery types that should show payment methods
            const deliveryTypesWithPayment = ['pickup', 'delivery', 'default'];
            
            // Show payment field only for specific delivery types (pickup, delivery, default)
            if (deliveryTypesWithPayment.includes(orderData.deliveryType)) {
                debugLog('✅ Payment field SHOWN - deliveryType:', orderData.deliveryType);
                paymentContainer.style.display = 'block';
            } else {
                debugLog('❌ Payment field HIDDEN - deliveryType not allowed:', orderData.deliveryType);
                paymentContainer.style.display = 'none';
                return;
            }
            
            // Get payment methods from configuration
            const paymentMethods = checkoutConfig.step3_formas_pag;
            debugLog('📝 Payment methods from config:', paymentMethods);
            
            if (paymentMethods && paymentMethods.trim() !== '') {
                // Parse payment methods from configuration
                const methodsList = paymentMethods.split(',').map(method => method.trim());
                debugLog('📋 Methods list:', methodsList);
                const paymentSelect = document.getElementById('payment-method');
                
                // Clear existing options except the first one ("Selecione...")
                paymentSelect.innerHTML = '<option value="">Selecione...</option>';
                
                // Add payment methods from configuration
                methodsList.forEach(method => {
                    const option = document.createElement('option');
                    
                    // Use payment method name as is from spreadsheet
                    option.value = method.toLowerCase().replace(/\s+/g, '-');
                    
                    // Add emoji based on method name
                    let emoji = '💳'; // Default credit card emoji
                    if (method.toLowerCase().includes('dinheiro')) {
                        emoji = '💵';
                    } else if (method.toLowerCase().includes('pix')) {
                        emoji = '📱';
                    } else if (method.toLowerCase().includes('cartão') || method.toLowerCase().includes('cartao')) {
                        emoji = '💳';
                    } else if (method.toLowerCase().includes('alelo') || method.toLowerCase().includes('vale') || method.toLowerCase().includes('ticket')) {
                        emoji = '🎫'; // Simpler ticket emoji
                    }
                    
                    option.textContent = `${emoji} ${method}`;
                    debugLog('✅ Created option:', option.value, '=', option.textContent);
                    
                    paymentSelect.appendChild(option);
                });
            } else {
                // Se não há métodos configurados, não exibir opções
                const paymentSelect = document.getElementById('payment-method');
                paymentSelect.innerHTML = `
                    <option value="">Métodos de pagamento não configurados</option>
                `;
                paymentSelect.disabled = true;
                debugLog('⚠️ Métodos de pagamento não configurados na planilha');
            }
        }

        // Close checkout
        function closeCheckout(event) {
            if (event && event.target !== event.currentTarget) return;
            document.getElementById('checkout-modal').classList.add('hidden');
            currentStep = 2;
            
            // Reabilitar scroll do body quando modal fecha (seguindo padrão do modal produto)
            document.body.style.overflow = '';
            document.documentElement.style.overflow = '';
            debugLog('✅ Scroll enabled after checkout close');
            
            // Remover listeners de scroll
            document.removeEventListener('wheel', preventScrollDuringCheckout);
            document.removeEventListener('touchmove', preventScrollDuringCheckout);
            
            // Show cart FAB again when checkout closes (if cart has items and checkout is enabled)
            const cartCount = cart.reduce((sum, item) => sum + item.quantity, 0);
            const checkoutConfig = getCheckoutConfig();
            const isCheckoutEnabled = checkoutConfig.checkout_mode && checkoutConfig.checkout_mode.toLowerCase() === 'sim';
            
            if (cartCount > 0 && isCheckoutEnabled) {
                document.getElementById('cart-fab').style.display = 'flex';
            }
        }
        
        // Back to cart from checkout
        function backToCart() {
            // Fechar checkout
            document.getElementById('checkout-modal').classList.add('hidden');
            currentStep = 2;
            
            // Reabilitar scroll do body quando modal fecha (seguindo padrão do modal produto)
            document.body.style.overflow = '';
            document.documentElement.style.overflow = '';
            debugLog('✅ Scroll enabled after back to cart');
            
            // Remover listeners de scroll
            document.removeEventListener('wheel', preventScrollDuringCheckout);
            document.removeEventListener('touchmove', preventScrollDuringCheckout);
            
            // Abrir carrinho
            setTimeout(() => {
                openCart();
            }, 100);
        }

        // Show specific step
        function showStep(step) {
            document.querySelectorAll('.checkout-step').forEach(el => el.classList.add('hidden'));
            document.getElementById(`checkout-step-${step}`).classList.remove('hidden');
            currentStep = step;
            
            // Sempre que voltar para steps anteriores ao resumo, resetar forma de pagamento
            if (step < 3) {
                if (typeof resetPaymentState === 'function') {
                    try { resetPaymentState(); } catch (e) { errorLog('resetPaymentState on showStep error:', e); }
                }
            }
            
            // ====================================================================
            // 🏘️ CORREÇÃO V4.1.4: RENDERIZAR CAMPOS AO VOLTAR PARA STEP 2
            // ====================================================================
            // Quando voltar para step 2, re-renderizar campos de bairro para evitar conflitos
            if (step === 2) {
                setTimeout(() => {
                    if (typeof renderNeighborhoodFields === 'function') {
                        renderNeighborhoodFields();
                        debugLog('🏘️ Campos de bairro re-renderizados ao voltar para Step 2');
                    }
                }, 100);
            }
            
            // Atualizar total do pedido no Step 3
            if (step === 3) {
                updateCheckoutOrderTotal();
                
                // Inicializar monitoramento do campo de bairro quando step 3 for mostrado
                setTimeout(() => {
                    iniciarMonitoramentoRedundanteBairro();
                }, 500); // Aguardar 500ms para garantir que os campos foram renderizados
            }
        }

        // Limpa estado e UI de forma de pagamento (quando usuário volta do Step 3)
        function resetPaymentState() {
            try {
                // 1) Estado global
                if (!window.orderData) window.orderData = {};
                delete orderData.paymentMethod;      // 'pix' | 'dinheiro' | 'cartao' | ...
                delete orderData.needsChange;        // boolean
                delete orderData.changeFor;          // número (legado)
                delete orderData.changeAmount;       // número/texto (atual)
                delete orderData.paymentObservations; // string opcional

                // 2) Persistência local (se utilizada)
                try {
                    localStorage.removeItem('paymentMethod');
                    localStorage.removeItem('needsChange');
                    localStorage.removeItem('changeFor'); // legado
                    localStorage.removeItem('changeAmount');
                    localStorage.removeItem('paymentObservations');
                } catch (_) { /* noop */ }

                // 3) UI
                // Radios de forma de pagamento
                document.querySelectorAll('input[name="payment-method"]').forEach(el => {
                    el.checked = false;
                });

                // Select de forma de pagamento (id atual)
                const paymentSelect = document.getElementById('payment-method');
                if (paymentSelect) {
                    // Assumindo que a option padrão tem value "" (Selecionar)
                    paymentSelect.value = '';
                    // Disparar change para atualizar listeners
                    try { paymentSelect.dispatchEvent(new Event('change')); } catch (_) {}
                }

                // Troco (usar IDs reais)
                const changeToggleContainer = document.getElementById('change-toggle-container');
                const changeDiv = document.getElementById('money-change');
                const changeInput = document.getElementById('change-amount');
                const changeToggle = document.getElementById('change-toggle');
                const changeToggleLabel = document.getElementById('change-toggle-label');
                const pixInfo = document.getElementById('pix-info');

                if (changeInput) changeInput.value = '';
                if (changeToggle) changeToggle.checked = false;
                if (changeToggleLabel) {
                    changeToggleLabel.textContent = 'Não';
                    changeToggleLabel.style.color = 'var(--cor-texto-secundario)';
                }
                if (changeDiv) changeDiv.classList.add('hidden');
                if (changeToggleContainer) changeToggleContainer.classList.add('hidden');
                if (pixInfo) pixInfo.classList.add('hidden');

                // 4) Atualizar resumo/totais se necessário
                if (typeof updateCheckoutOrderTotal === 'function') {
                    updateCheckoutOrderTotal();
                }

                debugLog('🔁 Forma de pagamento resetada ao voltar de step');
            } catch (e) {
                errorLog('resetPaymentState error:', e);
            }
        }

        // Next step with enhanced validation
        function nextStep(step) {
            if (step === 3) {
                if (!validateStep2Enhanced()) {
                    return;
                }
                // Sincronizar taxa de delivery com o bairro atual antes de abrir o resumo
                if (typeof syncDeliveryFeeBeforeStep3 === 'function') {
                    try { syncDeliveryFeeBeforeStep3(); } catch (e) { errorLog('Erro ao sincronizar taxa antes do Step 3:', e); }
                }
                showStep(step);
            } else {
                showStep(step);
            }
        }

        // Sincroniza a taxa de delivery com base no bairro atual antes de exibir o Step 3 (resumo)
        function syncDeliveryFeeBeforeStep3() {
            try {
                if (!orderData) return;
                if (orderData.deliveryType !== 'delivery') return; // só aplica para delivery

                // Obter bairro atual dos campos (prioriza modo manual se visível/preenchido)
                const manualNeighborhoodEl = document.getElementById('manual-neighborhood');
                const cepNeighborhoodEl = document.getElementById('neighborhood');
                const manualValue = manualNeighborhoodEl ? manualNeighborhoodEl.value.trim() : '';
                const cepValue = cepNeighborhoodEl ? cepNeighborhoodEl.value.trim() : '';
                const neighborhood = manualValue || cepValue || (orderData.address ? (orderData.address.neighborhood || '') : '');

                if (!neighborhood) {
                    // Se bairro vazio, limpar taxa
                    if (!orderData.address) orderData.address = {};
                    delete orderData.address.deliveryFee;
                    currentDeliveryFee = null;
                    return;
                }

                // Buscar taxa na planilha
                if (typeof findDeliveryFeeByNeighborhood === 'function') {
                    const feeRaw = findDeliveryFeeByNeighborhood(neighborhood);
                    const fee = typeof feeRaw === 'string' ? parseFloat(feeRaw.replace(/[^0-9.,]/g, '').replace(',', '.')) : feeRaw;
                    if (!isNaN(fee) && fee > 0) {
                        if (!orderData.address) orderData.address = {};
                        orderData.address.neighborhood = neighborhood;
                        orderData.address.deliveryFee = fee;
                        currentDeliveryFee = fee;
                        // Memoriza última consulta
                        window.lastNeighborhoodFee = fee;
                        window.lastNeighborhoodName = neighborhood;
                        debugLog('🔁 syncDeliveryFeeBeforeStep3 aplicou taxa:', neighborhood, fee);
                    } else {
                        if (!orderData.address) orderData.address = {};
                        delete orderData.address.deliveryFee;
                        currentDeliveryFee = null;
                        debugLog('🔁 syncDeliveryFeeBeforeStep3: taxa não encontrada para', neighborhood);
                    }
                }
            } catch (e) {
                errorLog('syncDeliveryFeeBeforeStep3 error:', e);
            }
        }
        
        // Enhanced Step 2 validation - validates all required fields
        function validateStep2Enhanced() {
            const deliveryType = document.querySelector('input[name="delivery-type"]:checked')?.value;
            
            // Clear any existing errors first
            clearAllFieldErrors();
            
            if (!deliveryType) {
                showToast('Por favor, selecione o tipo de recebimento', 'warning');
                return false;
            }
            
            // Update orderData with current selection
            orderData.deliveryType = deliveryType;
            
            let hasErrors = false;
            
            // Validate specific fields based on delivery type
            if (deliveryType === 'local') {
                // Check if mesa/comanda field should be validated based on configuration
                const checkoutConfig = getCheckoutConfig();
                const shouldShowMesaComanda = checkoutConfig.step3_mesa_comanda === 'Sim';
                
                if (shouldShowMesaComanda) {
                    const tableNumber = document.getElementById('table-number')?.value.trim();
                    if (!tableNumber) {
                        showFieldError('table-number', 'Informe o número da mesa ou comanda');
                        hasErrors = true;
                    } else {
                        orderData.tableNumber = tableNumber;
                    }
                } else {
                    // If mesa/comanda is not required, clear any existing table number
                    orderData.tableNumber = '';
                }
            } else if (deliveryType === 'delivery') {
                // Verificar se está no modo CEP ou modo manual
                const cepContainer = document.getElementById('cep-mode-container');
                const manualContainer = document.getElementById('manual-address-container');
                const isManualMode = manualContainer && !manualContainer.classList.contains('hidden');
                
                if (isManualMode) {
                    // Validação modo manual
                    const street = document.getElementById('manual-street')?.value.trim();
                    const number = document.getElementById('manual-number')?.value.trim();
                    const neighborhood = document.getElementById('manual-neighborhood')?.value.trim();
                    const city = document.getElementById('manual-city')?.value.trim();
                    
                    // Validar campos obrigatórios do modo manual
                    if (!street) {
                        showFieldError('manual-street', 'Endereço é obrigatório');
                        hasErrors = true;
                    }
                    if (!number) {
                        showFieldError('manual-number', 'Número é obrigatório');
                        hasErrors = true;
                    }
                    if (!neighborhood) {
                        showFieldError('manual-neighborhood', 'Bairro é obrigatório');
                        hasErrors = true;
                    }
                    if (!city) {
                        showFieldError('manual-city', 'Cidade é obrigatória');
                        hasErrors = true;
                    }
                    
                    // Se não há erros, garantir que orderData está atualizado
                    if (!hasErrors) {
                        updateManualAddressData();
                    }
                    
                } else {
                    // Validação modo CEP (original)
                    const cep = document.getElementById('cep')?.value.replace(/\D/g, '');
                    const number = document.getElementById('number')?.value?.trim();
                    const checkoutConfig = getCheckoutConfig();
                    const showCepField = checkoutConfig.step2_show_cep !== 'Não';
                    
                    // Validate CEP
                    if (showCepField) {
                        if (!cep || cep.length !== 8) {
                            showFieldError('cep', cep ? 'CEP deve ter 8 dígitos' : 'CEP é obrigatório');
                            const cepField = document.getElementById('cep');
                            if (cepField) cepField.focus();
                            hasErrors = true;
                        }
                    }
                    
                    // Validate if address was loaded
                    if (cep && cep.length === 8 && !orderData.address) {
                        showFieldError('cep', 'Por favor, aguarde o carregamento do endereço ou verifique o CEP');
                        hasErrors = true;
                    }
                    
                    // Validate street field
                    const street = document.getElementById('street')?.value.trim();
                    if (!street) {
                        showFieldError('street', 'Rua é obrigatória');
                        hasErrors = true;
                    }
                    
                    // Validate neighborhood field
                    const neighborhood = document.getElementById('neighborhood')?.value.trim();
                    if (!neighborhood) {
                        showFieldError('neighborhood', 'Bairro é obrigatório');
                        hasErrors = true;
                    }
                    
                    // Validate city field
                    const city = document.getElementById('city')?.value.trim();
                    if (!city) {
                        showFieldError('city', 'Cidade é obrigatória');
                        hasErrors = true;
                    }
                    
                    // Validate number field
                    if (!number) {
                        showFieldError('number', 'Número do endereço é obrigatório');
                        hasErrors = true;
                    }
                    
                    // If no errors, update orderData
                    if (!hasErrors && orderData.address) {
                        // Atualiza todos os campos do endereço
                        orderData.address.street = street;
                        orderData.address.neighborhood = neighborhood;
                        orderData.address.city = city.split(' - ')[0]; // Remove o UF se estiver presente
                        orderData.address.number = number;
                        
                        // Campo complemento é opcional
                        if (document.getElementById('complement')?.value) {
                            orderData.address.complement = document.getElementById('complement').value;
                        }
                        
                        debugLog('Dados de endereço atualizados após validação:', orderData.address);
                    }
                }
            }
            
            // 🔒 VALIDAÇÃO ADICIONAL: Modo de restrição por bairro
            if (deliveryType === 'delivery' && !hasErrors) {
                const config = getCheckoutConfig();
                
                if (config.only_bairro_mode === 'Sim') {
                    // Verificar se está no modo CEP ou modo manual
                    const cepContainer = document.getElementById('cep-mode-container');
                    const manualContainer = document.getElementById('manual-address-container');
                    const isManualMode = manualContainer && !manualContainer.classList.contains('hidden');
                    
                    let neighborhoodToValidate = '';
                    
                    if (isManualMode) {
                        // Modo manual - pegar bairro do campo manual
                        neighborhoodToValidate = document.getElementById('manual-neighborhood')?.value.trim() || '';
                    } else {
                        // Modo CEP - pegar bairro do campo CEP
                        neighborhoodToValidate = document.getElementById('neighborhood')?.value.trim() || '';
                    }
                    
                    // Validar se o bairro está na lista de atendimento
                    if (neighborhoodToValidate && !validateNeighborhoodForDelivery(neighborhoodToValidate)) {
                        debugLog('❌ Validação falhou: Bairro não atendido no modo de restrição:', neighborhoodToValidate);
                        showToast('Desculpe, não atendemos este bairro.', 'error');
                        return false;
                    }
                    
                    debugLog('✅ Validação passou: Bairro válido para entrega:', neighborhoodToValidate);
                }
            }
            
            // Show error toast if there are validation errors
            if (hasErrors) {
                showToast('Por favor, preencha todos os campos obrigatórios', 'error');
                return false;
            }
            
            return true;
        }
        
        // Clear all field errors
        function clearAllFieldErrors() {
            const errorFields = [
                'table-number', 'cep', 'number',
                'manual-street', 'manual-number', 'manual-neighborhood', 'manual-city'
            ];
            errorFields.forEach(fieldId => {
                clearFieldError(fieldId);
            });
        }

        // Previous step
        function prevStep(step) {
            showStep(step);
        }



        // Update cart quantity
        function updateCartQuantity(itemKey, delta) {
            const item = cart.find(item => item.itemKey === itemKey);
            if (!item) return;
            
            item.quantity += delta;
            
            if (item.quantity <= 0) {
                cart = cart.filter(item => item.itemKey !== itemKey);
            }
            
            // Salvar carrinho no localStorage
            if (typeof saveCartToStorage === 'function') {
                saveCartToStorage();
            }
            
            updateCartUI();
            
            // Refresh current view
            if (document.getElementById('cart-modal').classList.contains('hidden') === false) {
                openCart(); // Refresh cart display
            }
        }

        // Open image lightbox
        function openImageLightbox(imageSrc, itemName) {
            const lightbox = document.getElementById('image-lightbox');
            const lightboxImage = document.getElementById('lightbox-image');
            const lightboxTitle = document.getElementById('lightbox-title');
            
            lightboxImage.src = imageSrc;
            lightboxImage.alt = itemName;
            lightboxTitle.textContent = itemName;
            
            lightbox.classList.remove('hidden');
            document.body.style.overflow = 'hidden'; // Prevent background scrolling
        }
        
        // Close image lightbox
        function closeLightbox(event) {
            if (event && event.target !== event.currentTarget && !event.target.closest('button')) return;
            
            const lightbox = document.getElementById('image-lightbox');
            lightbox.classList.add('hidden');
            document.body.style.overflow = ''; // Restore scrolling
        }

        // Edit item notes
        let currentEditingItemKey = null;
        
        function editItemNotes(itemKey) {
            const item = cart.find(item => item.itemKey === itemKey);
            if (!item) return;
            
            currentEditingItemKey = itemKey;
            
            // Populate item info
            const itemInfoDiv = document.getElementById('edit-item-info');
            itemInfoDiv.innerHTML = `
                <div class="flex items-center space-x-3">
                    <div class="relative">
                        <img src="${processImageUrl(item.imagem)}" alt="${item.nome}" class="w-12 h-10 object-cover rounded" onerror="this.src='${getPlaceholderImage()}'">
                    </div>
                    <div class="flex-1">
                        <div class="text-xs text-gray-400 font-mono" style="font-size: 10px; margin-bottom: 2px;">${item.sku}</div>
                        <h4 class="font-medium text-sm">${item.nome}</h4>
                        ${item.variationText ? `<p class="text-xs text-gray-600">✓ ${item.variationText}</p>` : ''}
                        ${item.removalText ? `<p class="text-xs text-red-600">🚫 Remover Ingredientes: ${item.removalText}</p>` : ''}
                        <p class="text-xs text-gray-500">Quantidade: ${item.quantity}x</p>
                    </div>
                </div>
            `;
            
            // Set current notes
            document.getElementById('edit-item-notes').value = item.notes || '';
            
            // Hide cart FAB and show modal
            document.getElementById('cart-fab').style.display = 'none';
            document.getElementById('edit-notes-modal').classList.remove('hidden');
            
            // Focus on textarea
            setTimeout(() => {
                document.getElementById('edit-item-notes').focus();
            }, 300);
        }
        
        function saveItemNotes() {
            if (!currentEditingItemKey) return;
            
            const item = cart.find(item => item.itemKey === currentEditingItemKey);
            if (!item) return;
            
            const newNotes = document.getElementById('edit-item-notes').value.trim();
            
            // If notes changed, we need to update the item
            if (item.notes !== newNotes) {
                // Remove old item
                cart = cart.filter(item => item.itemKey !== currentEditingItemKey);
                
                // Create new item key if notes changed (for proper grouping)
                const baseKey = currentEditingItemKey.replace(/-notes-[^-]*$/, '');
                const notesKey = newNotes ? `-notes-${btoa(newNotes).replace(/[^a-zA-Z0-9]/g, '')}` : '';
                const newItemKey = `${baseKey}${notesKey}`;
                
                // Check if item with same key already exists
                const existingItem = cart.find(existingItem => existingItem.itemKey === newItemKey);
                
                if (existingItem) {
                    // Merge quantities
                    existingItem.quantity += item.quantity;
                } else {
                    // Add updated item
                    item.itemKey = newItemKey;
                    item.notes = newNotes;
                    cart.push(item);
                }
            }
            
            updateCartUI();
            
            // Salvar carrinho atualizado no localStorage
            if (typeof saveCartToStorage === 'function') {
                saveCartToStorage();
                debugLog('💾 Observações do item salvas no localStorage');
            }
            
            closeEditNotes();
            
            // Refresh cart display if it's open
            if (!document.getElementById('cart-modal').classList.contains('hidden')) {
                openCart();
            }
            
            showToast('Observações atualizadas com sucesso!', 'success', 2000);
        }
        
        function closeEditNotes(event) {
            if (event && event.target !== event.currentTarget) return;
            
            document.getElementById('edit-notes-modal').classList.add('hidden');
            currentEditingItemKey = null;
            
            // Show cart FAB again if cart has items
            const cartCount = cart.reduce((sum, item) => sum + item.quantity, 0);
            if (cartCount > 0) {
                document.getElementById('cart-fab').style.display = 'flex';
            }
        }

        // Handle delivery type change
        function handleDeliveryTypeChange() {
            const selectedType = document.querySelector('input[name="delivery-type"]:checked')?.value;
            const fieldsContainer = document.getElementById('delivery-fields');
            const continueBtn = document.getElementById('step2-continue');
            
            // Get delivery fee message from configuration
            const checkoutConfigDelivery = getCheckoutConfig();
            const showCepField = checkoutConfigDelivery.step2_show_cep !== 'Não';
            const cepContainerDisplay = showCepField ? '' : 'display: none;';
            const manualContainerDisplay = showCepField ? 'hidden' : ''; // Se CEP desabilitado, mostra container manual
            const addressFieldsDisplay = 'hidden'; // Este container deve estar sempre oculto inicialmente
            const cepButtonDisplay = showCepField ? '' : 'display: none;';

            // Limpar taxa de delivery ao trocar tipo de entrega
            clearDeliveryFee();
            
            // Atualizar estilo dos botões de opção
            document.querySelectorAll('.delivery-option-label').forEach(label => {
                const input = label.querySelector('input');
                label.classList.toggle('selected', input.checked);
            });

            // ====================================================================
            // 🎟️ CORREÇÃO V4.1.2: INVALIDAR CUPOM AO MUDAR TIPO DE ENTREGA
            // ====================================================================
            // Problema: Cupom permanecia aplicado ao mudar tipo de entrega,
            // causando inconsistências dependendo do tipo de cupom (produtos/frete/total)
            // Solução: Limpar cupom silenciosamente sem notificação desnecessária
            if (appliedCoupon && orderData.deliveryType !== selectedType) {
                debugLog('🎟️ Limpando cupom devido à mudança de tipo de entrega');
                debugLog('- Tipo anterior:', orderData.deliveryType, '→ Novo tipo:', selectedType);
                
                // Limpar cupom aplicado silenciosamente
                clearCoupon();
                
                // Atualizar resumo do pedido para refletir a remoção
                updateOrderSummary();
            }
            
            orderData.deliveryType = selectedType;
            
            if (!selectedType) {
                continueBtn.disabled = false; // Manter habilitado para mostrar erro de validação
                fieldsContainer.innerHTML = '';
                showAllDeliveryOptions();
                hideOtherOptionsButton();
                // Reset payment methods when no delivery type is selected
                setupPaymentMethods();
                return;
            }
            
            // Update payment methods visibility based on delivery type
            setupPaymentMethods();
            
            // Hide other options and show the "Mostrar outras opções" button
            hideOtherDeliveryOptions(selectedType);
            showOtherOptionsButton();
            
            // Verificar visibilidade do botão "Utilizar meu endereço" baseado no tipo de entrega
            checkUserLoginForAddressButton();

            // Mostrar o container de campos dinâmicos
            if (fieldsContainer) {
                fieldsContainer.style.display = 'block';
            }
            
            continueBtn.disabled = false;
            
            switch(selectedType) {
                case 'local':
                    // Check if mesa/comanda field should be shown based on configuration
                    const checkoutConfig = getCheckoutConfig();
                    const shouldShowMesaComanda = checkoutConfig.step3_mesa_comanda === 'Sim';
                    
                    if (shouldShowMesaComanda) {
                        fieldsContainer.innerHTML = `
                            <div>
                                <label class="block text-sm font-medium text-gray-700 mb-2">Número da Mesa/Comanda *</label>
                                <input type="tel" id="table-number" class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-red-500 focus:border-transparent" placeholder="Ex: Mesa 5 ou Comanda 123" autocomplete="off" oninput="clearFieldError('table-number')" onchange="updateContinueButton()" onblur="updateContinueButton()" inputmode="numeric">
                            </div>
                        `;
                        continueBtn.disabled = true;
                        
                        // Foco automático no campo de mesa após renderização
                        setTimeout(() => {
                            const tableNumberField = document.getElementById('table-number');
                            if (tableNumberField) {
                                // Primeiro tenta preencher automaticamente da URL
                                const preenchido = preencheMesaAutomatica();
                                // Se não preencheu automaticamente, foca no campo
                                if (!preenchido) {
                                    tableNumberField.focus();
                                }
                            }
                        }, 100);
                    } else {
                        // If mesa/comanda is not required, just clear the fields and enable continue
                        fieldsContainer.innerHTML = '';
                        continueBtn.disabled = false;
                    }
                    break;
                    
                case 'delivery':
                    // Get delivery fee message from configuration
                    const deliveryFeeMessage = checkoutConfigDelivery.step2_taxa_delivery || 'Consulte a taxa de entrega com nosso atendente';
                    
                    fieldsContainer.innerHTML = `
                        <div class="space-y-4">
                            <!-- Delivery Fee Alert - Oculto inicialmente, aparece apenas se bairro não for encontrado -->
                            <div id="original-delivery-fee-alert" class="bg-amber-50 border border-amber-200 rounded-lg p-4 mb-4" style="display: none;">
                                <div class="flex items-start space-x-3">
                                    <div class="flex-shrink-0">
                                        <svg class="w-5 h-5 text-amber-600 mt-0.5" fill="currentColor" viewBox="0 0 20 20">
                                            <path fill-rule="evenodd" d="M8.257 3.099c.765-1.36 2.722-1.36 3.486 0l5.58 9.92c.75 1.334-.213 2.98-1.742 2.98H4.42c-1.53 0-2.493-1.646-1.743-2.98l5.58-9.92zM11 13a1 1 0 11-2 0 1 1 0 012 0zm-1-8a1 1 0 00-1 1v3a1 1 0 002 0V6a1 1 0 00-1-1z" clip-rule="evenodd"></path>
                                        </svg>
                                    </div>
                                    <div class="flex-1">
                                        <h4 class="text-sm font-medium text-amber-800 mb-1">Consulte a Taxa de Entrega</h4>
                                        <p class="text-sm text-amber-700">${deliveryFeeMessage}</p>
                                    </div>
                                </div>
                            </div>
                            
                            <!-- Modo CEP (Padrão) -->
                            <div id="cep-mode-container" style="${cepContainerDisplay}">
                                <div class="flex items-center justify-between mb-2">
                                    <label class="block text-sm font-medium text-gray-700">CEP *</label>
                                    <button type="button" onclick="toggleAddressMode()" class="text-sm text-blue-600 hover:text-blue-800 underline transition-colors duration-200" style="${cepButtonDisplay}">
                                        Corrigir endereço / Não sei o CEP
                                    </button>
                                </div>
                                <input type="tel" id="cep" class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-red-500 focus:border-transparent" placeholder="00000-000" autocomplete="off" oninput="clearFieldError('cep'); handleCepInput();" onchange="fetchAddress(); updateContinueButton();" onblur="updateContinueButton();" maxlength="9" inputmode="numeric">
                            </div>

                            <!-- Modo Endereço Manual (Oculto inicialmente) -->
                            <div id="manual-address-container" class="${manualContainerDisplay} space-y-4">
                                <div class="flex items-center justify-end mb-2">
                                    <label class="block text-sm font-medium text-gray-700 hidden">Endereço Manual</label>
                                    <button type="button" onclick="toggleAddressMode()" class="text-sm text-blue-600 hover:text-blue-800 underline transition-colors duration-200 hidden">
                                        Usar meu CEP 
                                    </button>
                                </div>
                                <div>
                                    <label class="block text-sm font-medium text-gray-700 mb-2">Endereço Completo *</label>
                                    <input type="text" id="manual-street" class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-red-500 focus:border-transparent" placeholder="Rua das Flores, 123" autocomplete="off" oninput="updateManualAddressData(); clearFieldError('manual-street');" onchange="updateContinueButton();" onblur="updateContinueButton();">
                                </div>
                                <div class="grid grid-cols-2 gap-3">
                                    <div>
                                        <label class="block text-sm font-medium text-gray-700 mb-2">Número *</label>
                                        <input type="number" id="manual-number" min="1" step="1" class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-red-500 focus:border-transparent" placeholder="123" autocomplete="off" oninput="updateManualAddressData(); clearFieldError('manual-number');" onchange="updateContinueButton();" onblur="updateContinueButton();">
                                    </div>
                                    <div>
                                        <label class="block text-sm font-medium text-gray-700 mb-2">Complemento</label>
                                        <input type="text" id="manual-complement" class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-red-500 focus:border-transparent" placeholder="Apto 45" autocomplete="off" oninput="updateManualAddressData();">
                                    </div>
                                </div>
                                <div class="grid grid-cols-2 gap-3">
                                    <div>
                                        <label class="block text-sm font-medium text-gray-700 mb-2">Bairro *</label>
                                        <div id="manual-neighborhood-field-container">
                                            <!-- Campo será renderizado dinamicamente baseado em only_bairro_mode -->
                                        </div>
                                    </div>
                                    <div>
                                        <label class="block text-sm font-medium text-gray-700 mb-2">Cidade *</label>
                                        <input type="text" id="manual-city" class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-red-500 focus:border-transparent" placeholder="São Paulo" autocomplete="off" oninput="updateManualAddressData(); clearFieldError('manual-city');" onchange="updateContinueButton();" onblur="updateContinueButton();">
                                    </div>
                                </div>
                            </div>
                            <div id="address-fields" class="${addressFieldsDisplay} space-y-4">
                                <div>
                                    <label class="block text-sm font-medium text-gray-700 mb-2">Endereço *</label>
                                    <input type="text" id="street" class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-red-500 focus:border-transparent" placeholder="Rua, Avenida..." autocomplete="off" oninput="updateAddressData(); clearFieldError('street');">
                                </div>
                                <div class="grid grid-cols-2 gap-3">
                                    <div>
                                        <label class="block text-sm font-medium text-gray-700 mb-2">Número *</label>
                                        <input type="number" id="number" min="1" step="1" class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-red-500 focus:border-transparent" placeholder="123" autocomplete="off" oninput="clearFieldError('number')" onchange="updateContinueButton()" onblur="updateContinueButton()">
                                    </div>
                                    <div>
                                        <label class="block text-sm font-medium text-gray-700 mb-2">Complemento</label>
                                        <input type="text" id="complement" class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-red-500 focus:border-transparent" placeholder="Apto 45" autocomplete="off">
                                    </div>
                                </div>
                                <div class="grid grid-cols-2 gap-3">
                                    <div>
                                        <label class="block text-sm font-medium text-gray-700 mb-2">Bairro *</label>
                                        <div id="neighborhood-field-container">
                                            <!-- Campo será renderizado dinamicamente baseado em only_bairro_mode -->
                                        </div>
                                    </div>
                                    <div>
                                        <label class="block text-sm font-medium text-gray-700 mb-2">Cidade *</label>
                                        <input type="text" id="city" class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-red-500 focus:border-transparent" placeholder="Cidade - UF" autocomplete="off" oninput="updateAddressData(); clearFieldError('city');">
                                    </div>
                                </div>
                            </div>
                        </div>
                    `;
                    continueBtn.disabled = true;

                    // ====================================================================
                    // 🏘️ RENDERIZAR V4.1.4: CAMPOS DE BAIRRO DINÂMICOS
                    // ====================================================================
                    // Renderizar campos de bairro baseado em only_bairro_mode
                    setTimeout(() => {
                        renderNeighborhoodFields();
                        // Se o CEP está desabilitado, focar no primeiro campo manual
                        if (!showCepField) {
                            const manualStreetField = document.getElementById('manual-street');
                            if (manualStreetField) {
                                manualStreetField.focus();
                            }
                        }
                    }, 100);
                    

                    // Focar no CEP
                    setTimeout(() => {
                        const cepField = document.getElementById('cep');
                        if (cepField) {
                            cepField.focus();
                        }
                    }, 200);
                    break;
                    
                case 'pickup':
                case 'default':
                    fieldsContainer.innerHTML = '';
                    continueBtn.disabled = false;
                    break;
            }
        }

        // Handle CEP input - fetch address when 8 digits are entered
        function handleCepInput() {
            const cep = document.getElementById('cep').value.replace(/\D/g, '');
            
            // Limpar campos de endereço e taxa quando usuário editar CEP
            if (cep.length < 8) {
                // Limpar campos de endereço
                const streetField = document.getElementById('street');
                const neighborhoodField = document.getElementById('neighborhood');
                const cityField = document.getElementById('city');
                
                if (streetField) streetField.value = '';
                if (neighborhoodField) neighborhoodField.value = '';
                if (cityField) cityField.value = '';
                
                // Limpar taxa de delivery
                clearDeliveryFee();
                
                // Limpar dados do pedido
                if (window.orderData && window.orderData.address) {
                    delete window.orderData.address;
                }
            }
            
            if (cep.length === 8) {
                fetchAddress();
            }
        }

        // Fetch address from CEP with multiple API fallbacks
        async function fetchAddress() {
            const cep = document.getElementById('cep').value.replace(/\D/g, '');
            
            if (cep.length !== 8) return;
            
            // Show loading indicator
            const cepField = document.getElementById('cep');
            const originalPlaceholder = cepField.placeholder;
            cepField.placeholder = 'Digite o CEP...';
            cepField.disabled = true;
            
            // List of CEP APIs to try
            const cepApis = [
                {
                    name: 'ViaCEP',
                    url: `https://viacep.com.br/ws/${cep}/json/`,
                    parseResponse: (data) => ({
                        logradouro: data.logradouro,
                        bairro: data.bairro,
                        localidade: data.localidade,
                        uf: data.uf,
                        erro: data.erro
                    })
                },
                {
                    name: 'CEP Aberto',
                    url: `https://www.cepaberto.com/api/v3/cep?cep=${cep}`,
                    parseResponse: (data) => ({
                        logradouro: data.address,
                        bairro: data.district,
                        localidade: data.city?.name,
                        uf: data.state?.short_name,
                        erro: !data.address && !data.district && !data.city
                    }),
                    headers: {
                        'Authorization': 'Token token=free'
                    }
                },
                {
                    name: 'PostMon',
                    url: `https://api.postmon.com.br/v1/cep/${cep}`,
                    parseResponse: (data) => ({
                        logradouro: data.logradouro,
                        bairro: data.bairro,
                        localidade: data.cidade,
                        uf: data.estado,
                        erro: data.erro
                    })
                }
            ];
            
            let lastError = null;
            
            for (let i = 0; i < cepApis.length; i++) {
                const api = cepApis[i];
                
                try {
                    debugLog(`Tentando API ${api.name}:`, api.url);
                    
                    // Add timeout to the fetch request
                    const controller = new AbortController();
                    const timeoutId = setTimeout(() => controller.abort(), 8000); // 8 second timeout
                    
                    const response = await fetch(api.url, {
                        signal: controller.signal,
                        headers: {
                            'Accept': 'application/json',
                            'Content-Type': 'application/json',
                            ...api.headers
                        }
                    });
                    
                    clearTimeout(timeoutId);
                    
                    debugLog(`${api.name} Response status:`, response.status);
                    
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    
                    const rawData = await response.json();
                    const data = api.parseResponse(rawData);
                    debugLog(`${api.name} data received:`, data);
                    
                    if (data.erro) {
                        debugLog(`${api.name}: CEP não encontrado`);
                        continue; // Try next API
                    }
                    
                    // Validate required fields
                    if (!data.logradouro && !data.bairro && !data.localidade) {
                        debugLog(`${api.name}: Dados incompletos`);
                        continue; // Try next API
                    }
                    
                    // Success! Fill the form
                    const streetValue = data.logradouro || '';
                    document.getElementById('street').value = streetValue;
                    
                    // ====================================================================
                    // 🏘️ CONTROLE V4.1.4: PREENCHIMENTO DE BAIRRO BASEADO EM MODO
                    // ====================================================================
                    const config = getCheckoutConfig();
                    const neighborhoodField = document.getElementById('neighborhood');
                    
                    // Se a rua vier vazia, não preencher o bairro pois pode estar incorreto
                    if (!streetValue) {
                        if (neighborhoodField) {
                            if (config.only_bairro_mode === 'Sim') {
                                // Modo restrito - manter select com placeholder
                                if (neighborhoodField.tagName === 'SELECT') {
                                    neighborhoodField.selectedIndex = 0; // "Selecione o bairro"
                                }
                                debugLog('🏘️ Modo restrito: mantendo placeholder do select após CEP inválido');
                            } else {
                                // Modo normal - limpar input
                                neighborhoodField.value = '';
                            }
                        }
                        debugLog('Rua vazia no retorno do CEP, campo de bairro foi limpo para evitar dados incorretos');
                    } else {
                        if (neighborhoodField) {
                            if (config.only_bairro_mode === 'Sim') {
                                // Modo restrito - NÃO preencher automaticamente, manter select
                                if (neighborhoodField.tagName === 'SELECT') {
                                    neighborhoodField.selectedIndex = 0; // "Selecione o bairro"
                                }
                                debugLog('🏘️ Modo restrito: ignorando bairro do ViaCEP, usuário deve selecionar manualmente');
                            } else {
                                // Modo normal - preencher normalmente
                                neighborhoodField.value = data.bairro || '';
                                debugLog('🏘️ Modo normal: preenchendo bairro do ViaCEP');
                            }
                        }
                    }
                    
                    document.getElementById('city').value = `${data.localidade || ''} - ${data.uf || ''}`;
                    document.getElementById('address-fields').classList.remove('hidden');
                    
                    // ====================================================================
                    // 🏘️ CONTROLE V4.1.4: ORDERDATA BASEADO EM MODO
                    // ====================================================================
                    // Se a rua vier vazia, não incluir o bairro no objeto orderData.address
                    let neighborhoodForOrderData = '';
                    if (streetValue) {
                        if (config.only_bairro_mode === 'Sim') {
                            // Modo restrito - não incluir bairro do ViaCEP no orderData
                            neighborhoodForOrderData = '';
                            debugLog('🏘️ Modo restrito: bairro não incluído no orderData, aguardando seleção manual');
                        } else {
                            // Modo normal - incluir bairro do ViaCEP
                            neighborhoodForOrderData = data.bairro || '';
                        }
                    }
                    
                    orderData.address = {
                        cep: cep,
                        street: streetValue,
                        neighborhood: neighborhoodForOrderData,
                        city: data.localidade || '',
                        state: data.uf || ''
                    };
                    
                    if (!streetValue) {
                        debugLog('Rua vazia no retorno do CEP, bairro foi limpo no objeto orderData.address');
                    }
                    
                    // Processar taxa de delivery baseada no bairro
                    processDeliveryFeeAfterCEP(orderData.address);
                    
                    // Garantir que o campo CEP permaneça editável
                    const cepField = document.getElementById('cep');
                    if (cepField) {
                        cepField.disabled = false;
                        cepField.readOnly = false;
                        cepField.placeholder = originalPlaceholder;
                    }
                    
                    debugLog(`Endereço encontrado via ${api.name}:`, orderData.address);
                    updateContinueButton();
                    return; // Success, exit function
                    
                } catch (error) {
                    errorLog(`Erro na API ${api.name}:`, error);
                    lastError = error;
                    
                    // If this is the last API, show error
                    if (i === cepApis.length - 1) {
                        break;
                    }
                    
                    // Otherwise, continue to next API
                    continue;
                }
            }
            
            // If we get here, all APIs failed
            errorLog('Todas as APIs de CEP falharam');
            
            // Show manual input option
            showCustomAlert('Serviço de CEP temporariamente indisponível. Você pode preencher o endereço manualmente.', () => {
                // Show address fields for manual input
                document.getElementById('street').value = '';
                document.getElementById('neighborhood').value = '';
                document.getElementById('city').value = '';
                document.getElementById('address-fields').classList.remove('hidden');
                
                // Focus on street field
                setTimeout(() => {
                    document.getElementById('street').focus();
                }, 100);
                
                // Initialize empty address data
                orderData.address = {
                    cep: cep,
                    street: '',
                    neighborhood: '',
                    city: '',
                    state: ''
                };
                
                updateContinueButton();
            });
            
            // Restore field state
            cepField.placeholder = originalPlaceholder;
            cepField.disabled = false;
        }

        // Update continue button state (no validation, just enable/disable)
        function updateContinueButton() {
            // Button is always enabled - validation happens on click
            const continueBtn = document.getElementById('step2-continue');
            if (continueBtn) {
                continueBtn.disabled = false;
            }
        }

        // Show all delivery options (only enabled ones from configuration)
        function showAllDeliveryOptions() {
            const deliveryOptions = document.getElementById('delivery-options');
            const checkoutConfig = getCheckoutConfig();
            
            // Helper function to check if option is enabled
            function isOptionEnabled(csvValue) {
                if (!csvValue || !csvValue.includes('/')) {
                    return false;
                }
                const parts = csvValue.split('/');
                const visibility = parts[0] ? parts[0].trim().toLowerCase() : '';
                return visibility === 'sim';
            }
            
            // Map of input values to their config keys
            const optionConfigMap = {
                'local': checkoutConfig.step2_opc1,
                'pickup': checkoutConfig.step2_opc2,
                'delivery': checkoutConfig.step2_opc3,
                'default': checkoutConfig.step2_opc4
            };
            
            deliveryOptions.querySelectorAll('label').forEach(label => {
                const input = label.querySelector('input[type="radio"]');
                if (input) {
                    const optionValue = input.value;
                    const configValue = optionConfigMap[optionValue];
                    
                    // Only show if option is enabled in configuration
                    if (isOptionEnabled(configValue)) {
                        label.style.display = 'flex';
                    } else {
                        label.style.display = 'none';
                    }
                }
            });
        }

        // Hide other delivery options (keep only selected)
        function hideOtherDeliveryOptions(selectedType) {
            const deliveryOptions = document.getElementById('delivery-options');
            deliveryOptions.querySelectorAll('label').forEach(label => {
                const input = label.querySelector('input[type="radio"]');
                if (input.value !== selectedType) {
                    label.style.display = 'none';
                }
            });
        }

        // Show "Outras opções" button
        function showOtherOptionsButton() {
            const deliveryOptions = document.getElementById('delivery-options');
            let showOtherOptionsBtn = document.getElementById('show-other-options');
            let useMyAddressBtn = document.getElementById('use-my-address-btn');
            
            // Criar container para os botões se não existir
            let buttonsContainer = document.getElementById('delivery-buttons-container');
            if (!buttonsContainer) {
                buttonsContainer = document.createElement('div');
                buttonsContainer.id = 'delivery-buttons-container';
                buttonsContainer.className = 'flex flex-wrap gap-2 mt-3 mb-1';
                deliveryOptions.appendChild(buttonsContainer);
            }
            
            // Criar botão "Mostrar outras opções"
            if (!showOtherOptionsBtn) {
                showOtherOptionsBtn = document.createElement('button');
                showOtherOptionsBtn.id = 'show-other-options';
                showOtherOptionsBtn.type = 'button';
                showOtherOptionsBtn.className = 'text-sm font-medium py-2 px-4 rounded-md transition-all duration-200 flex items-center justify-center';
                showOtherOptionsBtn.style.backgroundColor = 'var(--cor-terciaria, #6B7280)';
                showOtherOptionsBtn.style.color = 'white';
                showOtherOptionsBtn.style.boxShadow = '0 2px 4px rgba(0,0,0,0.1)';
                showOtherOptionsBtn.style.flex = '1';
                showOtherOptionsBtn.style.minWidth = 'fit-content';
                showOtherOptionsBtn.onmouseenter = function() { 
                    const corTerciaria = getComputedStyle(document.documentElement).getPropertyValue('--cor-terciaria').trim() || '#6B7280';
                    const corEscurecida = escurecerCor30Porcento(corTerciaria);
                    this.style.backgroundColor = corEscurecida;
                    this.style.transform = 'translateY(-1px)';
                    this.style.boxShadow = '0 4px 8px rgba(0,0,0,0.15)';
                };
                showOtherOptionsBtn.onmouseleave = function() { 
                    this.style.backgroundColor = 'var(--cor-terciaria, #6B7280)'; 
                    this.style.transform = 'translateY(0)';
                    this.style.boxShadow = '0 2px 4px rgba(0,0,0,0.1)';
                };
                showOtherOptionsBtn.innerHTML = '↩️ Mostrar outras opções';
                showOtherOptionsBtn.onclick = toggleDeliveryOptions;
                buttonsContainer.appendChild(showOtherOptionsBtn);
            }
            
            // Criar botão "Utilizar meu endereço"
            if (!useMyAddressBtn) {
                useMyAddressBtn = document.createElement('button');
                useMyAddressBtn.id = 'use-my-address-btn';
                useMyAddressBtn.type = 'button';
                useMyAddressBtn.className = 'text-sm font-medium py-2 px-4 rounded-md transition-all duration-200 flex items-center justify-center gap-2';
                useMyAddressBtn.style.backgroundColor = 'var(--cor-primaria)';
                useMyAddressBtn.style.color = 'white';
                useMyAddressBtn.style.boxShadow = '0 2px 4px rgba(0,0,0,0.1)';
                useMyAddressBtn.style.flex = '1';
                useMyAddressBtn.style.minWidth = 'fit-content';
                useMyAddressBtn.onmouseenter = function() { 
                    this.style.opacity = '0.9';
                    this.style.transform = 'translateY(-1px)';
                    this.style.boxShadow = '0 4px 8px rgba(0,0,0,0.15)';
                };
                useMyAddressBtn.onmouseleave = function() { 
                    this.style.opacity = '1';
                    this.style.transform = 'translateY(0)';
                    this.style.boxShadow = '0 2px 4px rgba(0,0,0,0.1)';
                };
                useMyAddressBtn.innerHTML = `
                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17.657 16.657L13.414 20.9a1.998 1.998 0 01-2.827 0l-4.244-4.243a8 8 0 1111.314 0z"></path>
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 11a3 3 0 11-6 0 3 3 0 016 0z"></path>
                    </svg>
                    <span>Utilizar meu endereço</span>
                `;
                useMyAddressBtn.onclick = useMyAddress;
                buttonsContainer.appendChild(useMyAddressBtn);
            }
            
            showOtherOptionsBtn.style.display = 'flex';
            
            // Mostrar/ocultar botão baseado no login
            checkUserLoginForAddressButton();
        }

        // Hide "Outras opções" button
        function hideOtherOptionsButton() {
            const showOtherOptionsBtn = document.getElementById('show-other-options');
            const useMyAddressBtn = document.getElementById('use-my-address-btn');
            if (showOtherOptionsBtn) {
                showOtherOptionsBtn.style.display = 'none';
            }
            if (useMyAddressBtn) {
                useMyAddressBtn.style.display = 'none';
            }
        }
        
        // Verificar se usuário está logado para mostrar/ocultar botão de endereço
        async function checkUserLoginForAddressButton() {
            const useMyAddressBtn = document.getElementById('use-my-address-btn');
            if (!useMyAddressBtn) return;
            
            // Verificar o tipo de entrega selecionado
            const selectedType = document.querySelector('input[name="delivery-type"]:checked')?.value;
            
            // Ocultar botão se NÃO for "delivery" (apenas mostrar para delivery)
            if (selectedType !== 'delivery') {
                useMyAddressBtn.style.display = 'none';
                return;
            }
            
            const { data: { session } } = await supabase.auth.getSession();
            if (session) {
                useMyAddressBtn.style.display = 'flex';
            } else {
                useMyAddressBtn.style.display = 'none';
            }
        }
        
        // Função para usar endereço salvo - ABRE O MODAL
        async function useMyAddress() {
            // Verificar se usuário está logado
            const { data: { session } } = await supabase.auth.getSession();
            if (!session) {
                alert('Você precisa estar logado para usar seu endereço salvo.');
                return;
            }
            
            // Abrir modal
            openMyAddressModal();
        }
        
        // ====================================================================
        // MODAL "MEU ENDEREÇO" - PARA CHECKOUT
        // ====================================================================
        
        let savedAddressData = null;
        
        function openMyAddressModal() {
            const modal = document.getElementById('my-address-modal');
            modal.classList.remove('hidden');
            document.body.classList.add('modal-open');
            
            // Resetar estados
            document.getElementById('my-address-loading').classList.remove('hidden');
            document.getElementById('my-address-empty').classList.add('hidden');
            document.getElementById('my-address-content').classList.add('hidden');
            document.getElementById('my-address-actions').classList.add('hidden');
            
            // Carregar endereço
            loadAddressForModal();
        }
        
        function closeMyAddressModal() {
            const modal = document.getElementById('my-address-modal');
            modal.classList.add('hidden');
            document.body.classList.remove('modal-open');
            savedAddressData = null;
        }
        
        function openProfileFromAddress() {
            // Fechar modal de endereço e garantir que scroll seja liberado
            closeMyAddressModal();
            
            // Forçar remoção de qualquer bloqueio de scroll residual
            document.body.classList.remove('modal-open');
            document.body.style.overflow = '';
            document.body.style.position = '';
            document.body.style.width = '';
            
            // Abrir modal de perfil (sem bloquear scroll)
            setTimeout(() => {
                openProfileModal();
            }, 50);
        }
        
        async function loadAddressForModal() {
            try {
                debugLog('🔍 Carregando endereço para o modal...');
                
                const { data: { session } } = await supabase.auth.getSession();
                if (!session) {
                    debugLog('⚠️ Usuário não autenticado');
                    showEmptyAddressState();
                    return;
                }
                
                debugLog('✅ Usuário autenticado:', session.user.email);
                
                // Buscar endereço salvo (agora está na mesma tabela clientes)
                const { data: address, error } = await supabase
                    .from('clientes')
                    .select('*')
                    .eq('user_id', session.user.id)
                    .maybeSingle();
                
                debugLog('📦 Resposta do Supabase:', { address, error });
                
                if (error && error.code !== 'PGRST116') {
                    console.error('❌ Erro ao carregar endereço:', error);
                    showEmptyAddressState();
                    return;
                }
                
                if (!address) {
                    debugLog('⚠️ Nenhum endereço encontrado no banco');
                    showEmptyAddressState();
                    return;
                }
                
                debugLog('✅ Endereço carregado com sucesso:', address);
                
                // Salvar dados e mostrar
                savedAddressData = address;
                displayAddressInModal(address);
                
            } catch (error) {
                console.error('❌ Erro ao carregar endereço:', error);
                showEmptyAddressState();
            }
        }
        
        function showEmptyAddressState() {
            document.getElementById('my-address-loading').classList.add('hidden');
            document.getElementById('my-address-empty').classList.remove('hidden');
            document.getElementById('my-address-content').classList.add('hidden');
            document.getElementById('my-address-actions').classList.add('hidden');
        }
        
        function displayAddressInModal(address) {
            // Ocultar loading
            document.getElementById('my-address-loading').classList.add('hidden');
            
            // Mostrar conteúdo
            document.getElementById('my-address-content').classList.remove('hidden');
            document.getElementById('my-address-actions').classList.remove('hidden');
            
            // Preencher dados
            document.getElementById('modal-address-street').textContent = address.rua || '-';
            document.getElementById('modal-address-number').textContent = address.numero || '-';
            document.getElementById('modal-address-location').textContent = 
                `${address.bairro || '-'} - ${address.cidade || '-'}`;
            
            // Complemento (opcional)
            const complementContainer = document.getElementById('modal-address-complement-container');
            if (address.complemento) {
                document.getElementById('modal-address-complement').textContent = address.complemento;
                complementContainer.classList.remove('hidden');
            } else {
                complementContainer.classList.add('hidden');
            }
        }
        
        async function confirmUseAddress() {
            // Validar dados do endereço
            if (!savedAddressData) {
                console.error('❌ savedAddressData está null ou undefined');
                alert('Erro ao carregar endereço. Tente novamente.');
                return;
            }
            
            // Validar campos obrigatórios (SEM CEP)
            if (!savedAddressData.rua || !savedAddressData.numero || !savedAddressData.bairro || !savedAddressData.cidade) {
                console.error('❌ Dados do endereço incompletos:', savedAddressData);
                alert('Endereço incompleto. Por favor, atualize seu endereço no perfil com Rua, Número, Bairro e Cidade.');
                closeMyAddressModal();
                return;
            }
            
            debugLog('✅ Usando endereço do modal:', savedAddressData);
            
            // Salvar dados do endereço no objeto global orderData.address
            if (typeof orderData !== 'undefined') {
                orderData.address = {
                    street: savedAddressData.rua,
                    number: savedAddressData.numero,
                    complement: savedAddressData.complemento || '',
                    neighborhood: savedAddressData.bairro,
                    city: savedAddressData.cidade || ''
                };
                debugLog('✅ Endereço salvo em orderData.address:', orderData.address);
            }
            
            // ====================================================================
            // CALCULAR E SALVAR TAXA DE ENTREGA BASEADO NO BAIRRO
            // ====================================================================
            debugLog('🔍 Buscando taxa de entrega para o bairro:', savedAddressData.bairro);
            
            // Buscar taxa na lista de bairros
            let deliveryFee = 0;
            if (typeof neighborhoodsList !== 'undefined' && neighborhoodsList.length > 0) {
                const bairroInfo = neighborhoodsList.find(b => 
                    b.nome.toLowerCase() === savedAddressData.bairro.toLowerCase()
                );
                
                if (bairroInfo && bairroInfo.taxa) {
                    deliveryFee = parseFloat(bairroInfo.taxa);
                    debugLog('✅ Taxa de entrega encontrada:', deliveryFee);
                    
                    // Salvar taxa no orderData.address
                    if (orderData && orderData.address) {
                        orderData.address.deliveryFee = deliveryFee;
                        debugLog('✅ Taxa salva em orderData.address.deliveryFee:', deliveryFee);
                    }
                    
                    // Atualizar variável global da taxa
                    if (typeof currentDeliveryFee !== 'undefined') {
                        currentDeliveryFee = deliveryFee;
                        debugLog('✅ currentDeliveryFee atualizado:', currentDeliveryFee);
                    }
                } else {
                    debugLog('⚠️ Taxa de entrega não encontrada para o bairro:', savedAddressData.bairro);
                }
            } else {
                debugLog('⚠️ neighborhoodsList não disponível');
            }
            
            // Chamar função de busca de bairro para garantir que tudo seja atualizado
            if (typeof performNeighborhoodSearch === 'function') {
                performNeighborhoodSearch(savedAddressData.bairro);
                debugLog('✅ performNeighborhoodSearch chamado para:', savedAddressData.bairro);
            }
            
            // Fechar modal
            closeMyAddressModal();
            
            // Ir direto para o step 3 (dados do cliente / pagamento)
            if (typeof showStep === 'function') {
                showStep(3);
                debugLog('✅ Navegado para checkout-step-3');
                
                // Preencher nome e telefone do usuário logado
                setTimeout(async () => {
                    await fillUserDataInCheckout();
                }, 300);
            }
        }
        
        async function fillUserDataInCheckout() {
            try {
                debugLog('📝 Preenchendo dados do usuário no checkout...');
                
                const { data: { session } } = await supabase.auth.getSession();
                if (!session) {
                    debugLog('⚠️ Usuário não autenticado');
                    return;
                }
                
                // Buscar dados pessoais do usuário da tabela clientes
                const { data: profile, error } = await supabase
                    .from('clientes')
                    .select('*')
                    .eq('user_id', session.user.id)
                    .single();
                
                if (error && error.code !== 'PGRST116') {
                    console.error('❌ Erro ao buscar dados do usuário:', error);
                    return;
                }
                
                if (!profile) {
                    debugLog('ℹ️ Nenhum dado pessoal encontrado para preencher');
                    return;
                }
                
                // Preencher campo Nome
                const nameField = document.getElementById('customer-name');
                if (nameField && profile?.nome_completo) {
                    nameField.value = profile.nome_completo;
                    debugLog('✅ Nome preenchido:', profile.nome_completo);
                }
                
                // Preencher campo WhatsApp
                const whatsappField = document.getElementById('customer-whatsapp');
                if (whatsappField && profile?.telefone) {
                    // Remover código do país se existir (assumindo +55)
                    let telefone = profile.telefone.replace(/\D/g, '');
                    
                    // Se começar com 55, remover
                    if (telefone.startsWith('55') && telefone.length > 11) {
                        telefone = telefone.substring(2);
                    }
                    
                    // Formatar telefone brasileiro (11) 9 9999-9999
                    if (telefone.length === 11) {
                        telefone = `(${telefone.substring(0, 2)}) ${telefone.substring(2, 3)} ${telefone.substring(3, 7)}-${telefone.substring(7)}`;
                    } else if (telefone.length === 10) {
                        telefone = `(${telefone.substring(0, 2)}) ${telefone.substring(2, 6)}-${telefone.substring(6)}`;
                    }
                    
                    whatsappField.value = telefone;
                    debugLog('✅ WhatsApp preenchido:', telefone);
                }
                
                debugLog('✅ Dados do usuário preenchidos com sucesso!');
                
            } catch (error) {
                console.error('❌ Erro ao preencher dados do usuário:', error);
            }
        }

        // Toggle delivery options visibility
        function toggleDeliveryOptions() {
            const showOtherOptionsBtn = document.getElementById('show-other-options');
            const deliveryOptions = document.getElementById('delivery-options');
            const fieldsContainer = document.getElementById('delivery-fields');
            const hiddenOptions = deliveryOptions.querySelectorAll('label[style*="display: none"]');
            
            if (hiddenOptions.length > 0) {
                // Show all options and hide the button
                showAllDeliveryOptions();
                hideOtherOptionsButton();
                
                // Limpar os campos específicos (CEP ou mesa)
                fieldsContainer.innerHTML = '';
                
                // Desmarcar todos os radios
                document.querySelectorAll('input[name="delivery-type"]').forEach(radio => {
                    radio.checked = false;
                });
                
                // Atualizar orderData
                orderData.deliveryType = null;
            }
        }

        // Allow deselecting radio buttons
        function setupDeselectableRadios() {
            let lastChecked = null;
            
            document.addEventListener('click', function(e) {
                if (e.target.type === 'radio' && e.target.name === 'delivery-type') {
                    // If clicking the same radio that was already checked, uncheck it
                    if (lastChecked === e.target) {
                        e.target.checked = false;
                        lastChecked = null;
                        handleDeliveryTypeChange();
                    } else {
                        lastChecked = e.target;
                        handleDeliveryTypeChange();
                    }
                }
            });
        }

        /**
         * Limpa seleção de variação específica
         * @param {string} inputName - Nome do grupo de inputs
         * @param {string} variationIndex - Índice da variação
         */
        function clearVariationSelection(inputName, variationIndex) {
            const radios = document.querySelectorAll(`input[name="${inputName}"]`);
            radios.forEach(radio => {
                radio.checked = false;
            });
            
            // Limpar do objeto selectedVariations
            // Para formato novo (chaves como "0-1", "0-2") e legado (chaves simples)
            if (selectedVariations) {
                // Limpar chave simples (formato legado)
                if (selectedVariations[variationIndex]) {
                    delete selectedVariations[variationIndex];
                }
                
                // Limpar chaves compostas (formato novo: variationIndex-optionIndex)
                Object.keys(selectedVariations).forEach(key => {
                    if (key.startsWith(`${variationIndex}-`)) {
                        delete selectedVariations[key];
                    }
                });
                
                debugLog('🧹 Variações limpas para índice:', variationIndex, 'Estado atual:', selectedVariations);
            }
            
            // Ocultar botões de limpar dessa variação
            hideVariationClearButtons(inputName);
            
            // Atualizar preço do produto
            updateModalPricing();
            updateAddToCartButton();
            
            debugLog('🧹 Variação limpa:', inputName, 'Índice:', variationIndex);
        }

        /**
         * Limpa seleção de preço base
         */
        function clearBasePriceSelection() {
            const radios = document.querySelectorAll('input[name="base-price"]');
            radios.forEach(radio => {
                radio.checked = false;
            });
            
            // Resetar preço base no produto atual
            if (currentProduct) {
                currentProduct.selectedBasePrice = null;
            }
            
            // Resetar display do preço base
            const basePriceElement = document.getElementById('base-price');
            if (basePriceElement && currentProduct) {
                basePriceElement.textContent = getBasePriceDisplay(currentProduct.preco);
            }
            
            // Ocultar botões de limpar preço
            const clearBtns = document.querySelectorAll('.clear-price-btn');
            clearBtns.forEach(btn => btn.style.display = 'none');
            
            // Atualizar preço do produto
            updateModalPricing();
            updateAddToCartButton();
            
            debugLog('🧹 Preço base limpo');
        }

        /**
         * Mostra/oculta botões de limpar baseado na seleção
         */
        function toggleClearButtons() {
            // Para variações
            document.querySelectorAll('input[type="radio"]').forEach(radio => {
                if (radio.name.startsWith('variation-') || radio.name === 'base-price') {
                    const container = radio.closest('label');
                    const clearBtn = container.querySelector('.clear-variation-btn, .clear-price-btn');
                    
                    if (clearBtn) {
                        clearBtn.style.display = radio.checked ? 'inline-block' : 'none';
                    }
                }
            });
        }

        /**
         * Oculta botões de limpar de uma variação específica
         * @param {string} inputName - Nome do grupo de inputs
         */
        function hideVariationClearButtons(inputName) {
            const radios = document.querySelectorAll(`input[name="${inputName}"]`);
            radios.forEach(radio => {
                const container = radio.closest('label');
                const clearBtn = container.querySelector('.clear-variation-btn');
                if (clearBtn) clearBtn.style.display = 'none';
            });
        }

        // Show field error with enhanced visual feedback
        function showFieldError(fieldId, message) {
            const field = document.getElementById(fieldId);
            if (!field) return;
            
            // Clear any existing animations first
            field.classList.remove('shake', 'field-error');
            
            // Remove existing error message
            const existingError = field.parentNode.querySelector('.error-message');
            if (existingError) {
                existingError.remove();
            }
            
            // Force reflow to ensure classes are removed
            field.offsetHeight;
            
            // Add error styling with shake animation
            field.classList.add('field-error', 'shake');
            
            // Add error message with animation
            const errorDiv = document.createElement('div');
            errorDiv.className = 'error-message';
            errorDiv.innerHTML = `
                <span class="text-red-500">⚠️</span>
                <span>${message}</span>
            `;
            field.parentNode.appendChild(errorDiv);
            
            // Focus on field with slight delay
            setTimeout(() => {
                if (typeof field.focus === 'function') {
                    field.focus();
                }
                try {
                    if (field instanceof HTMLInputElement || field instanceof HTMLTextAreaElement) {
                        if (typeof field.select === 'function') {
                            field.select();
                        }
                    }
                } catch (e) { /* noop */ }
            }, 100);
            
            // Remove shake animation after it completes (only once)
            setTimeout(() => {
                field.classList.remove('shake');
            }, 600);
        }

        // Clear field error with smooth transition
        function clearFieldError(fieldId) {
            const field = document.getElementById(fieldId);
            if (!field) return;
            
            // Remove all error-related classes and animations
            field.classList.remove('field-error', 'shake');
            
            // Remove error message with fade out
            const errorMessage = field.parentNode.querySelector('.error-message');
            if (errorMessage) {
                errorMessage.style.opacity = '0';
                errorMessage.style.transform = 'translateY(-5px)';
                setTimeout(() => {
                    if (errorMessage.parentNode) {
                        errorMessage.remove();
                    }
                }, 200);
            }
        }
        


        // Simple validation functions - only called when needed
        function validateTableNumber() {
            const tableNumber = document.getElementById('table-number')?.value.trim();
            if (!tableNumber) {
                showFieldError('table-number', 'Informe o número da mesa ou comanda');
                return false;
            }
            return true;
        }
        
        function validateAddressNumber() {
            const number = document.getElementById('number')?.value.trim();
            if (!number) {
                showFieldError('number', 'Número do endereço é obrigatório');
                return false;
            }
            return true;
        }
        
        function validateCustomerName() {
            const name = document.getElementById('customer-name')?.value.trim();
            if (!name) {
                showFieldError('customer-name', 'Nome completo é obrigatório');
                return false;
            }
            if (name.length < 2) {
                showFieldError('customer-name', 'Nome deve ter pelo menos 2 caracteres');
                return false;
            }
            return true;
        }
        
        function validatePaymentMethod() {
            const checkoutConfig = getCheckoutConfig();
            
            // Check if payment methods are enabled
            if (checkoutConfig.step3_show_formas_pag !== 'Sim') {
                return true; // Skip validation if payment methods are disabled
            }
            
            // Define delivery types that should validate payment methods
            const deliveryTypesWithPayment = ['pickup', 'delivery', 'default'];
            if (!deliveryTypesWithPayment.includes(orderData.deliveryType)) {
                return true; // Skip validation for delivery types without payment
            }
            
            const paymentMethod = document.getElementById('payment-method')?.value;
            if (!paymentMethod) {
                showFieldError('payment-method', 'Selecione a forma de pagamento');
                return false;
            }
            return true;
        }
        
        /**
         * Calcula o total do carrinho
         */
        function calculateCartTotal() {
            return cart.reduce((sum, item) => {
                const price = typeof parsePrice === 'function' ? parsePrice(item.preco) : parseFloat(String(item.preco).replace(/[^0-9.,]/g, '').replace(',', '.')) || 0;
                return price > 0 ? sum + (price * item.quantity) : sum;
            }, 0);
        }
        
        // Atualizar total do pedido no Step 3 (checkout) - MODIFICADO PARA CUPONS
        function updateCheckoutOrderTotal() {
            const totalElement = document.getElementById('checkout-order-total');
            if (totalElement) {
                const cartTotal = calculateCartTotal();
                const deliveryFee = (orderData && orderData.deliveryType === 'delivery')
                    ? ((orderData.address && typeof orderData.address.deliveryFee !== 'undefined')
                        ? orderData.address.deliveryFee
                        : (typeof currentDeliveryFee !== 'undefined' && currentDeliveryFee !== null ? currentDeliveryFee : 0))
                    : 0;
                let finalTotal = cartTotal + deliveryFee;
                
                // Aplicar desconto do cupom se houver
                if (appliedCoupon && couponDiscount > 0) {
                    finalTotal = Math.max(0, finalTotal - couponDiscount);
                }
                
                debugLog('=== ATUALIZANDO TOTAL DO CHECKOUT ===');
                debugLog('Subtotal carrinho:', formatCurrency(cartTotal));
                debugLog('Taxa de delivery:', formatCurrency(deliveryFee));
                debugLog('Desconto cupom:', formatCurrency(couponDiscount));
                debugLog('Total final:', formatCurrency(finalTotal));
                
                // Atualizar total final (sempre limpo)
                totalElement.textContent = formatCurrency(finalTotal);
                
                // Atualizar novo resumo limpo
                updateOrderSummary(cartTotal, deliveryFee);
            }
        }
        
        // ===== SISTEMA DE CUPONS =====
        
        /**
         * Verifica se todos os itens no carrinho são do tipo "consulte preço"
         * @returns {boolean} True se todos os itens forem do tipo "consulte preço"
         */
        function hasOnlyConsultPriceItems() {
            // Se o carrinho estiver vazio, retorna false
            if (cart.length === 0) return false;
            
            // Verifica se todos os itens têm preço zero ou null/undefined
            return cart.every(item => {
                return item.preco === 0 || item.preco === null || item.preco === undefined || isNaN(item.preco);
            });
        }
        
        // Atualizar resumo do pedido - NOVA VERSÃO LIMPA
        function updateOrderSummary(cartTotal, deliveryFee) {
            // Elementos do novo layout
            const subtotalElement = document.getElementById('order-subtotal');
            const deliveryRow = document.getElementById('delivery-row');
            const deliveryFeeElement = document.getElementById('order-delivery-fee');
            const discountRow = document.getElementById('discount-row');
            const discountLabelElement = document.getElementById('discount-label');
            const discountElement = document.getElementById('order-discount');
            const orderSummaryBlock = document.querySelector('.bg-white.border.border-gray-200.rounded-lg.shadow-sm.p-4.mb-4');
            
            if (!subtotalElement) return;
            
            // Verifica se todos os produtos são do tipo "consulte preço"
            const onlyConsultItems = hasOnlyConsultPriceItems();
            
            // Se todos os produtos forem do tipo "consulte preço", oculta o bloco de resumo
            if (onlyConsultItems && orderSummaryBlock) {
                orderSummaryBlock.classList.add('hidden');
                debugLog('Resumo do pedido ocultado: todos os produtos são do tipo "consulte preço"');
                return;
            } else if (orderSummaryBlock) {
                orderSummaryBlock.classList.remove('hidden');
            }
            
            // 1. SUBTOTAL (sempre visível)
            subtotalElement.textContent = formatCurrency(cartTotal);
            
            // 2. FRETE (apenas se houver)
            if (deliveryFee > 0) {
                deliveryRow.classList.remove('hidden');
                deliveryFeeElement.textContent = formatCurrency(deliveryFee);
            } else {
                deliveryRow.classList.add('hidden');
            }
            
            // 3. DESCONTO (apenas se houver cupom aplicado)
            if (appliedCoupon && couponDiscount > 0) {
                discountRow.classList.remove('hidden');
                
                // Obter valor do desconto do cupom
                const discountValue = appliedCoupon.valor_desconto || appliedCoupon.valor || '';
                const discountType = appliedCoupon.tipo_desconto || appliedCoupon.tipo || '';
                const couponCode = appliedCoupon.codigo_cupom || appliedCoupon.codigo;
                
                // Formatar valor do desconto (% ou R$)
                let discountPrefix = '';
                if (discountValue.toString().includes('%')) {
                    // Se contém %, mostrar como percentual
                    discountPrefix = `${discountValue} `;
                } else {
                    // Se é valor fixo, mostrar como moeda
                    const numericValue = parseFloat(discountValue.toString().replace(/[^0-9.,]/g, '').replace(',', '.'));
                    if (!isNaN(numericValue)) {
                        discountPrefix = `${formatCurrency(numericValue)} `;
                    }
                }
                
                // Definir label baseado no tipo de desconto
                let label = 'Desconto';
                
                switch (discountType.toLowerCase()) {
                    case 'produtos':
                        label = `${discountPrefix}Desconto (${couponCode})`;
                        break;
                    case 'frete':
                        label = `${discountPrefix}Desconto Frete (${couponCode})`;
                        break;
                    case 'total':
                        label = `${discountPrefix}Desconto Total (${couponCode})`;
                        break;
                    default:
                        label = `${discountPrefix}Desconto (${couponCode})`;
                        break;
                }
                
                discountLabelElement.textContent = label;
                discountElement.textContent = '-' + formatCurrency(couponDiscount);
            } else {
                discountRow.classList.add('hidden');
            }
        }
        
        // Aplicar cupom via botão
        function applyCouponFromButton() {
            const couponInput = document.getElementById('coupon-code');
            if (!couponInput) return;
            
            const code = couponInput.value.trim().toUpperCase();
            if (!code) {
                showCouponFeedback('Digite um código de cupom', 'error');
                return;
            }
            
            applyCoupon(code);
        }
        
        // Aplicar cupom automaticamente ao digitar (REMOVIDO - agora só via botão)
        function applyCouponOnType(code) {
            // Função mantida para compatibilidade, mas não é mais usada
            // Agora o cupom só é aplicado via botão
        }
        
        // Aplicar cupom
        function applyCoupon(code) {
            debugLog('🔍 Validando cupom:', code);
            
            // Buscar cupom nos dados
            const coupon = couponsData.find(c => 
                (c.codigo_cupom || c.codigo || '').toString().toUpperCase() === code
            );
            
            if (!coupon) {
                showCouponFeedback('Cupom não encontrado', 'error');
                return false;
            }
            
            // Validar datas
            if (!validateCouponDates(coupon)) {
                return false;
            }
            
            // Calcular desconto
            const discount = calculateCouponDiscount(coupon);
            
            // Tratar erros específicos
            if (discount === -1) {
                showCouponFeedback('Cupom não aplicável: carrinho vazio', 'error');
                return false;
            } else if (discount === -2) {
                const discountType = coupon.tipo_desconto || coupon.tipo || '';
                if (discountType.toLowerCase() === 'frete') {
                    showCouponFeedback('Cupom de frete: selecione delivery primeiro', 'error');
                } else {
                    showCouponFeedback('Cupom não aplicável: sem taxa de delivery', 'error');
                }
                return false;
            } else if (discount <= 0) {
                showCouponFeedback('Cupom não aplicável', 'error');
                return false;
            }
            
            // Aplicar cupom
            appliedCoupon = coupon;
            couponDiscount = discount;
            
            // Salvar cupom no localStorage
            if (typeof saveCouponToStorage === 'function') {
                saveCouponToStorage();
            }
            
            debugLog('✅ Cupom aplicado:', code, 'Desconto:', formatCurrency(discount));
            
            // Atualizar interface com feedback simples
            showCouponFeedback('✅ Cupom aplicado com sucesso!', 'success');
            updateCheckoutOrderTotal();
            
            return true;
        }
        
        // Inicializar timezone global a partir do config.js
        function initializeGlobalTimezone() {
            debugLog('🌍 =================================');
            debugLog('🌍 INICIALIZANDO TIMEZONE GLOBAL');
            debugLog('🌍 =================================');
            
            debugLog('📊 TIMEZONE CONFIGURADO NO CONFIG.JS:');
            debugLog('- TIMEZONE constante:', TIMEZONE);
            debugLog('- globalTimezone atual:', globalTimezone);
            
            // Validar se o timezone do config.js é válido
            try {
                debugLog('🧪 TESTANDO VALIDADE DO TIMEZONE...');
                const testDate = new Date().toLocaleString("en-US", {timeZone: TIMEZONE});
                debugLog('- Teste bem-sucedido! Data de teste:', testDate);
                
                globalTimezone = TIMEZONE;
                debugLog('✅ ✅ ✅ TIMEZONE VÁLIDO CONFIGURADO! ✅ ✅ ✅');
                debugLog('- globalTimezone definido como:', globalTimezone);
            } catch (e) {
                errorLog('❌ ❌ ❌ TIMEZONE INVÁLIDO NO CONFIG.JS! ❌ ❌ ❌');
                errorLog('- Timezone configurado:', TIMEZONE);
                errorLog('- Erro:', e.message);
                debugLog('📝 Edite o arquivo config.js e use um timezone válido:');
                debugLog('   - America/Sao_Paulo (Brasil - SP, RJ, MG)');
                debugLog('   - America/Manaus (Brasil - AM, RR)');
                debugLog('   - America/Rio_Branco (Brasil - AC)');
                debugLog('   - America/Fortaleza (Brasil - CE, MA)');
            }
            
            debugLog('🌍 RESULTADO FINAL:');
            debugLog('- globalTimezone:', globalTimezone);
            debugLog('- Tipo:', typeof globalTimezone);
            debugLog('🌍 =================================');
        }
        
        // Obter o timezone configurado (agora usa variável global)
        function getConfiguredTimezone() {
            return globalTimezone;
        }
        
        // Função para teste manual do timezone (use no console)
        window.testTimezone = function(timezone) {
            debugLog('🧪 TESTE MANUAL DE TIMEZONE:');
            debugLog('- Timezone a testar:', timezone);
            try {
                const testDate = new Date().toLocaleString("en-US", {timeZone: timezone});
                debugLog('✅ Timezone válido! Data de teste:', testDate);
                return true;
            } catch (e) {
                errorLog('❌ Timezone inválido:', e.message);
                return false;
            }
        };
        
        // Função para forçar timezone manualmente (use no console)
        window.forceTimezone = function(timezone) {
            debugLog('🔧 FORÇANDO TIMEZONE MANUALMENTE:');
            if (window.testTimezone(timezone)) {
                globalTimezone = timezone;
                debugLog('✅ globalTimezone definido como:', globalTimezone);
                return true;
            }
            return false;
        };
        
        // Funções utilitárias para trabalhar com timezone global
        function getCurrentDateInTimezone() {
            const now = new Date();
            
            // Se globalTimezone não estiver definido, usar data local
            if (!globalTimezone || globalTimezone === '') {
                warnLog('Timezone não configurado, usando data local');
                return now;
            }
            
            try {
                // Usar Intl.DateTimeFormat para conversão mais robusta
                const formatter = new Intl.DateTimeFormat('en-CA', {
                    timeZone: globalTimezone,
                    year: 'numeric',
                    month: '2-digit',
                    day: '2-digit',
                    hour: '2-digit',
                    minute: '2-digit',
                    second: '2-digit',
                    hour12: false
                });
                
                const parts = formatter.formatToParts(now);
                const timezoneString = `${parts.find(p => p.type === 'year').value}-${parts.find(p => p.type === 'month').value}-${parts.find(p => p.type === 'day').value}T${parts.find(p => p.type === 'hour').value}:${parts.find(p => p.type === 'minute').value}:${parts.find(p => p.type === 'second').value}`;
                
                return new Date(timezoneString);
            } catch (e) {
                errorLog('ERRO ao aplicar timezone:', globalTimezone, '- usando data local');
                return now;
            }
        }
        
        /**
         * ===== SISTEMA DE CONTROLE DE PEDIDOS POR HORÁRIO =====
         * Controla se o estabelecimento aceita pedidos baseado no horário de funcionamento
         */
        
        /**
         * Verifica se o estabelecimento aceita pedidos 24 horas
         */
        function acceptsOrdersAllTime() {
            try {
                const result = appConfig?.checkout?.orders_all_time === 'Sim';
                return result;
            } catch (e) {
                errorLog('ERRO na função acceptsOrdersAllTime:', e);
                return false;
            }
        }
        
        /**
         * Verifica se o estabelecimento está aberto no horário atual
         */
        async function isCurrentlyOpen() {
            // Se aceita pedidos 24h, sempre está aberto
            const ordersAllTime = acceptsOrdersAllTime();
            
            if (ordersAllTime) {
                debugLog('✅ Pedidos 24h ativados - sempre aberto');
                return true;
            }
            
            try {
                const currentTime = getCurrentDateInTimezone();
                const dayOfWeek = getDayOfWeekInPortuguese(currentTime.getDay());
                const currentHour = currentTime.getHours();
                const currentMinute = currentTime.getMinutes();
                const currentTimeInMinutes = currentHour * 60 + currentMinute;
                
                const result = await checkIfOpenAtTime(dayOfWeek, currentTimeInMinutes);
                return result;
            } catch (e) {
                errorLog('Erro ao verificar horário:', e);
                return false;
            }
        }
        
        /**
         * Verifica se está aberto em um horário específico
         */
        function checkIfOpenAtTime(dayOfWeek, timeInMinutes) {
            return new Promise(async (resolve) => {
                try {
                    const response = await fetch(HOURS_CSV_URL);
                    const csvText = await response.text();
                    const lines = csvText.trim().split('\n');
                    
                    // Procurar pelo dia da semana (começando da linha 1, pois linha 0 é cabeçalho)
                    for (let i = 1; i < lines.length; i++) {
                        const line = lines[i];
                        if (!line || line.trim() === '') continue;
                        
                        const values = line.split(',').map(v => v.trim());
                        const csvDayName = values[0];
                        
                        if (csvDayName && csvDayName.toLowerCase() === dayOfWeek.toLowerCase()) {
                            // Verificar períodos do dia (começando do índice 1)
                            for (let j = 1; j < values.length; j++) {
                                const periodString = values[j];

                                if (periodString && periodString.trim() !== '') {
                                    const period = parsePeriodString(periodString);

                                    if (isTimeWithinPeriod(timeInMinutes, period)) {
                                        debugLog(`✅ ABERTO: ${dayOfWeek} ${Math.floor(timeInMinutes/60)}:${(timeInMinutes%60).toString().padStart(2,'0')} está no período ${periodString}`);
                                        resolve(true);
                                        return;
                                    }
                                }
                            }
                            break;
                        }
                    }

                    // Verificar se algum período do dia anterior invade a madrugada atual
                    const carryoverStatus = getPreviousDayCarryoverStatus(lines, dayOfWeek, timeInMinutes);
                    if (carryoverStatus.isOpen) {
                        debugLog(`✅ ABERTO (dia anterior) até ${carryoverStatus.nextCloseTime}`);
                        resolve(true);
                        return;
                    }

                    debugLog(`🚫 FECHADO: ${dayOfWeek} ${Math.floor(timeInMinutes/60)}:${(timeInMinutes%60).toString().padStart(2,'0')} fora do horário`);
                    resolve(false);
                } catch (e) {
                    errorLog('ERRO ao verificar horários:', e);
                    resolve(false);
                }
            });
        }
        
        /**
         * Converte string de horário para minutos
         */
        function timeStringToMinutes(timeString) {
            const [hours, minutes] = timeString.split(':').map(Number);
            return hours * 60 + minutes;
        }
        
        /**
         * Encontra o próximo horário de abertura
         */
        async function getNextOpenTime() {
            try {
                const response = await fetch(HOURS_CSV_URL);
                const csvText = await response.text();
                const lines = csvText.trim().split('\n');
                const currentTime = getCurrentDateInTimezone();
                const currentDay = currentTime.getDay();
                
                // Procurar próximo horário nos próximos 7 dias
                for (let dayOffset = 0; dayOffset < 7; dayOffset++) {
                    const checkDay = (currentDay + dayOffset) % 7;
                    const dayName = getDayOfWeekInPortuguese(checkDay);
                    
                    for (let i = 2; i < lines.length; i++) {
                        const values = lines[i].split(',');
                        const csvDayName = values[0]?.trim();
                        
                        if (csvDayName.toLowerCase() === dayName.toLowerCase()) {
                            // Pegar primeiro horário do dia
                            const firstStartTime = values[1]?.trim();
                            if (firstStartTime && firstStartTime !== '') {
                                const dayLabel = dayOffset === 0 ? 'Hoje' : 
                                               dayOffset === 1 ? 'Amanhã' : dayName;
                                return `${dayLabel} às ${firstStartTime}`;
                            }
                            break;
                        }
                    }
                }
                
                return 'Consulte nossos horários';
            } catch (e) {
                errorLog('Erro ao calcular próximo horário:', e);
                return 'Consulte nossos horários';
            }
        }
        
        function formatDateInTimezone(date, options = {}) {
            try {
                let formattedDate = date.toLocaleString('pt-BR', {
                    timeZone: globalTimezone,
                    ...options
                });
                
                // Se a opção weekday ou month está presente, aplicar capitalização
                if (options.weekday || options.month) {
                    // Capitalizar o dia da semana e o mês
                    formattedDate = formattedDate.replace(/\b([a-zà-ÿ]+)(-[a-zà-ÿ]+)?\b/gi, function(match) {
                        // Tratar palavras compostas com hífen (ex: segunda-feira)
                        if (match.includes('-')) {
                            const parts = match.split('-');
                            return parts.map(part => 
                                part.charAt(0).toUpperCase() + part.slice(1).toLowerCase()
                            ).join('-');
                        }
                        
                        // Palavras simples
                        return match.charAt(0).toUpperCase() + match.slice(1).toLowerCase();
                    });
                }
                
                return formattedDate;
            } catch (e) {
                errorLog('❌ Erro ao formatar data com timezone:', globalTimezone, '- usando formato local');
                return date.toLocaleString('pt-BR', options);
            }
        }
        
        function getTimezoneInfo() {
            return {
                timezone: globalTimezone,
                isConfigured: true,
                currentTime: getCurrentDateInTimezone(),
                formatted: formatDateInTimezone(new Date())
            };
        }
        
        // Validar datas do cupom com timezone correto
        function validateCouponDates(coupon) {
            // Obter a data atual usando timezone global
            const timezone = getConfiguredTimezone();
            const timezoneDate = getCurrentDateInTimezone();
            
            debugLog('🔍 Validando cupom:', coupon.codigo_cupom || coupon.codigo);
            debugLog('📅 Data atual (' + timezone + '):', formatDateInTimezone(timezoneDate));
            debugLog('📅 Período do cupom:', coupon.data_inicio, 'até', coupon.data_fim);
            
            // Validar data de início
            if (coupon.data_inicio && coupon.data_inicio !== '-' && coupon.data_inicio.trim()) {
                const startDate = parseCouponDate(coupon.data_inicio, timezone);
                debugLog('📅 Data de início do cupom:', startDate ? startDate.toLocaleString() : 'inválida');
                
                if (startDate && timezoneDate < startDate) {
                    debugLog('❌ Cupom ainda não válido. Será válido a partir de:', startDate.toLocaleString());
                    showCouponFeedback('Cupom ainda não válido. Válido a partir de ' + startDate.toLocaleDateString('pt-BR'), 'error');
                    return false;
                }
            }
            
            // Validar data de fim
            if (coupon.data_fim && coupon.data_fim !== '-' && coupon.data_fim.trim()) {
                const endDate = parseCouponDate(coupon.data_fim, timezone);
                debugLog('📅 Data de fim do cupom:', endDate ? endDate.toLocaleString() : 'inválida');
                
                if (endDate && timezoneDate > endDate) {
                    debugLog('❌ Cupom expirado. Expirou em:', endDate.toLocaleString());
                    showCouponFeedback('Cupom expirado em ' + endDate.toLocaleDateString('pt-BR'), 'error');
                    return false;
                }
            }
            
            debugLog('✅ Cupom válido dentro do período de validade');
            return true;
        }
        
        // Parsear data do cupom considerando o timezone
        function parseCouponDate(dateStr, timezone) {
            if (!dateStr || dateStr === '-' || dateStr.trim() === '') {
                return null;
            }
            
            try {
                // Limpar a string da data
                const cleanDateStr = dateStr.toString().trim();
                
                // Formato DD/MM/YYYY ou DD/MM/YYYY HH:MM
                const parts = cleanDateStr.split(' ');
                const datePart = parts[0];
                const timePart = parts[1] || '23:59'; // Se não houver horário, assume fim do dia
                
                const dateParts = datePart.split('/');
                if (dateParts.length !== 3) {
                    errorLog('❌ Formato de data inválido - deve ser DD/MM/YYYY:', dateStr);
                    return null;
                }
                
                const [day, month, year] = dateParts;
                const [hour, minute] = timePart.split(':');
                
                // Validar se os valores são válidos
                const dayNum = parseInt(day, 10);
                const monthNum = parseInt(month, 10);
                const yearNum = parseInt(year, 10);
                const hourNum = parseInt(hour, 10);
                const minuteNum = parseInt(minute, 10);
                
                if (isNaN(dayNum) || isNaN(monthNum) || isNaN(yearNum) || 
                    dayNum < 1 || dayNum > 31 || 
                    monthNum < 1 || monthNum > 12 || 
                    yearNum < 2000) {
                    errorLog('❌ Valores de data inválidos:', { day: dayNum, month: monthNum, year: yearNum });
                    return null;
                }
                
                // Criar objeto Date usando o construtor padrão (ano, mês-1, dia, hora, minuto)
                // Nota: mês no JavaScript é 0-indexado (0 = Janeiro, 11 = Dezembro)
                const date = new Date(yearNum, monthNum - 1, dayNum, hourNum || 23, minuteNum || 59);
                
                debugLog(`🔄 Convertendo data: ${dateStr} → ${date.toLocaleString('pt-BR')} (${timezone || 'local'})`);
                return date;
            } catch (e) {
                errorLog('❌ Erro ao parsear data do cupom:', dateStr, e);
                return null;
            }
        }
        
        // Calcular desconto do cupom
        function calculateCouponDiscount(coupon) {
            const cartTotal = calculateCartTotal();
            const deliveryFee = currentDeliveryFee || 0;
            const discountValue = coupon.valor_desconto || coupon.valor || '';
            const discountType = coupon.tipo_desconto || coupon.tipo || '';
            
            debugLog('💰 Calculando desconto do cupom:');
            debugLog('- Tipo:', discountType);
            debugLog('- Valor:', discountValue);
            debugLog('- Cart Total:', cartTotal);
            debugLog('- Delivery Fee:', deliveryFee);
            
            let baseValue = 0;
            
            // Determinar valor base para cálculo
            switch (discountType.toLowerCase()) {
                case 'produtos':
                    baseValue = cartTotal;
                    if (baseValue <= 0) {
                        debugLog('❌ Cupom de produtos: carrinho vazio');
                        return -1; // Indicador de erro específico
                    }
                    break;
                case 'frete':
                    baseValue = deliveryFee;
                    if (baseValue <= 0) {
                        debugLog('❌ Cupom de frete: sem taxa de delivery definida');
                        return -2; // Indicador de erro específico
                    }
                    break;
                case 'total':
                    baseValue = cartTotal + deliveryFee;
                    if (baseValue <= 0) {
                        debugLog('❌ Cupom de total: valores zerados');
                        return -1; // Indicador de erro específico
                    }
                    break;
                default:
                    debugLog('❌ Tipo de desconto inválido:', discountType);
                    return 0;
            }
            
            debugLog('- Base Value:', baseValue);
            
            // Calcular desconto
            let discount = 0;
            
            if (discountValue.toString().includes('%')) {
                // Desconto percentual
                const percentage = parseFloat(discountValue.replace('%', ''));
                discount = (baseValue * percentage) / 100;
                debugLog('- Desconto percentual:', percentage + '%', '=', discount);
            } else {
                // Desconto fixo
                discount = parseFloat(discountValue.toString().replace(',', '.')) || 0;
                debugLog('- Desconto fixo:', discount);
            }
            
            // Limitar desconto ao valor base
            const finalDiscount = Math.min(discount, baseValue);
            debugLog('- Desconto final:', finalDiscount);
            
            return finalDiscount;
        }
        
        // Mostrar feedback do cupom
        function showCouponFeedback(message, type) {
            const feedback = document.getElementById('coupon-feedback');
            if (!feedback) return;
            
            feedback.className = `mt-2 text-xs ${type === 'success' ? 'text-green-600' : 'text-red-600'}`;
            feedback.textContent = message;
            feedback.classList.remove('hidden');
            
            // Adicionar animação para chamar atenção
            if (type === 'error') {
                feedback.classList.add('shake-animation');
                setTimeout(() => {
                    feedback.classList.remove('shake-animation');
                }, 500);
            }
            
            // Para erros de data, mostrar também um toast
            if (message.includes('expirado') || message.includes('não válido')) {
                showToast(message, 'error');
            }
            
            // Ocultar após 4 segundos se for erro
            if (type === 'error') {
                setTimeout(() => {
                    feedback.classList.add('hidden');
                }, 4000);
            }
        }
        

        
        // Controlar expansão do campo de cupom
        function toggleCouponField() {
            const container = document.getElementById('coupon-field-container');
            const arrow = document.getElementById('coupon-arrow');
            const toggleBtn = document.getElementById('coupon-toggle-btn');
            
            if (!container || !arrow) return;
            
            const isExpanded = container.style.maxHeight !== '0px' && container.style.maxHeight !== '';
            
            if (isExpanded) {
                // Contrair
                container.style.maxHeight = '0';
                container.style.opacity = '0';
                arrow.style.transform = 'rotate(0deg)';
                debugLog('🎟️ Campo de cupom contraído');
            } else {
                // Expandir
                container.style.maxHeight = '200px';
                container.style.opacity = '1';
                arrow.style.transform = 'rotate(180deg)';
                
                // Focar no campo após expansão
                setTimeout(() => {
                    const couponInput = document.getElementById('coupon-code');
                    if (couponInput) {
                        couponInput.focus();
                    }
                }, 300);
                
                debugLog('🎟️ Campo de cupom expandido');
            }
        }
        

        
        // Controlar visibilidade do botão de limpar inline
        function toggleClearButton() {
            const couponInput = document.getElementById('coupon-code');
            const clearBtn = document.getElementById('clear-coupon-btn');
            
            if (!couponInput || !clearBtn) return;
            
            if (couponInput.value.trim().length > 0) {
                clearBtn.classList.remove('hidden');
            } else {
                clearBtn.classList.add('hidden');
            }
        }
        
        // Limpar input e resetar cupom completamente
        function clearCouponInput() {
            const couponInput = document.getElementById('coupon-code');
            const clearBtn = document.getElementById('clear-coupon-btn');
            
            // Limpar o input
            if (couponInput) {
                couponInput.value = '';
                couponInput.focus();
            }
            
            // Esconder botão de limpar
            if (clearBtn) {
                clearBtn.classList.add('hidden');
            }
            
            // Resetar cupom aplicado (usar função existente)
            clearCoupon();
            
            // Atualizar resumo do pedido
            updateOrderSummary();
            
            debugLog('🎟️ Input limpo e cupom resetado completamente');
        }
        
        // Limpar cupom
        function clearCoupon() {
            appliedCoupon = null;
            couponDiscount = 0;
            
            // Limpar cupom do localStorage
            if (typeof clearCouponFromStorage === 'function') {
                clearCouponFromStorage();
            }
            
            // Limpar interface
            const feedback = document.getElementById('coupon-feedback');
            if (feedback) feedback.classList.add('hidden');
            
            // Contrair campo de cupom
            const container = document.getElementById('coupon-field-container');
            const arrow = document.getElementById('coupon-arrow');
            if (container && arrow) {
                container.style.maxHeight = '0';
                container.style.opacity = '0';
                arrow.style.transform = 'rotate(0deg)';
            }
            
            // Limpar campo de input
            const couponInput = document.getElementById('coupon-code');
            if (couponInput) {
                couponInput.value = '';
            }
            
            // Atualizar total e resumo
            updateCheckoutOrderTotal();
        }
        
        // Resetar sistema de cupons
        function resetCouponSystem() {
            debugLog('🔄 Resetando sistema de cupons');
            
            // Limpar variáveis
            appliedCoupon = null;
            couponDiscount = 0;
            
            // Limpar timeout
            if (couponTimeout) {
                clearTimeout(couponTimeout);
                couponTimeout = null;
            }
            
            // Limpar campo de entrada
            const couponInput = document.getElementById('coupon-code');
            if (couponInput) couponInput.value = '';
            
            // Limpar interface
            clearCoupon();
        }
        
        // Adicionar informações do cupom à mensagem do WhatsApp
        function addCouponInfoToWhatsAppMessage(message) {
            if (!appliedCoupon || couponDiscount <= 0) {
                return message;
            }
            
            const discountType = appliedCoupon.tipo_desconto || appliedCoupon.tipo || '';
            let typeText = '';
            
            switch (discountType.toLowerCase()) {
                case 'produtos':
                    typeText = 'nos produtos';
                    break;
                case 'frete':
                    typeText = 'no frete';
                    break;
                case 'total':
                    typeText = 'no total';
                    break;
            }
            
            const couponInfo = `\n\n🎟️ *Cupom Aplicado:*\n   ${appliedCoupon.codigo_cupom || appliedCoupon.codigo}\n   Desconto: ${formatCurrency(couponDiscount)} (${typeText})`;
            
            // Inserir antes do total final
            const totalIndex = message.lastIndexOf('💰 *Total:');
            if (totalIndex !== -1) {
                return message.slice(0, totalIndex) + couponInfo + '\n\n' + message.slice(totalIndex);
            }
            
            return message + couponInfo;
        }
        
        // Handle payment method change
        function handlePaymentMethodChange() {
            const paymentMethod = document.getElementById('payment-method').value;
            const changeToggleContainer = document.getElementById('change-toggle-container');
            const changeDiv = document.getElementById('money-change');
            const changeToggle = document.getElementById('change-toggle');
            const pixDiv = document.getElementById('pix-info');
            
            // SEMPRE resetar o campo de troco ao mudar forma de pagamento
            resetChangeAmountField();
            
            // Reset do estado do switcher
            if (changeToggle) {
                changeToggle.checked = false;
                // Não chamar handleChangeToggle() aqui pois já resetamos o campo acima
                const toggleLabel = document.getElementById('change-toggle-label');
                if (toggleLabel) {
                    toggleLabel.textContent = 'Não';
                    toggleLabel.style.color = 'var(--cor-texto-secundario)';
                }
            }
            
            if (paymentMethod === 'dinheiro') {
                // DINHEIRO: Mostrar switcher de troco
                changeToggleContainer.classList.remove('hidden');
                if (pixDiv) pixDiv.classList.add('hidden');
                debugLog('💵 Dinheiro selecionado - switcher de troco disponível (campo resetado)');
            } else if (paymentMethod === 'pix') {
                // PIX: Ocultar switcher e mostrar info do PIX
                changeToggleContainer.classList.add('hidden');
                changeDiv.classList.add('hidden');
                showPixInfo();
                debugLog('📱 PIX selecionado - mostrando informações da chave (campo de troco resetado)');
            } else {
                // OUTROS: Ocultar tudo relacionado a troco e PIX
                changeToggleContainer.classList.add('hidden');
                changeDiv.classList.add('hidden');
                if (pixDiv) pixDiv.classList.add('hidden');
                debugLog('💳 Outra forma de pagamento selecionada - ocultando troco e PIX (campo resetado)');
            }
        }
        
        /**
         * Limpa completamente o campo de troco
         */
        function resetChangeAmountField() {
            const changeInput = document.getElementById('change-amount');
            if (changeInput) {
                // Limpar o valor do campo
                changeInput.value = '';
                changeInput.placeholder = 'Ex: R$ 50,00';
                
                // Limpar erros de validação
                clearFieldError('change-amount');
                
                // Remover o feedback de cálculo do troco ("Troco: R$ X,XX")
                const existingFeedback = changeInput.parentNode.querySelector('.change-feedback');
                if (existingFeedback) {
                    existingFeedback.remove();
                    debugLog('🧹 Label de cálculo do troco removido');
                }
                
                debugLog('🧹 Campo de troco resetado completamente (input + label)');
            }
        }
        
        /**
         * Manipula o toggle do switcher de troco
         */
        function handleChangeToggle() {
            const toggle = document.getElementById('change-toggle');
            const changeDiv = document.getElementById('money-change');
            const toggleLabel = document.getElementById('change-toggle-label');
            
            // SEMPRE resetar o campo de troco ao mexer no switcher
            resetChangeAmountField();
            
            if (toggle.checked) {
                // Switcher LIGADO - mostrar campo de troco
                changeDiv.classList.remove('hidden');
                toggleLabel.textContent = 'Sim';
                toggleLabel.style.color = 'var(--cor-primaria)';
                setupChangeAmountField();
                debugLog('💰 Switcher de troco ATIVADO - campo de valor exibido e resetado');
            } else {
                // Switcher DESLIGADO - ocultar campo de troco
                changeDiv.classList.add('hidden');
                toggleLabel.textContent = 'Não';
                toggleLabel.style.color = 'var(--cor-texto-secundario)';
                debugLog('💰 Switcher de troco DESATIVADO - campo de valor oculto e resetado');
            }
        }
        
        /**
         * Calcula o total final do pedido (subtotal + frete - desconto)
         */
        function calculateFinalOrderTotal() {
            const cartTotal = calculateCartTotal();
            const deliveryFee = (orderData && orderData.deliveryType === 'delivery')
                ? ((orderData.address && typeof orderData.address.deliveryFee !== 'undefined')
                    ? orderData.address.deliveryFee
                    : (typeof currentDeliveryFee !== 'undefined' && currentDeliveryFee !== null ? currentDeliveryFee : 0))
                : 0;
            let finalTotal = cartTotal + deliveryFee;
            
            // Aplicar desconto do cupom se houver
            if (appliedCoupon && couponDiscount > 0) {
                finalTotal = Math.max(0, finalTotal - couponDiscount);
            }
            
            return finalTotal;
        }
        
        /**
         * Configura o campo de troco com validação
         */
        function setupChangeAmountField() {
            debugLog('=== SETUP CHANGE AMOUNT FIELD ===');
            const changeInput = document.getElementById('change-amount');
            const total = calculateFinalOrderTotal();
            
            debugLog('Change input element:', changeInput);
            debugLog('Cart total:', total);
            debugLog('Cart contents:', cart);
            
            // Definir placeholder simples
            changeInput.placeholder = 'Ex: ' + formatCurrency(Math.ceil(total / 10) * 10 + 10);
            
            // Adicionar validação em tempo real com máscara da moeda atual
            changeInput.oninput = function() {
                formatMoney(this); // Aplicar máscara da moeda atual
                const currentTotal = calculateFinalOrderTotal(); // Recalcular total em tempo real
                validateChangeAmount(this.value, currentTotal);
                clearFieldError('change-amount');
            };
            
            // Remover o oninput antigo do HTML que usava formatMoney genérico
            changeInput.removeAttribute('oninput');
            
            // Focar no campo
            setTimeout(() => changeInput.focus(), 100);
        }
        
        /**
         * Valida o valor do troco em tempo real
         */
        function validateChangeAmount(changeValue, total) {
            const changeInput = document.getElementById('change-amount');
            const numericValue = parseFloat(changeValue.replace(/[^\d,]/g, '').replace(',', '.'));
            
            // Remover feedback anterior
            const existingFeedback = changeInput.parentNode.querySelector('.change-feedback');
            if (existingFeedback) existingFeedback.remove();
            
            if (!isNaN(numericValue) && numericValue > total) {
                const changeAmount = numericValue - total;
                
                // Criar feedback positivo
                const feedback = document.createElement('div');
                feedback.className = 'change-feedback text-sm mt-1 flex items-center space-x-2';
                feedback.style.color = 'var(--cor-sucesso)';
                feedback.innerHTML = `
                    <svg class="w-4 h-4" fill="currentColor" viewBox="0 0 20 20">
                        <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clip-rule="evenodd"></path>
                    </svg>
                    <span>Troco: ${formatCurrency(changeAmount)}</span>
                `;
                
                changeInput.parentNode.appendChild(feedback);
            } else if (!isNaN(numericValue) && numericValue <= total) {
                // Criar feedback de erro
                const feedback = document.createElement('div');
                feedback.className = 'change-feedback text-sm mt-1 flex items-center space-x-2';
                feedback.style.color = 'var(--cor-erro)';
                feedback.innerHTML = `
                    <svg class="w-4 h-4" fill="currentColor" viewBox="0 0 20 20">
                        <path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7 4a1 1 0 11-2 0 1 1 0 012 0zm-1-9a1 1 0 00-1 1v4a1 1 0 102 0V6a1 1 0 00-1-1z" clip-rule="evenodd"></path>
                    </svg>
                    <span>Valor deve ser maior que ${formatCurrency(total)}</span>
                `;
                
                changeInput.parentNode.appendChild(feedback);
            }
        }
        
        // Initialize everything
        document.addEventListener('DOMContentLoaded', function() {
            loadAllData(); // This will load CSV data and then call initializeApp()
        });
        
        // Setup event listeners (called after data is loaded)
        function setupEventListeners() {
            setupSearch();
            setupScrollSpy();
            handleInitialHash();
            setupDeselectableRadios();
            setupKeyboardShortcuts();
            setupResizeHandler();
            setupFormStorageListeners();
        }
        
        // Setup resize handler melhorado - sem interferir no scroll do usuário
        function setupResizeHandler() {
            let resizeTimeout;
            // ❌ REMOVIDO: Event listener de scroll que conflitava com scroll spy
            // O scroll spy já gerencia a detecção de scroll adequadamente
            
            // Event listener de resize - SIMPLIFICADO para não interferir com scroll spy
            window.addEventListener('resize', () => {
                clearTimeout(resizeTimeout);
                resizeTimeout = setTimeout(() => {
                    // Apenas atualizar setas de navegação das categorias se necessário
                    if (typeof updateNavigationArrows === 'function') {
                        updateNavigationArrows();
                    }
                    debugLog('📱 Resize handler executado - setas atualizadas');
                }, 300);
            });
        }
        
        // Setup listeners para salvar dados do formulário no localStorage
        function setupFormStorageListeners() {
            // Listener para campos de texto
            document.addEventListener('input', function(e) {
                if (e.target.matches('#customer-name, #customer-whatsapp, #payment-method, #change-amount, #order-notes')) {
                    // Debounce para evitar muitas escritas
                    clearTimeout(window.formSaveTimeout);
                    window.formSaveTimeout = setTimeout(() => {
                        updateOrderDataFromForm();
                        if (typeof saveOrderDataToStorage === 'function') {
                            saveOrderDataToStorage();
                        }
                    }, 1000);
                }
            });
            
            // Listener para radio buttons
            document.addEventListener('change', function(e) {
                if (e.target.matches('input[name="delivery-type"]')) {
                    updateOrderDataFromForm();
                    if (typeof saveOrderDataToStorage === 'function') {
                        saveOrderDataToStorage();
                    }
                }
            });
            
            debugLog('👂 Listeners de formulário para localStorage configurados');
        }
        
        // Atualizar dados do pedido a partir do formulário
        function updateOrderDataFromForm() {
            try {
                const customerName = document.getElementById('customer-name')?.value || '';
                const whatsapp = document.getElementById('customer-whatsapp')?.value || '';
                const paymentMethod = document.getElementById('payment-method')?.value || '';
                const changeAmount = document.getElementById('change-amount')?.value || '';
                const notes = document.getElementById('order-notes')?.value || '';
                const deliveryType = document.querySelector('input[name="delivery-type"]:checked')?.value || '';
                
                orderData.customerName = customerName;
                orderData.whatsapp = whatsapp;
                orderData.paymentMethod = paymentMethod;
                orderData.changeAmount = changeAmount;
                orderData.notes = notes;
                orderData.deliveryType = deliveryType;
            } catch (e) {
                errorLog('Erro ao atualizar orderData:', e);
            }
        }
        
        // Configura atalhos de teclado
        function setupKeyboardShortcuts() {
            debugLog('🎹 Configurando atalhos de teclado...');
            
            document.addEventListener('keydown', function(e) {
                // Fechar lightbox ou modal com Escape
                if (e.key === 'Escape') {
                    const lightbox = document.getElementById('image-lightbox');
                    const helpModal = document.getElementById('help-modal');
                    
                    if (!lightbox.classList.contains('hidden')) {
                        closeLightbox();
                    } else if (!helpModal.classList.contains('hidden')) {
                        closeHelpModal();
                    }
                    return;
                }
                
                // Atalho F1 para abrir ajuda
                if (e.key === 'F1') {
                    e.preventDefault(); // Evita abrir o menu de ajuda padrão do navegador
                    const helpModal = document.getElementById('help-modal');
                    if (helpModal.classList.contains('hidden')) {
                        openHelpModal();
                    } else {
                        closeHelpModal();
                    }
                }
            });
            
            debugLog('✅ Atalhos configurados: F1 (Ajuda), Escape (Fechar)');
        }
        
        /**
         * Abre o Gerador de Variações (Shift + V)
         */
        function openVariationGenerator() {
            debugLog('🔧 Abrindo Gerador de Variações...');
            
            // Mostrar toast informativo
            showToast('🔧 Abrindo Gerador de Variações', 'info', 2000);
            
            // Abrir em nova aba após pequeno delay para mostrar o toast
            setTimeout(() => {
                window.open('https://dantetesta.com.br/gerador-de-variacoes/', '_blank');
                debugLog('✅ Gerador de Variações aberto em nova aba');
            }, 500);
        }
        
        /**
         * Abre o Gerador de QR Code (Shift + Q)
         */
        function openQRCodeGenerator() {
            debugLog('📱 Abrindo Gerador de QR Code...');
            
            // Mostrar toast informativo
            showToast('📱 Abrindo Gerador de QR Code', 'info', 2000);
            
            // Abrir em nova aba após pequeno delay para mostrar o toast
            setTimeout(() => {
                window.open('https://dantetesta.com.br/qrcode-generator/', '_blank');
                debugLog('✅ Gerador de QR Code aberto em nova aba');
            }, 500);
        }
        
        /**
         * Abre o Gerador de Cores (Shift + C)
         */
        function openColorGenerator() {
            debugLog('🎨 Abrindo Gerador de Cores...');
            
            // Mostrar toast informativo
            showToast('🎨 Abrindo Gerador de Cores', 'info', 2000);
            
            // Abrir em nova aba após pequeno delay para mostrar o toast
            setTimeout(() => {
                window.open('https://dantetesta.com.br/color-generator/', '_blank');
                debugLog('✅ Gerador de Cores aberto em nova aba');
            }, 500);
        }
        
        /**
         * Abre o Modal de Ajuda com Atalhos (F1)
         */
        function openHelpModal() {
            debugLog('💡 Abrindo Modal de Ajuda...');
            
            const modal = document.getElementById('help-modal');
            if (modal) {
                modal.classList.remove('hidden');
                document.body.style.overflow = 'hidden';
                debugLog('✅ Modal de Ajuda aberto');
            } else {
                errorLog('❌ Modal de ajuda não encontrado');
            }
        }
        
        /**
         * Fecha o Modal de Ajuda
         */
        function closeHelpModal() {
            debugLog('❌ Fechando Modal de Ajuda...');
            
            const modal = document.getElementById('help-modal');
            if (modal) {
                modal.classList.add('hidden');
                document.body.style.overflow = '';
                debugLog('✅ Modal de Ajuda fechado');
            }
        }

        // ====================================================================
        // SISTEMA DE TAXA DE DELIVERY POR BAIRRO - V3.3.4
        // ====================================================================

        /**
         * Busca a taxa de delivery para um bairro específico
         * @param {string} neighborhood - Nome do bairro
         * @returns {number|null} - Valor da taxa ou null se não encontrado
         */
        function findDeliveryFeeByNeighborhood(neighborhood) {
            // Usar dados globais se disponíveis
            const dataSource = window.neighborhoodsData || neighborhoodsData;
            
            if (!neighborhood || !dataSource.length) {
                return null;
            }
            
            const normalizedNeighborhood = neighborhood.trim().toLowerCase();
            
            // 🔒 BUSCA EXATA APENAS - NÃO MAIS BUSCA PARCIAL
            let found = dataSource.find(item => {
                const itemBairro = (item.bairro || '').toLowerCase().trim();
                return itemBairro === normalizedNeighborhood;
            });
            
            if (found) {
                debugLog(`💰 Taxa encontrada para "${neighborhood}": R$ ${found.taxa}`);
                return found.taxa;
            }
            
            debugLog(`❌ Taxa não encontrada para o bairro: "${neighborhood}"`);
            return null;
        }

        /**
         * Exibe a taxa de delivery na interface ou alerta para consultar
         * @param {number|null} fee - Valor da taxa ou null se não encontrado
         * @param {string} neighborhood - Nome do bairro
         */
        function displayDeliveryFee(fee, neighborhood) {
            // Remove alertas anteriores se existirem
            const existingAlert = document.getElementById('delivery-fee-alert');
            const existingNotServedAlert = document.getElementById('neighborhood-not-served-alert');
            if (existingAlert) existingAlert.remove();
            if (existingNotServedAlert) existingNotServedAlert.remove();
            
            // Controlar visibilidade do alerta original
            const originalAlert = document.getElementById('original-delivery-fee-alert');
            
            // 🔒 Validar bairro para modo de restrição
            const config = getCheckoutConfig();
            const isNeighborhoodValid = validateNeighborhoodForDelivery(neighborhood);
            
            let alertHtml = '';
            
            // Exibir mensagem também quando a taxa for 0 (frete grátis)
            if (fee !== null && !isNaN(fee) && fee >= 0 && isNeighborhoodValid) {
                // Sincronizar estado com a taxa encontrada
                try {
                    if (!window.orderData) window.orderData = {};
                    if (!window.orderData.address) window.orderData.address = {};
                    window.orderData.address.neighborhood = neighborhood;
                    window.orderData.address.deliveryFee = fee;
                    window.currentDeliveryFee = fee;
                    // Memorizar última consulta
                    window.lastNeighborhoodFee = fee;
                    window.lastNeighborhoodName = neighborhood;
                    debugLog('🔄 Estado sincronizado em displayDeliveryFee:', {
                        neighborhood,
                        deliveryFee: fee
                    });
                    // Recalcular total/resumo imediatamente
                    if (typeof updateCheckoutOrderTotal === 'function') {
                        updateCheckoutOrderTotal();
                    }
                } catch (e) {
                    errorLog('Erro ao sincronizar taxa em displayDeliveryFee:', e);
                }
                // Taxa encontrada e bairro válido - ocultar alerta original
                if (originalAlert) {
                    originalAlert.style.display = 'none';
                }
                // Taxa encontrada - mostrar valor calculado
                alertHtml = `
                    <div id="delivery-fee-alert" class="mt-4 p-4 rounded-lg border-l-4" style="background-color: #f0f9ff; border-color: var(--cor-primaria);">
                        <div class="flex items-start">
                            <div class="flex-shrink-0">
                                <svg class="w-5 h-5 mt-0.5" style="color: var(--cor-primaria);" fill="currentColor" viewBox="0 0 20 20">
                                    <path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2v-3a1 1 0 00-1-1H9z" clip-rule="evenodd"></path>
                                </svg>
                            </div>
                            <div class="ml-3 flex-1">
                                <h3 class="text-sm font-medium" style="color: var(--cor-primaria);">
                                    🚚 Taxa de Delivery Calculada
                                </h3>
                                <div class="mt-2 text-sm" style="color: var(--cor-texto);">
                                    <p><strong>Bairro:</strong> ${neighborhood}</p>
                                    <p><strong>Taxa:</strong> <span class="font-bold" style="color: var(--cor-primaria);">${formatCurrency(fee)}</span></p>
                                    <p class="mt-1 text-xs" style="color: var(--cor-texto-primario);">
                                        Esta taxa será adicionada ao valor total do seu pedido.
                                    </p>
                                </div>
                            </div>
                        </div>
                    </div>
                `;
                
                // Habilitar botão continuar
                updateContinueButtonState(true, neighborhood);
                
            } else if (!isNeighborhoodValid && config.only_bairro_mode === 'Sim') {
                // Bairro não atendido no modo de restrição
                if (originalAlert) {
                    originalAlert.style.display = 'none';
                }
                
                // Mostrar mensagem de bairro não atendido
                showNeighborhoodNotServedMessage(neighborhood);
                
                // Desabilitar botão continuar
                updateContinueButtonState(false, neighborhood);
                
            } else {
                // Taxa não encontrada mas bairro válido (ou modo desativado) - mostrar alerta original
                if (originalAlert) {
                    originalAlert.style.display = 'block';
                }
                
                // Atualizar estado do botão continuar
                updateContinueButtonState(isNeighborhoodValid, neighborhood);
            }
            
            // Inserir após os campos de endereço
            const addressFields = document.getElementById('address-fields');
            if (addressFields && alertHtml) {
                addressFields.insertAdjacentHTML('afterend', alertHtml);
            }
        }

        /**
         * Valida se o bairro está na lista de atendimento quando only_bairro_mode está ativo
         * @param {string} neighborhood - Nome do bairro a ser validado
         * @returns {boolean} - true se bairro é válido ou modo não está ativo
         */
        function validateNeighborhoodForDelivery(neighborhood) {
            const config = getCheckoutConfig();
            
            // Se modo de restrição não está ativo, sempre permitir
            if (config.only_bairro_mode !== 'Sim') {
                debugLog('🔓 Modo de restrição por bairro DESATIVADO - permitindo qualquer bairro');
                return true;
            }
            
            debugLog('🔒 Modo de restrição por bairro ATIVADO - validando:', neighborhood);
            
            // Verificar se dados de bairros estão disponíveis
            if (!window.neighborhoodsData || window.neighborhoodsData.length === 0) {
                debugLog('❌ Dados de bairros não disponíveis para validação');
                return false;
            }
            
            // Normalizar bairro para busca EXATA
            const normalizedNeighborhood = neighborhood.toLowerCase().trim();
            
            // 🔒 BUSCA EXATA APENAS - igual à função de busca de taxa
            const found = window.neighborhoodsData.find(item => {
                const itemBairro = (item.bairro || '').toLowerCase().trim();
                return itemBairro === normalizedNeighborhood;
            });
            
            const isValid = !!found;
            debugLog(isValid ? '✅ Bairro VÁLIDO para entrega' : '❌ Bairro NÃO ATENDIDO', { bairro: neighborhood, encontrado: found });
            
            return isValid;
        }

        /**
         * Controla o estado do botão continuar baseado na validação do bairro
         * @param {boolean} isValid - Se o bairro é válido
         * @param {string} neighborhood - Nome do bairro
         */
        function updateContinueButtonState(isValid, neighborhood = '') {
            const config = getCheckoutConfig();
            const continueButton = document.querySelector('button[onclick="nextStep(3)"]');
            
            if (!continueButton) {
                debugLog('❌ Botão continuar não encontrado');
                return;
            }
            
            // Se modo de restrição não está ativo, sempre habilitar
            if (config.only_bairro_mode !== 'Sim') {
                continueButton.disabled = false;
                continueButton.classList.remove('opacity-50', 'cursor-not-allowed');
                continueButton.classList.add('hover:opacity-90');
                return;
            }
            
            // Controlar estado do botão baseado na validação
            if (isValid) {
                // Habilitar botão
                continueButton.disabled = false;
                continueButton.classList.remove('opacity-50', 'cursor-not-allowed');
                continueButton.classList.add('hover:opacity-90');
                debugLog('✅ Botão continuar HABILITADO');
            } else {
                // Desabilitar botão
                continueButton.disabled = true;
                continueButton.classList.add('opacity-50', 'cursor-not-allowed');
                continueButton.classList.remove('hover:opacity-90');
                debugLog('❌ Botão continuar DESABILITADO');
            }
        }

        /**
         * Exibe mensagem de erro quando bairro não é atendido
         * @param {string} neighborhood - Nome do bairro
         */
        function showNeighborhoodNotServedMessage(neighborhood) {
            const contactConfig = getContactConfig();
            
            // Remove mensagem anterior se existir
            const existingMessage = document.getElementById('neighborhood-not-served-alert');
            if (existingMessage) {
                existingMessage.remove();
            }
            
            // Criar mensagem de erro
            const whatsappNumber = contactConfig.whatsapp || '5519998021956';
            const formattedWhatsapp = formatPhoneForDisplay(whatsappNumber);
            
            const alertHtml = `
                <div id="neighborhood-not-served-alert" class="mt-4 p-4 rounded-lg border-l-4" style="background-color: #fef2f2; border-color: #ef4444;">
                    <div class="flex items-start">
                        <div class="flex-shrink-0">
                            <svg class="w-5 h-5 mt-0.5" style="color: #ef4444;" fill="currentColor" viewBox="0 0 20 20">
                                <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM8.707 7.293a1 1 0 00-1.414 1.414L8.586 10l-1.293 1.293a1 1 0 101.414 1.414L10 11.414l1.293 1.293a1 1 0 001.414-1.414L11.414 10l1.293-1.293a1 1 0 00-1.414-1.414L10 8.586 8.707 7.293z" clip-rule="evenodd"></path>
                            </svg>
                        </div>
                        <div class="ml-3 flex-1">
                            <h3 class="text-sm font-medium" style="color: #ef4444;">
                                ⚠️ Bairro não atendido
                            </h3>
                            <div class="mt-2 text-sm" style="color: #7f1d1d;">
                                <p><strong>Bairro informado:</strong> ${neighborhood}</p>
                                <p class="mt-2">Infelizmente não atendemos o seu bairro.</p>
                                <p class="mt-1">Entre em contato via WhatsApp para mais informações:</p>
                                <a href="https://wa.me/${whatsappNumber}" target="_blank" 
                                   class="inline-flex items-center mt-2 px-3 py-2 text-sm font-medium text-white rounded-md transition-colors"
                                   style="background-color: #25D366; hover:background-color: #128C7E;">
                                    <svg class="w-4 h-4 mr-2" fill="currentColor" viewBox="0 0 24 24">
                                        <path d="M17.472 14.382c-.297-.149-1.758-.867-2.03-.967-.273-.099-.471-.148-.67.15-.197.297-.767.966-.94 1.164-.173.199-.347.223-.644.075-.297-.15-1.255-.463-2.39-1.475-.883-.788-1.48-1.761-1.653-2.059-.173-.297-.018-.458.13-.606.134-.133.298-.347.446-.52.149-.174.198-.298.298-.497.099-.198.05-.371-.025-.52-.075-.149-.669-1.612-.916-2.207-.242-.579-.487-.5-.669-.51-.173-.008-.371-.01-.57-.01-.198 0-.52.074-.792.372-.272.297-1.04 1.016-1.04 2.479 0 1.462 1.065 2.875 1.213 3.074.149.198 2.096 3.2 5.077 4.487.709.306 1.262.489 1.694.625.712.227 1.36.195 1.871.118.571-.085 1.758-.719 2.006-1.413.248-.694.248-1.289.173-1.413-.074-.124-.272-.198-.57-.347m-5.421 7.403h-.004a9.87 9.87 0 01-5.031-1.378l-.361-.214-3.741.982.998-3.648-.235-.374a9.86 9.86 0 01-1.51-5.26c.001-5.45 4.436-9.884 9.888-9.884 2.64 0 5.122 1.03 6.988 2.898a9.825 9.825 0 012.893 6.994c-.003 5.45-4.437 9.884-9.885 9.884m8.413-18.297A11.815 11.815 0 0012.05 0C5.495 0 .16 5.335.157 11.892c0 2.096.547 4.142 1.588 5.945L.057 24l6.305-1.654a11.882 11.882 0 005.683 1.448h.005c6.554 0 11.89-5.335 11.893-11.893A11.821 11.821 0 0020.885 3.488"/>
                                    </svg>
                                    📱 ${formattedWhatsapp}
                                </a>
                            </div>
                        </div>
                    </div>
                </div>
            `;
            
            // Inserir após os campos de endereço
            const addressFields = document.getElementById('address-fields');
            if (addressFields) {
                addressFields.insertAdjacentHTML('afterend', alertHtml);
            }
        }

        /**
         * Remove a exibição da taxa de delivery
         */
        function clearDeliveryFee() {
            currentDeliveryFee = null;
            if (window.orderData && window.orderData.address) {
                delete window.orderData.address.deliveryFee;
            }
            const existingAlert = document.getElementById('delivery-fee-alert');
            if (existingAlert) {
                existingAlert.remove();
            }
            
            // NÃO mostrar alerta original automaticamente
            // Ele só deve aparecer quando bairro não for encontrado
            const originalAlert = document.getElementById('original-delivery-fee-alert');
            if (originalAlert) {
                originalAlert.style.display = 'none';
            }
            
            // Recalcular total do checkout/resumo após limpar a taxa
            if (typeof updateCheckoutOrderTotal === 'function') {
                updateCheckoutOrderTotal();
            }
        }

        /**
         * Processa a taxa de delivery após validação do CEP
         * @param {object} addressData - Dados do endereço
         */
        function processDeliveryFeeAfterCEP(addressData) {
            if (!addressData || !addressData.neighborhood) {
                clearDeliveryFee();
                return;
            }
            
            // Buscar taxa para o bairro
            const fee = findDeliveryFeeByNeighborhood(addressData.neighborhood);
            
            if (fee !== null && fee > 0) {
                currentDeliveryFee = fee;
                
                // Salvar taxa de delivery no localStorage
                if (typeof saveDeliveryFeeToStorage === 'function') {
                    saveDeliveryFeeToStorage();
                }
                
                displayDeliveryFee(fee, addressData.neighborhood);
                
                // Adicionar taxa aos dados do pedido
                if (window.orderData && window.orderData.address) {
                    window.orderData.address.deliveryFee = fee;
                }
            } else {
                // Taxa não encontrada - limpar taxa mas exibir alerta para consultar
                currentDeliveryFee = null;
                
                // Salvar taxa de delivery no localStorage
                if (typeof saveDeliveryFeeToStorage === 'function') {
                    saveDeliveryFeeToStorage();
                }
                if (window.orderData && window.orderData.address) {
                    delete window.orderData.address.deliveryFee;
                }
                // Exibir alerta para consultar taxa
                displayDeliveryFee(null, addressData.neighborhood);
            }
            
            // Atualizar total do checkout após mudança na taxa de delivery
            if (typeof updateCheckoutOrderTotal === 'function') {
                updateCheckoutOrderTotal();
            }
        }

        /**
         * Atualiza os dados do endereço quando editado manualmente
         */
        function updateAddressData() {
            if (!window.orderData || !window.orderData.address) {
                return;
            }
            
            // Atualizar dados do endereço com valores dos campos
            const streetField = document.getElementById('street');
            const neighborhoodField = document.getElementById('neighborhood');
            const cityField = document.getElementById('city');
            
            if (streetField) {
                window.orderData.address.street = streetField.value;
            }
            if (neighborhoodField) {
                window.orderData.address.neighborhood = neighborhoodField.value;
            }
            if (cityField) {
                window.orderData.address.city = cityField.value;
            }
            
            debugLog('Dados do endereço atualizados:', window.orderData.address);
        }
        
        // Variável para controlar o timeout de busca do bairro no modo CEP
        let cepNeighborhoodSearchTimeout = null;
        
        /**
         * Manipula mudanças no campo de bairro para recalcular taxa de delivery
         * Versão aprimorada com debounce e busca direta na planilha
         */
        function handleNeighborhoodChange() {
            const neighborhoodField = document.getElementById('neighborhood');
            if (!neighborhoodField || !window.orderData || !window.orderData.address) {
                return;
            }
            
            const neighborhood = neighborhoodField.value.trim();
            
            // Atualizar dados do endereço
            window.orderData.address.neighborhood = neighborhood;
            
            // Limpar timeout anterior se existir
            if (cepNeighborhoodSearchTimeout) {
                clearTimeout(cepNeighborhoodSearchTimeout);
            }
            
            // Se estiver vazio, limpar taxa
            if (!neighborhood || neighborhood.length < 2) {
                clearDeliveryFee();
                if (window.orderData.address) {
                    delete window.orderData.address.deliveryFee;
                }
                updateCheckoutOrderTotal();
                
                // 🔒 Atualizar estado do botão continuar para bairro vazio
                const config = getCheckoutConfig();
                if (config.only_bairro_mode === 'Sim') {
                    updateContinueButtonState(false, '');
                }
                return;
            }
            
            // Aguardar 500ms após o usuário parar de digitar antes de buscar
            cepNeighborhoodSearchTimeout = setTimeout(() => {
                searchNeighborhoodFeeForCEPMode(neighborhood);
                
                // 🔒 Atualizar estado do botão continuar baseado na validação do bairro
                const isValid = validateNeighborhoodForDelivery(neighborhood);
                updateContinueButtonState(isValid, neighborhood);
            }, 500);
        }
        
        /**
         * Busca taxa de delivery por bairro no modo CEP
         * @param {string} neighborhood - Nome do bairro a ser pesquisado
         */
        function searchNeighborhoodFeeForCEPMode(neighborhood) {
            debugLog('=== BUSCANDO TAXA POR BAIRRO (MODO CEP) ===');
            debugLog('Bairro pesquisado:', neighborhood);
            
            // Verificar se dados estão disponíveis
            if (!window.neighborhoodsData || window.neighborhoodsData.length === 0) {
                debugLog('Dados de bairros não disponíveis, tentando usar dados locais');
                
                // Fallback para dados locais
                if (typeof neighborhoodsData !== 'undefined' && neighborhoodsData.length > 0) {
                    window.neighborhoodsData = neighborhoodsData;
                    debugLog('Dados locais copiados para global:', neighborhoodsData.length, 'registros');
                } else {
                    debugLog('Nenhum dado de bairro disponível');
                    displayDeliveryFee(null, neighborhood);
                    return;
                }
            }
            
            // Normalizar bairro para busca
            const normalizedNeighborhood = neighborhood.toLowerCase().trim();
            
            // 🔒 BUSCA EXATA APENAS - NÃO MAIS BUSCA PARCIAL
            let result = window.neighborhoodsData.find(item => {
                const itemBairro = (item.bairro || '').toLowerCase().trim();
                return itemBairro === normalizedNeighborhood;
            });
            
            debugLog('Busca exata por bairro:', { buscado: normalizedNeighborhood, encontrado: result });
            
            debugLog('Resultado da busca:', result);
            
            if (result && result.taxa) {
                const fee = parseFloat(result.taxa);
                
                if (!isNaN(fee) && fee > 0) {
                    debugLog('✅ Taxa válida encontrada:', fee);
                    
                    // Definir taxa global
                    currentDeliveryFee = fee;
                    
                    // Definir taxa no orderData
                    if (window.orderData && window.orderData.address) {
                        window.orderData.address.deliveryFee = fee;
                    }
                    
                    // Exibir taxa
                    displayDeliveryFee(fee, neighborhood);
                    
                    // Atualizar total do checkout
                    updateCheckoutOrderTotal();
                    return;
                }
            }
            
            debugLog('❌ Taxa não encontrada para o bairro:', neighborhood);
            // Taxa não encontrada - mostrar alerta para consultar
            displayDeliveryFee(null, neighborhood);
            
            // Limpar taxa nos dados do pedido
            if (window.orderData && window.orderData.address) {
                delete window.orderData.address.deliveryFee;
            }
            
            // Atualizar total do checkout (sem taxa)
            updateCheckoutOrderTotal();
        }

        // ====================================================================
        // SISTEMA REDUNDANTE DE BUSCA DE TAXA POR BAIRRO - V1.0
        // ====================================================================
        
        // Variáveis globais para controlar a busca de bairro
        let bairroSearchTimeout = null;
        let lastSearchedTerm = null; // Cache do último termo buscado
        let neighborhoodsList = []; // Lista de bairros para autocomplete
        let autocompleteContainer = null; // Container do autocomplete
        let spinnerTimeout = null; // Timeout para parar spinner automaticamente
        let lastInputValue = ''; // Último valor do input para detectar mudanças
        
        /**
         * Prepara lista de bairros para autocomplete (chamada durante preloader)
         */
        function prepareNeighborhoodsAutocomplete() {
            debugLog('📋 Preparando lista de bairros para autocomplete...');
            
            // Obter dados de bairros de qualquer fonte disponível
            let dadosBairros = null;
            
            if (window.neighborhoodsData && Array.isArray(window.neighborhoodsData) && window.neighborhoodsData.length > 0) {
                dadosBairros = window.neighborhoodsData;
            } else if (typeof neighborhoodsData !== 'undefined' && Array.isArray(neighborhoodsData) && neighborhoodsData.length > 0) {
                dadosBairros = neighborhoodsData;
            } else if (window.localNeighborhoodsData && Array.isArray(window.localNeighborhoodsData) && window.localNeighborhoodsData.length > 0) {
                dadosBairros = window.localNeighborhoodsData;
            }
            
            if (!dadosBairros || dadosBairros.length === 0) {
                debugLog('⚠️ Nenhum dado de bairro disponível para autocomplete');
                return;
            }
            
            // Extrair lista única de nomes de bairros
            neighborhoodsList = dadosBairros
                .map(item => {
                    const nome = item.bairro || item.neighborhood || '';
                    const taxa = parseFloat(item.taxa || item.fee || 0);
                    return {
                        nome: nome.trim(),
                        taxa: taxa,
                        normalizado: normalizarTexto(nome.toLowerCase())
                    };
                })
                .filter(item => item.nome && item.nome.length > 0)
                .sort((a, b) => a.nome.localeCompare(b.nome)); // Ordenar alfabeticamente
            
            // Remover duplicatas
            const nomesUnicos = new Set();
            neighborhoodsList = neighborhoodsList.filter(item => {
                if (nomesUnicos.has(item.normalizado)) {
                    return false;
                }
                nomesUnicos.add(item.normalizado);
                return true;
            });
            
            debugLog(`✅ Lista de autocomplete preparada: ${neighborhoodsList.length} bairros`);
            debugLog('📋 Primeiros 5 bairros:', neighborhoodsList.slice(0, 5).map(b => b.nome));
            
            // ====================================================================
            // 🏘️ FUNÇÃO V4.1.4: GERAR SELECT DE BAIRROS PARA MODO RESTRITO
            // ====================================================================
            // Preparar select de bairros quando only_bairro_mode = Sim
            window.neighborhoodsSelectOptions = neighborhoodsList
                .map(item => `<option value="${item.nome}">${item.nome.charAt(0).toUpperCase() + item.nome.slice(1)}</option>`)
                .join('');
            
            debugLog('🏘️ Select de bairros preparado para modo restrito');
            
            // Adicionar evento global para esconder autocomplete ao clicar fora
            if (!window.autocompleteEventAdded) {
                document.addEventListener('click', function(e) {
                    const field = document.getElementById('neighborhood');
                    const container = document.getElementById('neighborhood-autocomplete');
                    
                    if (field && container && 
                        !field.contains(e.target) && 
                        !container.contains(e.target)) {
                        hideNeighborhoodAutocomplete();
                    }
                });
                window.autocompleteEventAdded = true;
            }
        }
        
        /**
         * Verifica se o valor do input mudou e para o spinner se necessário
         */
        function checkInputChangeAndStopSpinner() {
            const field = document.getElementById('neighborhood');
            if (!field) return;
            
            const currentValue = field.value;
            
            // Se o valor não mudou e o spinner está ativo, pará-lo
            if (currentValue === lastInputValue && field.classList.contains('neighborhood-loading')) {
                debugLog('🚫 Valor do input não mudou, parando spinner por inatividade');
                hideNeighborhoodSpinner();
            }
        }
        
        /**
         * Função REDUNDANTE para buscar taxa de entrega por bairro
         * Implementa debounce e busca mais precisa por termo completo
         */
        function buscarTaxaPorBairroRedundante(bairroDigitado, forceImmediate = false) {
            debugLog('🔍 === BUSCA REDUNDANTE DE TAXA POR BAIRRO === 🔍');
            debugLog('🏠 Bairro digitado:', bairroDigitado);
            debugLog('⚡ Busca imediata:', forceImmediate);
            
            // Limpar timeout anterior
            if (bairroSearchTimeout) {
                clearTimeout(bairroSearchTimeout);
                bairroSearchTimeout = null;
            }
            
            // Validação de entrada
            if (!bairroDigitado || typeof bairroDigitado !== 'string' || bairroDigitado.trim().length < 3) {
                debugLog('⚠️ Bairro inválido ou muito curto (mínimo 3 caracteres)');
                
                // Limpar spinner se campo inválido
                hideNeighborhoodSpinner();
                
                // Mostrar autocomplete mesmo para termos curtos (≥2 caracteres)
                if (bairroDigitado && bairroDigitado.trim().length >= 2) {
                    showNeighborhoodAutocomplete(bairroDigitado.trim());
                } else {
                    hideNeighborhoodAutocomplete();
                }
                
                limparTaxaDeEntrega();
                return;
            }
            
            const bairro = bairroDigitado.trim();
            
            // Verificar se já buscamos este termo recentemente (evitar buscas repetidas)
            if (!forceImmediate && lastSearchedTerm === bairro.toLowerCase()) {
                debugLog('💾 Cache: Termo já buscado recentemente, pulando busca:', bairro);
                
                // Mesmo com cache, mostrar autocomplete se disponível
                if (bairro.length >= 2) {
                    showNeighborhoodAutocomplete(bairro);
                }
                return;
            }
            
            // Se não for busca forçada, mostrar autocomplete e implementar debounce
            if (!forceImmediate) {
                debugLog('⏱️ Mostrando autocomplete e implementando debounce de 800ms...');
                
                // Mostrar autocomplete imediatamente
                showNeighborhoodAutocomplete(bairro);
                
                // Mostrar spinner no campo
                showNeighborhoodSpinner();
                
                bairroSearchTimeout = setTimeout(() => {
                    debugLog('🚀 Executando busca após debounce...');
                    executarBuscaBairro(bairro);
                }, 800);
                return;
            }
            
            // Busca imediata
            executarBuscaBairro(bairro);
        }
        
        /**
         * Mostra spinner no campo de bairro com timeout automático
         */
        function showNeighborhoodSpinner() {
            const field = document.getElementById('neighborhood');
            if (!field) return;
            
            // Limpar timeout anterior se existir
            if (spinnerTimeout) {
                clearTimeout(spinnerTimeout);
            }
            
            // Adicionar classe de loading
            field.classList.add('neighborhood-loading');
            field.style.backgroundImage = 'url("data:image/svg+xml,%3Csvg xmlns=\'http://www.w3.org/2000/svg\' width=\'20\' height=\'20\' viewBox=\'0 0 24 24\'%3E%3Cpath fill=\'%23666\' d=\'M12,1A11,11,0,1,0,23,12,11,11,0,0,0,12,1Zm0,19a8,8,0,1,1,8-8A8,8,0,0,1,12,20Z\' opacity=\'.25\'/%3E%3Cpath fill=\'%23666\' d=\'M12,4a8,8,0,0,1,7.89,6.7A1.53,1.53,0,0,0,21.38,12h0a1.5,1.5,0,0,0,1.48-1.75,11,11,0,0,0-21.72,0A1.5,1.5,0,0,0,2.62,12h0a1.53,1.53,0,0,0,1.49-1.3A8,8,0,0,1,12,4Z\'%3E%3CanimateTransform attributeName=\'transform\' dur=\'0.75s\' repeatCount=\'indefinite\' type=\'rotate\' values=\'0 12 12;360 12 12\'/%3E%3C/path%3E%3C/svg%3E")';
            field.style.backgroundRepeat = 'no-repeat';
            field.style.backgroundPosition = 'right 10px center';
            field.style.backgroundSize = '16px 16px';
            field.style.paddingRight = '35px';
            
            // Armazenar valor atual do input
            lastInputValue = field.value;
            
            // Configurar timeout para parar spinner automaticamente após 5 segundos
            spinnerTimeout = setTimeout(() => {
                debugLog('⏰ Timeout: Parando spinner automaticamente após 5 segundos');
                hideNeighborhoodSpinner();
            }, 5000);
            
            // Configurar verificação intermediária a cada 2 segundos
            setTimeout(() => {
                checkInputChangeAndStopSpinner();
            }, 2000);
            
            debugLog('🔄 Spinner ativado no campo de bairro (timeout: 5s)');
        }
        
        /**
         * Remove spinner do campo de bairro
         */
        function hideNeighborhoodSpinner() {
            const field = document.getElementById('neighborhood');
            if (!field) return;
            
            // Limpar timeout se existir
            if (spinnerTimeout) {
                clearTimeout(spinnerTimeout);
                spinnerTimeout = null;
            }
            
            // Remover classe e estilos de loading
            field.classList.remove('neighborhood-loading');
            field.style.backgroundImage = '';
            field.style.backgroundRepeat = '';
            field.style.backgroundPosition = '';
            field.style.backgroundSize = '';
            field.style.paddingRight = '';
            
            debugLog('✅ Spinner removido do campo de bairro');
        }
        
        /**
         * Mostra autocomplete de bairros
         */
        function showNeighborhoodAutocomplete(termo) {
            if (!termo || termo.length < 2 || neighborhoodsList.length === 0) {
                hideNeighborhoodAutocomplete();
                return;
            }
            
            const field = document.getElementById('neighborhood');
            if (!field) return;
            
            // Filtrar bairros que correspondem ao termo
            const termoNormalizado = normalizarTexto(termo.toLowerCase());
            const sugestoes = neighborhoodsList
                .filter(bairro => bairro.normalizado.includes(termoNormalizado))
                .slice(0, 8); // Limitar a 8 sugestões
            
            if (sugestoes.length === 0) {
                hideNeighborhoodAutocomplete();
                return;
            }
            
            // Criar container se não existir
            if (!autocompleteContainer) {
                autocompleteContainer = document.createElement('div');
                autocompleteContainer.id = 'neighborhood-autocomplete';
                autocompleteContainer.style.cssText = `
                    position: absolute;
                    top: 100%;
                    left: 0;
                    right: 0;
                    background: white;
                    border: 1px solid #d1d5db;
                    border-top: none;
                    border-radius: 0 0 8px 8px;
                    box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
                    max-height: 200px;
                    overflow-y: auto;
                    z-index: 99999;
                    display: none;
                `;
                
                // Inserir após o campo
                field.parentNode.style.position = 'relative';
                field.parentNode.style.overflow = 'visible';
                
                // Garantir que o modal também tenha overflow visible
                const modal = field.closest('.modal-content, [id*="modal"], .fixed');
                if (modal) {
                    modal.style.overflow = 'visible';
                }
                
                field.parentNode.appendChild(autocompleteContainer);
            }
            
            // Gerar HTML das sugestões
            let html = '';
            sugestoes.forEach((bairro, index) => {
                const taxaFormatada = bairro.taxa > 0 ? `R$ ${bairro.taxa.toFixed(2)}` : 'Grátis';
                html += `
                    <div class="autocomplete-item" 
                         data-neighborhood="${bairro.nome}" 
                         data-taxa="${bairro.taxa}"
                         style="
                             padding: 10px 12px;
                             cursor: pointer;
                             border-bottom: 1px solid #f3f4f6;
                             display: flex;
                             justify-content: space-between;
                             align-items: center;
                             transition: background-color 0.2s;
                         "
                         onmouseover="this.style.backgroundColor='#f9fafb'"
                         onmouseout="this.style.backgroundColor='white'"
                         onclick="selectNeighborhoodFromAutocomplete('${bairro.nome}', ${bairro.taxa})">
                        <span style="font-weight: 500; color: #374151;">${bairro.nome}</span>
                        <span style="font-size: 12px; color: #6b7280; font-weight: 600;">${taxaFormatada}</span>
                    </div>
                `;
            });
            
            autocompleteContainer.innerHTML = html;
            autocompleteContainer.style.display = 'block';
            
            debugLog(`📝 Autocomplete exibido: ${sugestoes.length} sugestões para "${termo}"`);
        }
        
        /**
         * Esconde autocomplete de bairros
         */
        function hideNeighborhoodAutocomplete() {
            if (autocompleteContainer) {
                autocompleteContainer.style.display = 'none';
            }
        }
        
        /**
         * Reseta o estado do sistema de busca (limpa cache e spinner)
         */
        function resetNeighborhoodSearchState() {
            // Limpar timeout de busca se existir
            if (bairroSearchTimeout) {
                clearTimeout(bairroSearchTimeout);
                bairroSearchTimeout = null;
            }
            
            // Limpar timeout do spinner se existir
            if (spinnerTimeout) {
                clearTimeout(spinnerTimeout);
                spinnerTimeout = null;
            }
            
            // Limpar cache
            lastSearchedTerm = null;
            lastInputValue = '';
            
            // Remover spinner
            hideNeighborhoodSpinner();
            
            debugLog('🔄 Estado da busca de bairro resetado');
        }
        
        /**
         * Seleciona bairro do autocomplete
         */
        function selectNeighborhoodFromAutocomplete(nome, taxa) {
            const field = document.getElementById('neighborhood');
            if (!field) return;
            
            // Preencher campo
            field.value = nome;
            
            // Esconder autocomplete
            hideNeighborhoodAutocomplete();
            
            // Aplicar taxa imediatamente
            debugLog(`🎯 Bairro selecionado do autocomplete: ${nome} (Taxa: R$ ${taxa})`);
            aplicarTaxaEncontrada(taxa, nome);
            
            // Atualizar dados do endereço
            updateAddressData();
            
            // Limpar campo de erro se existir
            clearFieldError('neighborhood');
        }
        
        /**
         * Executa a busca real do bairro na planilha
         */
        function executarBuscaBairro(bairro) {
            debugLog('🔍 Executando busca para:', bairro);
            debugLog('📋 Bairro processado:', bairro);
            
            // Atualizar cache do termo buscado
            lastSearchedTerm = bairro.toLowerCase();
            
            // Verificar se temos dados disponíveis (múltiplas fontes)
            let dadosBairros = null;
            
            // Fonte 1: window.neighborhoodsData
            if (window.neighborhoodsData && Array.isArray(window.neighborhoodsData) && window.neighborhoodsData.length > 0) {
                dadosBairros = window.neighborhoodsData;
                debugLog('✅ Usando window.neighborhoodsData:', dadosBairros.length, 'registros');
            }
            // Fonte 2: neighborhoodsData global
            else if (typeof neighborhoodsData !== 'undefined' && Array.isArray(neighborhoodsData) && neighborhoodsData.length > 0) {
                dadosBairros = neighborhoodsData;
                window.neighborhoodsData = neighborhoodsData; // Copiar para window
                debugLog('✅ Usando neighborhoodsData global:', dadosBairros.length, 'registros');
            }
            // Fonte 3: localNeighborhoodsData
            else if (window.localNeighborhoodsData && Array.isArray(window.localNeighborhoodsData) && window.localNeighborhoodsData.length > 0) {
                dadosBairros = window.localNeighborhoodsData;
                debugLog('✅ Usando window.localNeighborhoodsData:', dadosBairros.length, 'registros');
            }
            else {
                errorLog('Nenhum dado de bairro disponível!');
                exibirAlertaTaxaNaoEncontrada(bairro);
                
                // Remover spinner sempre
                hideNeighborhoodSpinner();
                return;
            }
            
            // Normalizar bairro para busca (remover acentos, maiúsculas, etc.)
            const bairroNormalizado = normalizarTexto(bairro.toLowerCase());
            debugLog('🔄 Bairro normalizado:', bairroNormalizado);
            
            // BUSCA NIVEL 1: Busca exata (prioritária)
            debugLog('🎯 Tentando busca EXATA...');
            let resultado = dadosBairros.find(item => {
                const itemBairro = normalizarTexto((item.bairro || item.neighborhood || '').toLowerCase());
                return itemBairro === bairroNormalizado;
            });
            
            // BUSCA NIVEL 2: Busca exata sem normalização (caso especial)
            if (!resultado) {
                debugLog('🎯 Tentando busca EXATA sem normalização...');
                resultado = dadosBairros.find(item => {
                    const itemBairro = (item.bairro || item.neighborhood || '').toLowerCase().trim();
                    return itemBairro === bairro.toLowerCase().trim();
                });
            }
            
            // BUSCA NIVEL 3: Busca parcial muito restritiva (apenas se o termo for muito similar)
            if (!resultado && bairro.length >= 5) {
                debugLog('🎯 Tentando busca PARCIAL restritiva...');
                resultado = dadosBairros.find(item => {
                    const itemBairro = normalizarTexto((item.bairro || item.neighborhood || '').toLowerCase());
                    // Apenas se o bairro digitado está contido no bairro da planilha E tem pelo menos 80% de similaridade
                    const similarity = calculateSimilarity(bairroNormalizado, itemBairro);
                    return (itemBairro.includes(bairroNormalizado) && similarity >= 0.8) || 
                           (bairroNormalizado.includes(itemBairro) && similarity >= 0.8);
                });
                
                if (resultado) {
                    debugLog('✅ Encontrado por busca parcial restritiva');
                }
            }
            
            // Processar resultado
            if (resultado) {
                const taxa = parseFloat(resultado.taxa || resultado.fee || 0);
                
                if (!isNaN(taxa) && taxa > 0) {
                    debugLog('✅ TAXA ENCONTRADA!', {
                        bairroOriginal: bairro,
                        bairroEncontrado: resultado.bairro || resultado.neighborhood,
                        taxa: taxa
                    });
                    
                    aplicarTaxaEncontrada(taxa, bairro);
                    
                    // Remover spinner após sucesso
                    hideNeighborhoodSpinner();
                    return;
                } else {
                    errorLog('⚠️ Taxa inválida encontrada:', resultado.taxa || resultado.fee);
                }
            }
            
            // Se chegou até aqui, não encontrou
            debugLog('❌ Taxa não encontrada para o bairro:', bairro);
            exibirAlertaTaxaNaoEncontrada(bairro);
            
            // Limpar cache para permitir novas buscas
            lastSearchedTerm = null;
            
            // Remover spinner sempre ao final
            hideNeighborhoodSpinner();
        }
        
        /**
         * Calcula a similaridade entre duas strings usando algoritmo de Levenshtein
         */
        function calculateSimilarity(str1, str2) {
            if (!str1 || !str2) return 0;
            if (str1 === str2) return 1;
            
            const len1 = str1.length;
            const len2 = str2.length;
            
            // Matriz para algoritmo de Levenshtein
            const matrix = Array(len2 + 1).fill(null).map(() => Array(len1 + 1).fill(null));
            
            for (let i = 0; i <= len1; i++) matrix[0][i] = i;
            for (let j = 0; j <= len2; j++) matrix[j][0] = j;
            
            for (let j = 1; j <= len2; j++) {
                for (let i = 1; i <= len1; i++) {
                    const cost = str1[i - 1] === str2[j - 1] ? 0 : 1;
                    matrix[j][i] = Math.min(
                        matrix[j - 1][i] + 1,     // deletion
                        matrix[j][i - 1] + 1,     // insertion
                        matrix[j - 1][i - 1] + cost // substitution
                    );
                }
            }
            
            const distance = matrix[len2][len1];
            return 1 - distance / Math.max(len1, len2);
        }
        
        // ====================================================================
        // 🏘️ FUNÇÃO V4.1.4: GERAR SELECT DE BAIRROS
        // ====================================================================
        /**
         * Gera select de bairros quando only_bairro_mode = Sim
         */
        function generateNeighborhoodSelect(fieldId, onChangeCallback) {
            const config = getCheckoutConfig();
            
            // Se modo restrito não está ativo, retorna input normal
            if (config.only_bairro_mode !== 'Sim') {
                return null; // Indica que deve usar input normal
            }
            
            // Verificar se dados estão disponíveis
            if (!window.neighborhoodsSelectOptions) {
                return `<select id="${fieldId}" class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-red-500 focus:border-transparent" disabled>
                    <option value="">Carregando bairros...</option>
                </select>`;
            }
            
            return `<select id='${fieldId}' class='w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-red-500 focus:border-transparent' onchange='${onChangeCallback}' value=''>
                <option value="" selected>Selecione o bairro</option>
                ${window.neighborhoodsSelectOptions}
            </select>`;
        }
        
        /**
         * Handler para select de bairro
         */
        function handleNeighborhoodSelect(selectedBairro, fieldId) {
            
            debugLog('🏘️ Bairro selecionado via SELECT:', selectedBairro, 'no campo:', fieldId);
            
            if (selectedBairro) {
                // Buscar taxa automaticamente
                performNeighborhoodSearch(selectedBairro);
                
                // Atualizar dados do endereço baseado no campo
                if (fieldId === 'neighborhood') {
                    updateAddressData();
                } else {
                    updateManualAddressData();
                }
                
                // Limpar erros
                clearFieldError(fieldId);
                
                // Atualizar botão continuar
                updateContinueButton();
            } else {
                // Campo vazio - limpar taxa
                clearDeliveryFee();
                updateContinueButton();
            }
        }
        
        /**
         * Renderiza campos de bairro dinamicamente baseado em only_bairro_mode
         */
        function renderNeighborhoodFields() {
            const config = getCheckoutConfig();
            
            // ====================================================================
            // 🏘️ PRESERVAÇÃO V4.1.4: CAPTURAR VALORES ATUAIS ANTES DE RENDERIZAR
            // ====================================================================
            // Capturar valores atuais dos campos para preservar seleção
            const currentNeighborhoodValue = document.getElementById('neighborhood')?.value || '';
            const currentManualNeighborhoodValue = document.getElementById('manual-neighborhood')?.value || '';
            
            // Também verificar orderData como fonte de verdade
            const orderDataNeighborhood = window.orderData?.address?.neighborhood || '';
            
            // Esconder qualquer autocomplete ativo para evitar conflitos
            hideNeighborhoodAutocomplete();
            
            // Renderizar campo do modo CEP
            const neighborhoodContainer = document.getElementById('neighborhood-field-container');
            if (neighborhoodContainer) {
                const neighborhoodSelect = generateNeighborhoodSelect('neighborhood', 'handleNeighborhoodSelect(this.value, "neighborhood")');
                
                if (neighborhoodSelect) {
                    // Modo restrito - usar select
                    neighborhoodContainer.innerHTML = neighborhoodSelect;
                    debugLog('🏘️ Campo de bairro (CEP) renderizado como SELECT (modo restrito)');
                    
                    // ====================================================================
                    // 🏘️ RESTAURAÇÃO V4.1.4: PRESERVAR VALOR SELECIONADO
                    // ====================================================================
                    setTimeout(() => {
                        const selectElement = document.getElementById('neighborhood');
                        if (selectElement) {
                            // Tentar restaurar valor anterior (prioridade: campo atual > orderData)
                            const valueToRestore = currentNeighborhoodValue || orderDataNeighborhood;
                            
                            if (valueToRestore) {
                                // Procurar opção correspondente no select
                                const options = selectElement.options;
                                let optionFound = false;
                                
                                for (let i = 0; i < options.length; i++) {
                                    if (options[i].value.toLowerCase() === valueToRestore.toLowerCase()) {
                                        selectElement.selectedIndex = i;
                                        optionFound = true;
                                        debugLog('🏘️ Valor do bairro restaurado:', valueToRestore);
                                        break;
                                    }
                                }
                                
                                if (!optionFound) {
                                    selectElement.selectedIndex = 0; // Fallback para placeholder
                                    debugLog('🏘️ Valor anterior não encontrado no select, usando placeholder');
                                }
                            } else {
                                selectElement.selectedIndex = 0; // Placeholder padrão
                            }
                        }
                    }, 50);
                } else {
                    // Modo normal - usar input
                    neighborhoodContainer.innerHTML = `<input type="text" id="neighborhood" class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-red-500 focus:border-transparent" placeholder="Nome do bairro" autocomplete="off" oninput="updateAddressData(); clearFieldError('neighborhood'); if(this.value.trim() === '') resetNeighborhoodSearchState(); buscarTaxaPorBairroRedundante(this.value);" onchange="buscarTaxaPorBairroRedundante(this.value, true); hideNeighborhoodAutocomplete();" onblur="setTimeout(() => { buscarTaxaPorBairroRedundante(this.value, true); hideNeighborhoodAutocomplete(); }, 200);" onpaste="setTimeout(() => buscarTaxaPorBairroRedundante(this.value, true), 200);" onfocus="if(this.value.length >= 2) showNeighborhoodAutocomplete(this.value);">`;
                    debugLog('🏘️ Campo de bairro (CEP) renderizado como INPUT (modo normal)');
                    
                    // Restaurar valor no input
                    setTimeout(() => {
                        const inputElement = document.getElementById('neighborhood');
                        if (inputElement) {
                            const valueToRestore = currentNeighborhoodValue || orderDataNeighborhood;
                            if (valueToRestore) {
                                inputElement.value = valueToRestore;
                                debugLog('🏘️ Valor do input restaurado:', valueToRestore);
                            }
                        }
                    }, 50);
                }
            }
            
            // Renderizar campo do modo manual
            const manualNeighborhoodContainer = document.getElementById('manual-neighborhood-field-container');
            if (manualNeighborhoodContainer) {
                const manualNeighborhoodSelect = generateNeighborhoodSelect('manual-neighborhood', 'handleNeighborhoodSelect(this.value, "manual-neighborhood")');
                
                if (manualNeighborhoodSelect) {
                    // Modo restrito - usar select
                    manualNeighborhoodContainer.innerHTML = manualNeighborhoodSelect;
                    debugLog('🏘️ Campo de bairro (Manual) renderizado como SELECT (modo restrito)');
                    
                    // Restaurar valor no select manual
                    setTimeout(() => {
                        const selectElement = document.getElementById('manual-neighborhood');
                        if (selectElement) {
                            const valueToRestore = currentManualNeighborhoodValue || orderDataNeighborhood;
                            
                            if (valueToRestore) {
                                const options = selectElement.options;
                                let optionFound = false;
                                
                                for (let i = 0; i < options.length; i++) {
                                    if (options[i].value.toLowerCase() === valueToRestore.toLowerCase()) {
                                        selectElement.selectedIndex = i;
                                        optionFound = true;
                                        debugLog('🏘️ Valor do bairro manual restaurado:', valueToRestore);
                                        break;
                                    }
                                }
                                
                                if (!optionFound) {
                                    selectElement.selectedIndex = 0;
                                }
                            } else {
                                selectElement.selectedIndex = 0;
                            }
                        }
                    }, 50);
                } else {
                    // Modo normal - usar input
                    manualNeighborhoodContainer.innerHTML = `<input type="text" id="manual-neighborhood" class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-red-500 focus:border-transparent" placeholder="Centro" autocomplete="off" oninput="updateManualAddressData(); searchNeighborhoodFee(); clearFieldError('manual-neighborhood');" onchange="updateContinueButton();" onblur="updateContinueButton();">`;
                    debugLog('🏘️ Campo de bairro (Manual) renderizado como INPUT (modo normal)');
                    
                    // Restaurar valor no input manual
                    setTimeout(() => {
                        const inputElement = document.getElementById('manual-neighborhood');
                        if (inputElement) {
                            const valueToRestore = currentManualNeighborhoodValue || orderDataNeighborhood;
                            if (valueToRestore) {
                                inputElement.value = valueToRestore;
                                debugLog('🏘️ Valor do input manual restaurado:', valueToRestore);
                            }
                        }
                    }, 50);
                }
            }
        }
        
        /**
         * Função para normalizar texto (remover acentos, caracteres especiais)
         */
        function normalizarTexto(texto) {
            if (!texto) return '';
            
            return texto
                .normalize('NFD')
                .replace(/[\u0300-\u036f]/g, '') // Remove acentos
                .replace(/[^a-z0-9\s]/g, '') // Remove caracteres especiais
                .replace(/\s+/g, ' ') // Normaliza espaços
                .trim();
        }
        
        /**
         * Função para aplicar taxa encontrada
         */
        function aplicarTaxaEncontrada(taxa, bairro) {
            debugLog('✅ Aplicando taxa encontrada:', taxa);
            
            // Definir taxa global
            window.currentDeliveryFee = taxa;
            
            // Atualizar orderData
            if (window.orderData && window.orderData.address) {
                window.orderData.address.deliveryFee = taxa;
                debugLog('✅ Taxa atualizada em orderData.address');
            }
            
            // Exibir taxa na interface
            displayDeliveryFee(taxa, bairro);
            
            // Atualizar total do pedido
            updateCheckoutOrderTotal();
            
            // Efeito visual no campo
            const campo = document.getElementById('neighborhood');
            if (campo) {
                campo.style.backgroundColor = '#dcfce7'; // Verde claro
                setTimeout(() => {
                    campo.style.backgroundColor = '';
                }, 1000);
            }
        }
        
        /**
         * Função para exibir alerta quando taxa não é encontrada
         */
        function exibirAlertaTaxaNaoEncontrada(bairro) {
            debugLog('⚠️ Exibindo alerta de taxa não encontrada');
            
            // Limpar taxa
            limparTaxaDeEntrega();
            
            // Exibir alerta
            displayDeliveryFee(null, bairro);
            
            // Efeito visual no campo
            const campo = document.getElementById('neighborhood');
            if (campo) {
                campo.style.backgroundColor = '#fef2f2'; // Vermelho claro
                setTimeout(() => {
                    campo.style.backgroundColor = '';
                }, 1000);
            }
        }
        
        /**
         * Função para limpar taxa de entrega
         */
        function limparTaxaDeEntrega() {
            debugLog('🧹 Limpando taxa de entrega');
            
            // Limpar variável global
            window.currentDeliveryFee = null;
            
            // Limpar orderData
            if (window.orderData && window.orderData.address) {
                delete window.orderData.address.deliveryFee;
            }
            
            // Remover alerta da interface
            const alerta = document.getElementById('delivery-fee-alert');
            if (alerta) {
                alerta.remove();
            }
            
            // Atualizar total do pedido
            updateCheckoutOrderTotal();
        }
        
        /**
         * Função REDUNDANTE de monitoramento do campo de bairro
         * Esta função garante que SEMPRE que o usuário digitar, a busca será executada
         * AGORA: Só executa quando o campo realmente existe (checkout aberto)
         */
        function iniciarMonitoramentoRedundanteBairro() {
            debugLog('🔄 Iniciando monitoramento REDUNDANTE do campo de bairro');
            
            const campo = document.getElementById('neighborhood');
            if (!campo) {
                debugLog('⚠️ Campo de bairro não encontrado - checkout não está aberto');
                return; // NÃO tentar novamente automaticamente
            }
            
            debugLog('✅ Campo de bairro encontrado, configurando eventos...');
            
            // Variável para debounce
            let timeoutBusca = null;
            
            // Função de busca com debounce INTELIGENTE
            function executarBuscaComDebounce() {
                const valor = campo.value.trim();
                
                // Cancelar busca anterior
                if (timeoutBusca) {
                    clearTimeout(timeoutBusca);
                }
                
                // Se vazio ou muito curto, limpar
                if (!valor || valor.length < 3) {
                    if (valor.length === 0) {
                        limparTaxaDeEntrega();
                    }
                    return;
                }
                
                // Mostrar indicador visual de que está digitando
                campo.style.backgroundColor = '#f0f9ff'; // Azul muito claro
                
                // Agendar nova busca com tempo maior para palavra completa
                timeoutBusca = setTimeout(() => {
                    debugLog('🚀 Executando busca para palavra completa:', valor);
                    
                    // Remover indicador visual
                    campo.style.backgroundColor = '';
                    
                    // Executar busca
                    buscarTaxaPorBairroRedundante(valor);
                }, 1200); // 1.2 segundos para garantir palavra completa
            }
            
            // Remover eventos anteriores
            campo.removeEventListener('input', executarBuscaComDebounce);
            campo.removeEventListener('change', executarBuscaComDebounce);
            campo.removeEventListener('blur', executarBuscaComDebounce);
            campo.removeEventListener('paste', executarBuscaComDebounce);
            
            // Adicionar apenas eventos que indicam fim da digitação
            campo.addEventListener('input', executarBuscaComDebounce); // Com debounce longo
            campo.addEventListener('change', function() {
                // Busca imediata quando sai do campo
                if (timeoutBusca) clearTimeout(timeoutBusca);
                const valor = campo.value.trim();
                if (valor.length >= 3) {
                    debugLog('🚀 Busca imediata por CHANGE:', valor);
                    buscarTaxaPorBairroRedundante(valor);
                }
            });
            campo.addEventListener('blur', function() {
                // Busca imediata quando perde o foco
                if (timeoutBusca) clearTimeout(timeoutBusca);
                const valor = campo.value.trim();
                if (valor.length >= 3) {
                    debugLog('🚀 Busca imediata por BLUR:', valor);
                    buscarTaxaPorBairroRedundante(valor);
                }
            });
            campo.addEventListener('paste', function() {
                // Busca após colar texto
                setTimeout(() => {
                    const valor = campo.value.trim();
                    if (valor.length >= 3) {
                        debugLog('🚀 Busca imediata por PASTE:', valor);
                        buscarTaxaPorBairroRedundante(valor);
                    }
                }, 200);
            });
            
            // Sobrescrever atributo oninput apenas para updateAddressData
            campo.setAttribute('oninput', 'updateAddressData();');
            
            debugLog('✅ Monitoramento redundante configurado com sucesso!');
            
            // Efeito visual para confirmar
            campo.style.border = '2px solid #10b981';
            setTimeout(() => {
                campo.style.border = '';
            }, 2000);
        }
        
        // REMOVIDO: Inicialização automática do monitoramento
        // Agora o monitoramento só é iniciado quando o checkout é aberto
        // document.addEventListener('DOMContentLoaded', function() {
        //     setTimeout(iniciarMonitoramentoRedundanteBairro, 2000);
        // });
        
        // Função de teste global
        window.testarBuscaBairro = function(bairro) {
            debugLog('🧪 Testando busca para:', bairro);
            buscarTaxaPorBairroRedundante(bairro || 'Centro');
        };
        
        // ====================================================================
        // SISTEMA MODO ENDEREÇO MANUAL - "NÃO SEI MEU CEP" - V3.5
        // ====================================================================

        // Variável para controlar timeout de busca por bairro
        let neighborhoodSearchTimeout = null;

        /**
         * Alterna entre modo CEP e modo endereço manual
         */
        function toggleAddressMode() {
            debugLog('=== ALTERNANDO MODO DE ENDEREÇO ===');
            
            const cepContainer = document.getElementById('cep-mode-container');
            const manualContainer = document.getElementById('manual-address-container');
            const addressFields = document.getElementById('address-fields');
            
            if (!cepContainer || !manualContainer) {
                errorLog('Containers de modo não encontrados');
                return;
            }
            
            // Limpar timeout de busca se existir
            if (neighborhoodSearchTimeout) {
                clearTimeout(neighborhoodSearchTimeout);
                neighborhoodSearchTimeout = null;
                debugLog('Timeout de busca limpo');
            }
            
            const isManualMode = !manualContainer.classList.contains('hidden');
            
            if (isManualMode) {
                // Mudando para modo CEP
                debugLog('Mudando para modo CEP');
                manualContainer.classList.add('hidden');
                cepContainer.classList.remove('hidden');
                
                // Limpar campos manuais
                clearManualAddressFields();
                
                // Ocultar campos de endereço automático
                if (addressFields) {
                    addressFields.classList.add('hidden');
                }
                
                // Foco no campo CEP
                setTimeout(() => {
                    const cepField = document.getElementById('cep');
                    if (cepField) {
                        cepField.focus();
                    }
                }, 100);
                
            } else {
                // Mudando para modo manual
                debugLog('Mudando para modo MANUAL');
                cepContainer.classList.add('hidden');
                manualContainer.classList.remove('hidden');
                
                // Limpar campos CEP
                clearAddressFields();
                
                // Foco no primeiro campo manual
                setTimeout(() => {
                    const streetField = document.getElementById('manual-street');
                    if (streetField) {
                        streetField.focus();
                    }
                }, 100);
            }
            
            // Limpar taxa de delivery ao alternar
            clearDeliveryFee();
            
            // Limpar dados do endereço
            if (window.orderData && window.orderData.address) {
                window.orderData.address = {};
            }
            
            // Atualizar botão continuar
            updateContinueButton();
            
            debugLog('Modo atual:', isManualMode ? 'CEP' : 'MANUAL');
        }

        /**
         * Atualiza os dados do endereço manual
         */
        function updateManualAddressData() {
            const streetField = document.getElementById('manual-street');
            const numberField = document.getElementById('manual-number');
            const complementField = document.getElementById('manual-complement');
            const neighborhoodField = document.getElementById('manual-neighborhood');
            const cityField = document.getElementById('manual-city');
            
            if (!streetField || !numberField || !neighborhoodField || !cityField) {
                return;
            }
            
            // Inicializar orderData.address se não existir (usar variável global consistente)
            if (!orderData) {
                orderData = {};
            }
            if (!orderData.address) {
                orderData.address = {};
            }
            
            // Preservar taxa de delivery existente
            const existingDeliveryFee = orderData.address.deliveryFee;
            
            // Construir endereço completo
            const street = streetField.value.trim();
            const number = numberField.value.trim();
            const complement = complementField.value.trim();
            const neighborhood = neighborhoodField.value.trim();
            const city = cityField.value.trim();
            
            // Montar endereço completo
            let fullAddress = street;
            if (number) fullAddress += `, ${number}`;
            if (complement) fullAddress += `, ${complement}`;
            
            // Atualizar dados do pedido
            orderData.address = {
                cep: '',
                street: fullAddress,
                neighborhood: neighborhood,
                city: city,
                state: '',
                isManual: true
            };
            
            // Restaurar taxa de delivery se existia
            if (existingDeliveryFee) {
                orderData.address.deliveryFee = existingDeliveryFee;
            }
            
            debugLog('DEBUG - Dados endereço manual atualizados:', orderData.address);
        }

        /**
         * Busca taxa de delivery por bairro no modo manual (com debounce)
         */
        function searchNeighborhoodFee() {
            const neighborhoodField = document.getElementById('manual-neighborhood');
            if (!neighborhoodField) return;
            
            const neighborhood = neighborhoodField.value.trim();
            
            // Limpar timeout anterior
            if (neighborhoodSearchTimeout) {
                clearTimeout(neighborhoodSearchTimeout);
            }
            
            // Se menos de 3 caracteres, limpar taxa
            if (neighborhood.length < 3) {
                clearDeliveryFee();
                
                // 🔒 Atualizar estado do botão continuar para bairro vazio
                const config = getCheckoutConfig();
                if (config.only_bairro_mode === 'Sim') {
                    updateContinueButtonState(false, '');
                }
                return;
            }
            
            // Aguardar 800ms após o usuário parar de digitar
            neighborhoodSearchTimeout = setTimeout(() => {
                performNeighborhoodSearch(neighborhood);
                
                // 🔒 Atualizar estado do botão continuar baseado na validação do bairro
                const isValid = validateNeighborhoodForDelivery(neighborhood);
                updateContinueButtonState(isValid, neighborhood);
            }, 800);
        }

        /**
         * Executa a busca real por bairro
         */
        function performNeighborhoodSearch(neighborhood) {
            debugLog('=== BUSCANDO TAXA POR BAIRRO (MANUAL) ===');
            debugLog('Bairro pesquisado:', neighborhood);
            debugLog('window.neighborhoodsData existe?', !!window.neighborhoodsData);
            debugLog('Quantidade de registros:', window.neighborhoodsData ? window.neighborhoodsData.length : 0);
            
            // Verificar se dados estão disponíveis
            if (!window.neighborhoodsData) {
                errorLog('ERRO: window.neighborhoodsData não definido!');
                // Fallback para dados locais
                if (typeof neighborhoodsData !== 'undefined' && neighborhoodsData.length > 0) {
                    window.neighborhoodsData = neighborhoodsData;
                    debugLog('Dados locais copiados para global:', neighborhoodsData.length, 'registros');
                }
            }
            
            if (!window.neighborhoodsData || window.neighborhoodsData.length === 0) {
                debugLog('Dados de bairros não disponíveis');
                displayDeliveryFee(null, neighborhood);
                return;
            }
            
            // Log dos primeiros registros para debug
            debugLog('Primeiros 3 registros:', window.neighborhoodsData.slice(0, 3));
            
            // Normalizar bairro para busca
            const normalizedNeighborhood = neighborhood.toLowerCase();
            debugLog('Bairro normalizado para busca:', normalizedNeighborhood);
            
            // Buscar na planilha
            const result = window.neighborhoodsData.find(item => {
                const itemBairro = (item.bairro || '').toLowerCase();
                debugLog('Comparando:', normalizedNeighborhood, '===', itemBairro);
                return itemBairro === normalizedNeighborhood;
            });
            
            debugLog('Resultado da busca:', result);
            
            if (result && result.taxa) {
                const fee = parseFloat(result.taxa);
                debugLog('Taxa encontrada (raw):', result.taxa);
                debugLog('Taxa parseada:', fee);
                
                if (!isNaN(fee) && fee > 0) {
                    debugLog('✅ Taxa válida encontrada:', fee);
                    
                    // CORREÇÃO: Definir taxa global (necessário para cálculo do total)
                    currentDeliveryFee = fee;
                    
                    // Definir taxa no orderData
                    if (orderData && orderData.address) {
                        orderData.address.deliveryFee = fee;
                        debugLog('Taxa de delivery definida com sucesso:', fee);
                    }
                    
                    // Exibir taxa
                    displayDeliveryFee(fee, neighborhood);
                    
                    // CORREÇÃO: Atualizar total do checkout
                    updateCheckoutOrderTotal();
                    
                    return;
                }
            }
            
            debugLog('❌ Taxa não encontrada para o bairro:', neighborhood);
            // Taxa não encontrada - mostrar alerta para consultar
            displayDeliveryFee(null, neighborhood);
        }

        /**
         * Limpa campos de endereço do modo CEP
         */
        function clearAddressFields() {
            const fields = ['cep', 'street', 'number', 'complement', 'neighborhood', 'city'];
            fields.forEach(fieldId => {
                const field = document.getElementById(fieldId);
                if (field) {
                    field.value = '';
                    clearFieldError(fieldId);
                }
            });
            
            // Ocultar campos de endereço
            const addressFields = document.getElementById('address-fields');
            if (addressFields) {
                addressFields.classList.add('hidden');
            }
        }

        /**
         * Limpa campos de endereço do modo manual
         */
        function clearManualAddressFields() {
            const fields = ['manual-street', 'manual-number', 'manual-complement', 'manual-neighborhood', 'manual-city'];
            fields.forEach(fieldId => {
                const field = document.getElementById(fieldId);
                if (field) {
                    field.value = '';
                    clearFieldError(fieldId);
                }
            });
        }

        // Show toast notification
        function showToast(message, type = 'error', duration = 4000) {
            // Remove existing toasts
            const existingToasts = document.querySelectorAll('.toast');
            existingToasts.forEach(toast => {
                toast.classList.add('toast-exit');
                setTimeout(() => toast.remove(), 300);
            });
            
            const icons = {
                error: '⚠️',
                success: '✅',
                warning: '⚠️',
                info: 'ℹ️'
            };
            
            const toastDiv = document.createElement('div');
            toastDiv.className = `toast toast-${type}`;
            toastDiv.innerHTML = `
                <div class="flex items-start space-x-3">
                    <span class="text-xl flex-shrink-0 mt-0.5">${icons[type]}</span>
                    <div class="flex-1">
                        <div class="font-semibold text-sm leading-tight">${message}</div>
                    </div>
                    <button onclick="this.parentElement.parentElement.classList.add('toast-exit'); setTimeout(() => this.parentElement.parentElement.remove(), 300)" class="text-white/80 hover:text-white ml-2 flex-shrink-0">
                        <span class="text-lg">×</span>
                    </button>
                </div>
            `;
            
            document.body.appendChild(toastDiv);
            
            // Auto remove
            setTimeout(() => {
                if (toastDiv.parentNode) {
                    toastDiv.classList.add('toast-exit');
                    setTimeout(() => toastDiv.remove(), 300);
                }
            }, duration);
        }
        
        // Show custom alert (legacy support)
        function showCustomAlert(message, type = 'error') {
            showToast(message, type);
        }

        // Format WhatsApp number with country-specific mask
        /**
         * Formata número de telefone para exibição
         * @param {string} phoneNumber - Número de telefone (ex: 5519998021956)
         * @returns {string} - Número formatado (ex: +55 (19) 99802-1956)
         */
        function formatPhoneForDisplay(phoneNumber) {
            if (!phoneNumber) return '';
            
            // Remover caracteres não numéricos
            const cleanNumber = phoneNumber.replace(/\D/g, '');
            
            // Se começar com 55 (Brasil)
            if (cleanNumber.startsWith('55') && cleanNumber.length >= 13) {
                // Formato: 5519998021956 -> +55 (19) 99802-1956
                const countryCode = cleanNumber.substring(0, 2);
                const areaCode = cleanNumber.substring(2, 4);
                const firstPart = cleanNumber.substring(4, 9);
                const secondPart = cleanNumber.substring(9, 13);
                return `+${countryCode} (${areaCode}) ${firstPart}-${secondPart}`;
            }
            // Se começar com 55 mas for menor (formato antigo)
            else if (cleanNumber.startsWith('55') && cleanNumber.length >= 12) {
                // Formato: 551998021956 -> +55 (19) 9802-1956
                const countryCode = cleanNumber.substring(0, 2);
                const areaCode = cleanNumber.substring(2, 4);
                const firstPart = cleanNumber.substring(4, 8);
                const secondPart = cleanNumber.substring(8, 12);
                return `+${countryCode} (${areaCode}) ${firstPart}-${secondPart}`;
            }
            // Se for número brasileiro sem código do país
            else if (cleanNumber.length === 11) {
                // Formato: 19998021956 -> +55 (19) 99802-1956
                const areaCode = cleanNumber.substring(0, 2);
                const firstPart = cleanNumber.substring(2, 7);
                const secondPart = cleanNumber.substring(7, 11);
                return `+55 (${areaCode}) ${firstPart}-${secondPart}`;
            }
            // Se for número brasileiro antigo sem código do país
            else if (cleanNumber.length === 10) {
                // Formato: 1998021956 -> +55 (19) 9802-1956
                const areaCode = cleanNumber.substring(0, 2);
                const firstPart = cleanNumber.substring(2, 6);
                const secondPart = cleanNumber.substring(6, 10);
                return `+55 (${areaCode}) ${firstPart}-${secondPart}`;
            }
            // Para outros formatos, retornar com + na frente
            else {
                return `+${cleanNumber}`;
            }
        }
        
        function formatWhatsAppWithCountry(input) {
            const countryCode = document.getElementById('country-code').value;
            const selectedOption = document.querySelector(`#country-code option[value="${countryCode}"]`);
            const format = selectedOption ? selectedOption.getAttribute('data-format') : '(99) 9 9999-9999';
            
            let value = input.value.replace(/\D/g, '');
            
            // Apply formatting based on country
            if (countryCode === '55') { // Brazil
                // Limit to 11 digits (DDD + 9 digits)
                if (value.length > 11) {
                    value = value.substring(0, 11);
                }
                
                // Format: (99) 9 9999-9999
                if (value.length >= 11) {
                    value = value.replace(/(\d{2})(\d{1})(\d{4})(\d{4})/, '($1) $2 $3-$4');
                } else if (value.length >= 7) {
                    value = value.replace(/(\d{2})(\d{1})(\d{0,4})(\d{0,4})/, '($1) $2 $3-$4');
                } else if (value.length >= 3) {
                    value = value.replace(/(\d{2})(\d{0,1})(\d{0,4})/, '($1) $2 $3');
                } else if (value.length >= 1) {
                    value = value.replace(/(\d{0,2})/, '($1)');
                }
            } else if (countryCode === '1') { // US/Canada
                if (value.length > 10) {
                    value = value.substring(0, 10);
                }
                if (value.length >= 10) {
                    value = value.replace(/(\d{3})(\d{3})(\d{4})/, '($1) $2-$3');
                } else if (value.length >= 6) {
                    value = value.replace(/(\d{3})(\d{0,3})(\d{0,4})/, '($1) $2-$3');
                } else if (value.length >= 3) {
                    value = value.replace(/(\d{0,3})(\d{0,3})/, '($1) $2');
                } else {
                    value = value.replace(/(\d{0,3})/, '($1)');
                }
            } else if (countryCode === '351') { // Portugal
                // Limit to 9 digits for Portugal
                if (value.length > 9) {
                    value = value.substring(0, 9);
                }
                
                // Format: 999 999 999
                if (value.length >= 9) {
                    value = value.replace(/(\d{3})(\d{3})(\d{3})/, '$1 $2 $3');
                } else if (value.length >= 6) {
                    value = value.replace(/(\d{3})(\d{0,3})(\d{0,3})/, '$1 $2 $3');
                } else if (value.length >= 3) {
                    value = value.replace(/(\d{0,3})(\d{0,3})/, '$1 $2');
                }
            } else {
                // Generic formatting for other countries
                if (value.length > 15) {
                    value = value.substring(0, 15);
                }
            }
            
            input.value = value;
        }
        
        // Get minimum required length for WhatsApp validation based on country (formatted)
        function getMinWhatsAppLength(countryCode) {
            const countryLengths = {
                '55': 14,   // Brazil: (99) 9 9999-9999
                '1': 14,    // US/Canada: (999) 999-9999
                '351': 11,  // Portugal: 999 999 999
                '244': 11,  // Angola: 999 999 999
                '258': 12,  // Mozambique: 99 999 9999
                '238': 9,   // Cape Verde: 999 99 99
                '245': 8,   // Guinea-Bissau: 999 9999
                '239': 7,   // São Tomé: 99 99999
                '670': 8,   // East Timor: 999 9999
                '853': 9,   // Macau: 9999 9999
                '54': 12,   // Argentina: 9 9999-9999
                '56': 12,   // Chile: 9 9999 9999
                '57': 12,   // Colombia: 999 999 9999
                '51': 11,   // Peru: 999 999 999
                '598': 9,   // Uruguay: 9999 9999
                '595': 10,  // Paraguay: 999 999999
                '591': 9,   // Bolivia: 9999 9999
                '593': 12,  // Ecuador: 99 999 9999
                '58': 12,   // Venezuela: 999-999-9999
                '592': 8,   // Guyana: 999 9999
                '597': 8,   // Suriname: 999-9999
                '594': 12,  // French Guiana: 999 99 99 99
                '34': 12,   // Spain: 999 99 99 99
                '33': 14,   // France: 99 99 99 99 99
                '39': 12,   // Italy: 999 999 9999
                '49': 12,   // Germany: 999 99999999
                '44': 11    // UK: 9999 999999
            };
            return countryLengths[countryCode] || 8; // Default minimum length
        }
        
        // Get minimum required digits for WhatsApp validation based on country (digits only)
        function getMinWhatsAppDigits(countryCode) {
            const countryDigits = {
                '55': 11,   // Brazil: 11 digits
                '1': 10,    // US/Canada: 10 digits
                '351': 9,   // Portugal: 9 digits
                '244': 9,   // Angola: 9 digits
                '258': 9,   // Mozambique: 9 digits
                '238': 7,   // Cape Verde: 7 digits
                '245': 7,   // Guinea-Bissau: 7 digits
                '239': 7,   // São Tomé: 7 digits
                '670': 7,   // East Timor: 7 digits
                '853': 8,   // Macau: 8 digits
                '54': 10,   // Argentina: 10 digits
                '56': 9,    // Chile: 9 digits
                '57': 10,   // Colombia: 10 digits
                '51': 9,    // Peru: 9 digits
                '598': 8,   // Uruguay: 8 digits
                '595': 9,   // Paraguay: 9 digits
                '591': 8,   // Bolivia: 8 digits
                '593': 9,   // Ecuador: 9 digits
                '58': 10,   // Venezuela: 10 digits
                '592': 7,   // Guyana: 7 digits
                '597': 7,   // Suriname: 7 digits
                '594': 10,  // French Guiana: 10 digits
                '34': 9,    // Spain: 9 digits
                '33': 10,   // France: 10 digits
                '39': 10,   // Italy: 10 digits
                '49': 11,   // Germany: 11 digits
                '44': 10    // UK: 10 digits
            };
            return countryDigits[countryCode] || 7; // Default minimum digits
        }
        
        // Update phone placeholder based on selected country
        function updatePhonePlaceholder() {
            const countryCode = document.getElementById('country-code').value;
            const selectedOption = document.querySelector(`#country-code option[value="${countryCode}"]`);
            const format = selectedOption ? selectedOption.getAttribute('data-format') : '(99) 9 9999-9999';
            const phoneInput = document.getElementById('customer-whatsapp');
            
            phoneInput.placeholder = format;
            phoneInput.value = ''; // Clear current value when country changes
        }
        
        // Detect country by IP and set default country code
        async function detectCountryByIP() {
            // Lista de APIs que tentaremos, em ordem de prioridade
            const apiEndpoints = [
                {
                    url: 'https://ipinfo.io/json',
                    extractCode: (data) => {
                        // ipinfo.io retorna o código do país diretamente
                        const countryMapping = {
                            'BR': '55', 'PT': '351', 'AO': '244', 'MZ': '258', 'CV': '238',
                            'GW': '245', 'ST': '239', 'TL': '670', 'MO': '853',
                            'US': '1', 'CA': '1', 'AR': '54', 'CL': '56',
                            'CO': '57', 'PE': '51', 'UY': '598', 'PY': '595', 'BO': '591',
                            'EC': '593', 'VE': '58', 'GY': '592', 'SR': '597', 'GF': '594',
                            'ES': '34', 'FR': '33', 'IT': '39', 'DE': '49', 'GB': '44'
                        };
                        return countryMapping[data.country] || '55';
                    }
                },
                {
                    url: 'https://api.ipdata.co?api-key=test',
                    extractCode: (data) => {
                        // ipdata.co retorna o código do país e o código de chamada
                        return data.calling_code || '55';
                    }
                },
                {
                    url: `https://api.ipgeolocation.io/ipgeo?apiKey=${window.ENV?.IP_GEO_API_KEY || 'API_KEY_FREE'}`,
                    extractCode: (data) => {
                        // ipgeolocation.io retorna o código de chamada
                        return data.calling_code?.replace('+', '') || '55';
                    }
                }
            ];
            
            let phoneCountryCode = '55'; // Valor padrão para Brasil
            let countryName = 'Brazil';
            let apiUsed = 'nenhuma';
            
            // Tenta cada API até uma funcionar
            for (const api of apiEndpoints) {
                try {
                    debugLog('Tentando API:', api.url);
                    const response = await fetch(api.url, { 
                        method: 'GET',
                        headers: { 'Accept': 'application/json' },
                        // Timeout de 3 segundos para não travar o carregamento
                        signal: AbortSignal.timeout(3000)
                    });
                    
                    if (response.ok) {
                        const data = await response.json();
                        phoneCountryCode = api.extractCode(data);
                        countryName = data.country_name || data.country || 'Brazil';
                        apiUsed = api.url;
                        break; // Sai do loop se uma API funcionar
                    }
                } catch (error) {
                    debugLog('Erro ao acessar API:', api.url, error.message);
                    // Continua para a próxima API
                }
            }
            
            debugLog('País detectado:', countryName, 'Código telefônico:', phoneCountryCode, 'API usada:', apiUsed);
            
            // Atualiza o seletor de país
            const countrySelect = document.getElementById('country-code');
            if (countrySelect) {
                countrySelect.value = phoneCountryCode;
                updatePhonePlaceholder();
            }
        }
        
        // Check if webhook is active
        function isWebhookActive() {
            const envioConfig = getEnvioConfig();
            // Webhook is active when there's a webhook URL AND whatsapp_web is NOT 'Sim'
            // If whatsapp_web is 'Sim', we should use WhatsApp Web instead of webhook
            return envioConfig.webhook_url && envioConfig.webhook_url.trim() !== '' && envioConfig.whatsapp_web !== 'Sim';
        }
        
        // Show/hide WhatsApp field based on webhook status
        function toggleWhatsAppField() {
            const whatsappField = document.getElementById('whatsapp-field');
            
            // Verificação defensiva - elemento deve existir
            if (!whatsappField) {
                if (typeof warnLog === 'function') warnLog('⚠️ WhatsApp field element not found');
                return;
            }
            
            // Campo de WhatsApp agora é sempre visível
            whatsappField.classList.remove('hidden');
        }

        // Focus order notes field with auto-scroll to prevent keyboard covering
        function focusOrderNotesField(element) {
            // Apply visual focus styles
            element.style.borderColor = 'var(--cor-primaria)';
            element.style.outline = '2px solid var(--cor-primaria)';
            element.style.outlineOffset = '2px';
            
            // Auto-scroll within modal container with delay for mobile keyboard
            setTimeout(() => {
                // Find the modal container with overflow-y-auto
                const modalContainer = document.querySelector('#checkout-modal .overflow-y-auto');
                if (!modalContainer) {
                    if (typeof debugLog === 'function') debugLog('❌ Modal container not found');
                    return;
                }
                
                // Get element position relative to modal container
                const elementRect = element.getBoundingClientRect();
                const containerRect = modalContainer.getBoundingClientRect();
                const elementHeight = elementRect.height;
                const containerHeight = containerRect.height;
                
                // Calculate relative position within the modal
                const elementTopInModal = elementRect.top - containerRect.top + modalContainer.scrollTop;
                
                // Calculate position to center the field in visible area, accounting for mobile keyboard
                const viewportHeight = window.innerHeight;
                const keyboardHeight = viewportHeight * 0.4; // Estimate keyboard height (40% of viewport)
                const availableHeight = Math.min(containerHeight, viewportHeight - keyboardHeight);
                const targetScrollPosition = elementTopInModal - (availableHeight / 2) + (elementHeight / 2);
                
                // Smooth scroll within modal container
                modalContainer.scrollTo({
                    top: Math.max(0, targetScrollPosition),
                    behavior: 'smooth'
                });
                
                if (typeof debugLog === 'function') debugLog('📝 Order notes field focused and centered within modal');
            }, 300); // Delay to allow keyboard animation
        }

        // Função auxiliar para formatar o endereço para a planilha
        function formatAddressForSheet() {
            if (!orderData || !orderData.address) return '';

            const { street, number, complement, neighborhood, city } = orderData.address;
            const addressParts = [];

            // Constrói a primeira parte do endereço (Rua, Número, Complemento)
            let streetPart = street || '';
            if (number) streetPart += `, ${number}`;
            if (complement) streetPart += ` - ${complement}`;
            if (streetPart) addressParts.push(streetPart);

            // Constrói a segunda parte (Bairro, Cidade)
            if (neighborhood) addressParts.push(neighborhood);
            if (city) addressParts.push(city);

            return addressParts.join(' | ');
        }


        // Finalize order with enhanced validation
        async function finalizeOrder() {
            // Collect customer data
            const customerName = document.getElementById('customer-name').value.trim();
            const paymentMethod = document.getElementById('payment-method').value;
            const customerWhatsApp = document.getElementById('customer-whatsapp').value.trim();
            
            // Simple validation without loops
            let hasErrors = false;
            
            // Clear any existing errors first
            clearFieldError('customer-name');
            clearFieldError('payment-method');
            clearFieldError('customer-whatsapp');
            
            // Validate customer name
            if (!customerName || customerName.length < 2) {
                showFieldError('customer-name', customerName ? 'Nome deve ter pelo menos 2 caracteres' : 'Nome completo é obrigatório');
                hasErrors = true;
            }
            
            // Validate WhatsApp if webhook is active
            if (true) { // Validação de WhatsApp sempre ativa
                const countryCodeSelect = document.getElementById('country-code');
                const selectedCountryCode = countryCodeSelect ? countryCodeSelect.value : '55';
                const digitsOnly = customerWhatsApp.replace(/\D/g, ''); // Extract only digits
                const minDigits = getMinWhatsAppDigits(selectedCountryCode);
                
                if (!customerWhatsApp || digitsOnly.length < minDigits) {
                    showFieldError('customer-whatsapp', 'WhatsApp é obrigatório e deve ter um formato válido');
                    hasErrors = true;
                }
            }
            
            // Validate payment method only if payment methods are enabled AND not "Consumo no Local"
            const checkoutConfig = getCheckoutConfig();
            if (checkoutConfig.step3_show_formas_pag === 'Sim' && orderData.deliveryType !== 'local') {
                if (!paymentMethod) {
                    showFieldError('payment-method', 'Selecione a forma de pagamento');
                    hasErrors = true;
                }
                
                // Validar valor do troco se pagamento for em dinheiro (OPCIONAL)
                if (paymentMethod === 'dinheiro') {
                    debugLog('=== VALIDANDO TROCO (OPCIONAL) ===');
                    const changeAmountInput = document.getElementById('change-amount');
                    const changeValue = changeAmountInput?.value?.trim() || '';
                    
                    debugLog('Change input:', changeAmountInput);
                    debugLog('Change value:', changeValue);
                    
                    clearFieldError('change-amount');
                    
                    // Campo é OPCIONAL - só valida se foi preenchido
                    if (changeValue) {
                        const numericChangeValue = parseFloat(changeValue.replace(/[^\d,]/g, '').replace(',', '.'));
                        const cartTotal = calculateFinalOrderTotal();
                        
                        debugLog('Valor numérico do troco:', numericChangeValue);
                        debugLog('Total do carrinho:', cartTotal);
                        
                        if (isNaN(numericChangeValue) || numericChangeValue <= 0) {
                            showFieldError('change-amount', 'Valor inválido para troco');
                            hasErrors = true;
                        } else if (numericChangeValue <= cartTotal) {
                            showFieldError('change-amount', 
                                `Valor deve ser maior que ${formatCurrency(cartTotal)}.`);
                            hasErrors = true;
                        }
                    } else {
                        debugLog('Campo de troco vazio - assumindo que cliente tem troco exato');
                    }
                }
            }
            
            // ====================================================================
            // 💰 VALIDAÇÃO V4.1.3: VALOR MÍNIMO DO PEDIDO
            // ====================================================================
            // Verificar se o pedido atende ao valor mínimo configurado no CSV
            const minimumOrderValue = parseFloat(appConfig?.checkout?.valor_pedido_minimo) || 0;
            const currentTotal = calculateCartTotal();
            
            if (minimumOrderValue > 0 && currentTotal < minimumOrderValue) {
                showToast(`💰 Valor mínimo do pedido: ${formatCurrency(minimumOrderValue)}. Seu pedido atual: ${formatCurrency(currentTotal)}`, 'warning', 5000);
                debugLog('💰 Pedido rejeitado - valor abaixo do mínimo:', {
                    valorMinimo: minimumOrderValue,
                    valorAtual: currentTotal,
                    diferenca: minimumOrderValue - currentTotal
                });
                return;
            }
            
            // If there are errors, stop here
            if (hasErrors) {
                showToast('Por favor, preencha todos os campos obrigatórios', 'error');
                return;
            }
            
            // Verificar se cupom ainda é válido antes de finalizar
            if (appliedCoupon) {
                if (!validateCouponDates(appliedCoupon)) {
                    // Remover cupom expirado
                    clearCoupon();
                    showToast('⚠️ Cupom expirou durante o checkout. Confirme o pedido novamente.', 'warning', 5000);
                    return; // Impedir finalização até usuário confirmar
                }
            }
            
            // Update order data only after validation passes
            orderData.customerName = customerName;
            orderData.paymentMethod = paymentMethod;
            
            // Captura e limpa o valor de troco (remove formatação de moeda)
            const changeAmountRaw = document.getElementById('change-amount')?.value || '';
            orderData.changeAmount = changeAmountRaw ? changeAmountRaw.replace(/[^\d,.-]/g, '').replace(',', '.') : '';
            
            orderData.notes = document.getElementById('order-notes').value;
            
            // Debug: Verificar valor de troco
            console.log('[Pedido] Forma de pagamento:', paymentMethod);
            console.log('[Pedido] Valor de troco RAW:', changeAmountRaw);
            console.log('[Pedido] Valor de troco LIMPO:', orderData.changeAmount);
            console.log('[Pedido] Campo change-amount existe?', document.getElementById('change-amount'));
            // Add selected country code to WhatsApp number for sending
            if (customerWhatsApp) {
                const countryCodeSelect = document.getElementById('country-code');
                const selectedCountryCode = countryCodeSelect ? countryCodeSelect.value : '55';
                orderData.customerWhatsApp = selectedCountryCode + customerWhatsApp.replace(/\D/g, '');
            } else {
                orderData.customerWhatsApp = '';
            }
            
            // ===== NOVO FLUXO DE ENVIO DE PEDIDO (SUPABASE + WHATSAPP) =====
            try {
                showToast('Enviando seu pedido...', 'info', 60000); // Toast de longa duração
        
                // Obter user_id do usuário logado (se houver)
                const { data: { session } } = await supabase.auth.getSession();
                const userId = session?.user?.id || null;
                
                debugLog('👤 User ID para o pedido:', userId);
        
                // Crie o payload do pedido para o Supabase
                const orderPayload = {
                    order_id: generateOrderId(), // Gera um ID único para o pedido
                    user_id: userId, // ID do usuário logado (ou null se não estiver logado)
                    customer_name: orderData.customerName,
                    customer_phone: orderData.customerWhatsApp,
                    delivery_type: orderData.deliveryType, // Nome da coluna na sua tabela
                    address: orderData.deliveryType === 'delivery' ? formatAddressForSheet() : (orderData.tableNumber || ''),
                    payment_method: orderData.paymentMethod,
                    change_amount: (() => {
                        const rawValue = orderData.changeAmount;
                        console.log('[Supabase] change_amount RAW:', rawValue);
                        
                        if (!rawValue || rawValue === '') {
                            console.log('[Supabase] change_amount é vazio, enviando NULL');
                            return null;
                        }
                        
                        const cleanValue = String(rawValue).replace(/[^\d,.-]/g, '').replace(',', '.');
                        const numericValue = parseFloat(cleanValue);
                        
                        console.log('[Supabase] change_amount LIMPO:', cleanValue);
                        console.log('[Supabase] change_amount NUMÉRICO:', numericValue);
                        console.log('[Supabase] change_amount É VÁLIDO?', !isNaN(numericValue));
                        
                        return !isNaN(numericValue) ? numericValue : null;
                    })(),
                    total: calculateFinalOrderTotal(),
                    items: cart, // Salva o carrinho inteiro como um objeto JSON
                    notes: orderData.notes,
                    status: 'Novo' // Status inicial do pedido
                };
        
                // Insere o pedido no Supabase
                const { data, error } = await supabase
                    .from('pedidos')
                    .insert([orderPayload]);
        
                if (error) {
                    throw error; // Lança o erro para o bloco catch
                }
        
                // Sucesso!
                console.log('Pedido inserido com sucesso no Supabase:', data);
                const checkoutConfig = getCheckoutConfig();
                const successMessage = checkoutConfig.checkout_mensagem_confirmacao || 'Pedido enviado com sucesso!';
                showToast(successMessage, 'success', 3000);
        
                // Fecha o checkout, limpa o carrinho e abre o modal de rastreio
                setTimeout(() => {
                    // 1. Fechar o modal de checkout
                    closeCheckout();

                    // 2. Limpar o carrinho e resetar o sistema
                    resetSystemAfterOrder();

                    // 3. Abrir o modal de rastreio
                    openTrackingModal();

                    // 4. Preencher o código do pedido e iniciar a busca
                    const orderIdInput = document.getElementById('order-id-input');
                    if (orderIdInput) orderIdInput.value = orderPayload.order_id;
                    
                    trackOrder();
                }, 1500);
        
            } catch (error) {
                errorLog('❌ Erro ao inserir pedido no Supabase:', error);
                showToast('Erro ao registrar o pedido. Tente novamente.', 'error', 5000);
            }
        }

        // Format money input
        // Currency configuration object
        const currencyConfig = {
            // Américas
            'BRL': { symbol: 'R$', decimalSeparator: ',', thousandSeparator: '.', position: 'before' },
            'USD': { symbol: '$', decimalSeparator: '.', thousandSeparator: ',', position: 'before' },
            'CAD': { symbol: 'C$', decimalSeparator: '.', thousandSeparator: ',', position: 'before' },
            'MXN': { symbol: '$', decimalSeparator: '.', thousandSeparator: ',', position: 'before' },
            'ARS': { symbol: '$', decimalSeparator: ',', thousandSeparator: '.', position: 'before' },
            'CLP': { symbol: '$', decimalSeparator: ',', thousandSeparator: '.', position: 'before' },
            'COP': { symbol: '$', decimalSeparator: ',', thousandSeparator: '.', position: 'before' },
            'PEN': { symbol: 'S/', decimalSeparator: '.', thousandSeparator: ',', position: 'before' },
            'PYG': { symbol: '₲', decimalSeparator: ',', thousandSeparator: '.', position: 'before' },
            'UYU': { symbol: '$U', decimalSeparator: ',', thousandSeparator: '.', position: 'before' },
            
            // Europa
            'EUR': { symbol: '€', decimalSeparator: ',', thousandSeparator: '.', position: 'after' },
            'GBP': { symbol: '£', decimalSeparator: '.', thousandSeparator: ',', position: 'before' },
            'CHF': { symbol: 'CHF', decimalSeparator: '.', thousandSeparator: ',', position: 'before' },
            'SEK': { symbol: 'kr', decimalSeparator: ',', thousandSeparator: ' ', position: 'after' },
            'NOK': { symbol: 'kr', decimalSeparator: ',', thousandSeparator: ' ', position: 'after' },
            'DKK': { symbol: 'kr', decimalSeparator: ',', thousandSeparator: '.', position: 'after' },
            'PLN': { symbol: 'zł', decimalSeparator: ',', thousandSeparator: ' ', position: 'after' },
            'CZK': { symbol: 'Kč', decimalSeparator: ',', thousandSeparator: ' ', position: 'after' },
            'HUF': { symbol: 'Ft', decimalSeparator: ',', thousandSeparator: ' ', position: 'after' },
            'RUB': { symbol: '₽', decimalSeparator: ',', thousandSeparator: ' ', position: 'after' },
            'TRY': { symbol: '₺', decimalSeparator: ',', thousandSeparator: '.', position: 'before' },
            'ILS': { symbol: '₪', decimalSeparator: '.', thousandSeparator: ',', position: 'before' },
            
            // Ásia & Oriente Médio
            'JPY': { symbol: '¥', decimalSeparator: '.', thousandSeparator: ',', position: 'before' },
            'CNY': { symbol: '¥', decimalSeparator: '.', thousandSeparator: ',', position: 'before' },
            'KRW': { symbol: '₩', decimalSeparator: '.', thousandSeparator: ',', position: 'before' },
            'INR': { symbol: '₹', decimalSeparator: '.', thousandSeparator: ',', position: 'before' },
            'IDR': { symbol: 'Rp', decimalSeparator: ',', thousandSeparator: '.', position: 'before' },
            'THB': { symbol: '฿', decimalSeparator: '.', thousandSeparator: ',', position: 'before' },
            'MYR': { symbol: 'RM', decimalSeparator: '.', thousandSeparator: ',', position: 'before' },
            'SGD': { symbol: 'S$', decimalSeparator: '.', thousandSeparator: ',', position: 'before' },
            'AED': { symbol: 'د.إ', decimalSeparator: '.', thousandSeparator: ',', position: 'before' },
            'SAR': { symbol: 'ر.س', decimalSeparator: '.', thousandSeparator: ',', position: 'before' },
            'KWD': { symbol: 'د.ك', decimalSeparator: '.', thousandSeparator: ',', position: 'before' },
            'AFN': { symbol: '؋', decimalSeparator: '.', thousandSeparator: ',', position: 'before' },
            'BDT': { symbol: '৳', decimalSeparator: '.', thousandSeparator: ',', position: 'before' },
            'IRR': { symbol: '﷼', decimalSeparator: '.', thousandSeparator: ',', position: 'before' },
            'LKR': { symbol: 'Rs', decimalSeparator: '.', thousandSeparator: ',', position: 'before' },
            'TWD': { symbol: 'NT$', decimalSeparator: '.', thousandSeparator: ',', position: 'before' },
            'VND': { symbol: '₫', decimalSeparator: ',', thousandSeparator: '.', position: 'after' },
            
            // África
            'AOA': { symbol: 'Kz', decimalSeparator: ',', thousandSeparator: '.', position: 'before' },
            'ZAR': { symbol: 'R', decimalSeparator: '.', thousandSeparator: ',', position: 'before' },
            'NGN': { symbol: '₦', decimalSeparator: '.', thousandSeparator: ',', position: 'before' },
            'EGP': { symbol: 'ج.م', decimalSeparator: '.', thousandSeparator: ',', position: 'before' },
            'KES': { symbol: 'KSh', decimalSeparator: '.', thousandSeparator: ',', position: 'before' },
            'GHS': { symbol: '₵', decimalSeparator: '.', thousandSeparator: ',', position: 'before' },
            'MAD': { symbol: 'د.م.', decimalSeparator: '.', thousandSeparator: ',', position: 'before' },
            'DZD': { symbol: 'د.ج', decimalSeparator: '.', thousandSeparator: ',', position: 'before' },
            'TND': { symbol: 'د.ت', decimalSeparator: '.', thousandSeparator: ',', position: 'before' },
            
            // Oceania
            'AUD': { symbol: 'A$', decimalSeparator: '.', thousandSeparator: ',', position: 'before' },
            'NZD': { symbol: 'NZ$', decimalSeparator: '.', thousandSeparator: ',', position: 'before' },
            'FJD': { symbol: 'FJ$', decimalSeparator: '.', thousandSeparator: ',', position: 'before' }
        };

        // Get current currency from configuration
        function getCurrentCurrency() {
            const checkoutConfig = getCheckoutConfig();
            return checkoutConfig.checkout_currency || 'BRL';
        }

        // Get currency configuration
        function getCurrencyConfig() {
            const currency = getCurrentCurrency();
            return currencyConfig[currency] || currencyConfig['BRL'];
        }

        /**
         * Função para escurecer uma cor em 30%
         * @param {string} cor - Cor em formato hexadecimal, RGB ou variável CSS
         * @returns {string} - Cor escurecida em formato hexadecimal
         */
        function escurecerCor30Porcento(cor) {
            // Se a cor estiver no formato var(--variavel), usar cor padrão
            if (cor.includes('var(')) {
                cor = '#6B7280'; // Cor terciária padrão
            }
            
            // Remover espaços e # se existir
            cor = cor.replace(/\s/g, '').replace('#', '');
            
            // Se a cor estiver em formato RGB, converter para hex
            if (cor.includes('rgb')) {
                const rgbMatch = cor.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);
                if (rgbMatch) {
                    const r = parseInt(rgbMatch[1]);
                    const g = parseInt(rgbMatch[2]);
                    const b = parseInt(rgbMatch[3]);
                    cor = r.toString(16).padStart(2, '0') + 
                          g.toString(16).padStart(2, '0') + 
                          b.toString(16).padStart(2, '0');
                }
            }
            
            // Garantir que temos uma cor hex válida
            if (cor.length !== 6) {
                cor = '6B7280'; // Fallback para cor terciária
            }
            
            // Converter para RGB
            let r = parseInt(cor.substring(0, 2), 16);
            let g = parseInt(cor.substring(2, 4), 16);
            let b = parseInt(cor.substring(4, 6), 16);
            
            // Escurecer cada componente em 30%
            r = Math.floor(r * 0.7); // 30% mais escuro = multiplicar por 0.7
            g = Math.floor(g * 0.7);
            b = Math.floor(b * 0.7);
            
            // Garantir que os valores estão no intervalo válido
            r = Math.max(0, Math.min(255, r));
            g = Math.max(0, Math.min(255, g));
            b = Math.max(0, Math.min(255, b));
            
            // Converter de volta para hexadecimal
            return '#' + 
                   r.toString(16).padStart(2, '0') + 
                   g.toString(16).padStart(2, '0') + 
                   b.toString(16).padStart(2, '0');
        }
        
        // Format currency value for display
        function formatCurrency(value) {
            const config = getCurrencyConfig();
            
            // Converter para número se for string
            const numValue = typeof value === 'string' ? parseFloat(value) : value;
            
            // Separar parte inteira e decimal
            const [integerPart, decimalPart] = numValue.toFixed(2).split('.');
            
            // Aplicar separador de milhares na parte inteira
            const formattedInteger = integerPart.replace(/\B(?=(\d{3})+(?!\d))/g, config.thousandSeparator);
            
            // Montar valor final com separador decimal correto
            const formattedValue = `${formattedInteger}${config.decimalSeparator}${decimalPart}`;
            
            if (config.position === 'before') {
                return `${config.symbol} ${formattedValue}`;
            } else {
                return `${formattedValue} ${config.symbol}`;
            }
        }

        function formatMoney(input) {
            const config = getCurrencyConfig();
            let value = input.value.replace(/\D/g, '');
            
            if (value === '') {
                input.value = '';
                return;
            }
            
            // Convert to number and format
            value = parseInt(value);
            value = (value / 100).toFixed(2);
            
            // Format with current currency
            const formattedValue = value.replace('.', config.decimalSeparator);
            if (config.position === 'before') {
                input.value = `${config.symbol} ${formattedValue}`;
            } else {
                input.value = `${formattedValue} ${config.symbol}`;
            }
        }

        // Get numeric value from formatted money
        function getNumericValue(formattedValue) {
            if (!formattedValue) return 0;
            const config = getCurrencyConfig();
            
            // Remove currency symbol and convert back to number
            let cleanValue = formattedValue.replace(config.symbol, '').trim();
            cleanValue = cleanValue.replace(config.decimalSeparator, '.');
            
            return parseFloat(cleanValue) || 0;
        }

        // ===== SISTEMA DE PREÇOS MÚLTIPLOS - FUNÇÕES AUXILIARES =====
        
        // Função de parsing inteligente internacional
        function parsePrice(priceString) {
            try {
                if (!priceString || priceString === '' || priceString === null || priceString === undefined) return 0;
            
            const config = getCurrencyConfig();
            let cleanValue = priceString.toString().trim();
            
            // Remove símbolos de moeda
            cleanValue = cleanValue.replace(/[^\d.,\-\s]/g, '');
            
            // Detectar formato baseado na configuração da moeda
            if (config.decimalSeparator === ',' && config.thousandSeparator === '.') {
                // Formato brasileiro/europeu: 1.500,50
                if (cleanValue.includes(',') && cleanValue.includes('.')) {
                    // Tem ambos: último é decimal
                    const lastComma = cleanValue.lastIndexOf(',');
                    const lastDot = cleanValue.lastIndexOf('.');
                    
                    if (lastComma > lastDot) {
                        // Vírgula é decimal: 1.500,50
                        cleanValue = cleanValue.replace(/\./g, '').replace(',', '.');
                    } else {
                        // Ponto é decimal: 1,500.50 (formato misto)
                        cleanValue = cleanValue.replace(/,/g, '');
                    }
                } else if (cleanValue.includes(',')) {
                    // Só vírgula: pode ser decimal ou milhares
                    const parts = cleanValue.split(',');
                    if (parts.length === 2 && parts[1].length <= 2) {
                        // Provavelmente decimal: 15,50
                        cleanValue = cleanValue.replace(',', '.');
                    } else {
                        // Provavelmente milhares: 1,500
                        cleanValue = cleanValue.replace(/,/g, '');
                    }
                }
            } else {
                // Formato americano: 1,500.50
                if (cleanValue.includes(',') && cleanValue.includes('.')) {
                    const lastComma = cleanValue.lastIndexOf(',');
                    const lastDot = cleanValue.lastIndexOf('.');
                    
                    if (lastDot > lastComma) {
                        // Ponto é decimal: 1,500.50
                        cleanValue = cleanValue.replace(/,/g, '');
                    } else {
                        // Vírgula é decimal: 1.500,50 (formato misto)
                        cleanValue = cleanValue.replace(/\./g, '').replace(',', '.');
                    }
                } else if (cleanValue.includes('.')) {
                    // Só ponto: pode ser decimal ou milhares
                    const parts = cleanValue.split('.');
                    if (parts.length === 2 && parts[1].length <= 2) {
                        // Provavelmente decimal: 15.50
                        // Já está no formato correto
                    } else {
                        // Provavelmente milhares: 1.500
                        cleanValue = cleanValue.replace(/\./g, '');
                    }
                }
            }
            
            return parseFloat(cleanValue) || 0;
            } catch (error) {
                errorLog('Erro em parsePrice:', error, 'priceString:', priceString);
                return 0;
            }
        }
        
        // Detectar tipo de preço
        function getPriceType(priceField) {
            // Converter para string e validar
            if (!priceField || priceField === null || priceField === undefined) {
                return 'consultation';
            }
            
            const priceStr = String(priceField).trim();
            
            if (priceStr === '' || priceStr.toLowerCase().includes('consulte')) {
                return 'consultation';
            }
            
            // Detectar preços múltiplos (formato: Nome:Preço/Nome:Preço)
            // Aceita tanto ponto quanto vírgula como decimal
            if (priceStr.includes('/') && priceStr.includes(':')) {
                return 'multiple';
            }
            
            // Detectar preço promocional (formato: 25.00 > 19.90)
            if (priceStr.includes('>')) {
                return 'promotional';
            }
            
            return 'fixed';
        }
        

        
        // Parsing de preços múltiplos (formato: Label#Variação:Preço/Variação:Preço)
        function parseMultiplePrices(priceField) {
            if (!priceField || priceField.trim() === '') return [];
            
            if (typeof debugLog === 'function') {
                debugLog('🔍 Parsing multiple prices:', priceField);
            }
            
            // Primeiro, verificar se há um hashtag (formato: "Label#Variações")
            let variationsString = priceField;
            if (priceField.includes('#')) {
                const hashtagParts = priceField.split('#');
                if (hashtagParts.length >= 2) {
                    // Pegar tudo após o primeiro hashtag como as variações
                    variationsString = hashtagParts.slice(1).join('#');
                    
                    if (typeof debugLog === 'function') {
                        debugLog('📋 Label encontrado:', hashtagParts[0].trim());
                        debugLog('🎯 Variações extraídas:', variationsString);
                    }
                }
            }
            
            // Agora processar as variações (formato: Nome:Preço/Nome:Preço)
            const items = variationsString.split('/');
            
            const result = items.map(item => {
                const parts = item.split(':');
                
                if (parts.length !== 2) {
                    if (typeof warnLog === 'function') {
                        warnLog('⚠️ Formato inválido para variação:', item);
                    }
                    return null;
                }
                
                const [name, price] = parts;
                const cleanName = name.trim();
                const cleanPrice = price.trim();
                const parsedPrice = parsePrice(cleanPrice);
                
                if (typeof debugLog === 'function') {
                    debugLog(`📊 Variação parsed: "${cleanName}" = ${parsedPrice}`);
                }
                
                return {
                    name: cleanName,
                    price: parsedPrice
                };
            }).filter(item => item !== null);
            
            if (typeof debugLog === 'function') {
                debugLog('✅ Final parsed variations:', result);
            }
            
            return result;
        }
        
        // Extração do label dinâmico (parte antes do hashtag)
        function getMultiplePricesLabel(priceField) {
            if (!priceField || priceField.trim() === '') return 'Selecione o tamanho';
            
            if (priceField.includes('#')) {
                const hashtagParts = priceField.split('#');
                if (hashtagParts.length >= 2) {
                    const label = hashtagParts[0].trim();
                    if (typeof debugLog === 'function') {
                        debugLog('🏷️ Label extraído:', label);
                    }
                    return label || 'Selecione o tamanho';
                }
            }
            
            // Fallback para formato antigo sem hashtag
            return 'Selecione o tamanho';
        }
        
        // Exibição de preço para o span base-price (apenas texto)
        function getBasePriceDisplay(priceField) {
            try {
                const type = getPriceType(priceField);
                
                switch(type) {
                    case 'consultation':
                        return '💬 Consulte';
                        
                    case 'multiple':
                        const prices = parseMultiplePrices(priceField);
                        if (prices.length === 0) {
                            return '💬 Consulte';
                        }
                        const values = prices.map(p => p.price);
                        const min = Math.min(...values);
                        const max = Math.max(...values);
                        return `${formatCurrency(min)} - ${formatCurrency(max)}`;
                        
                    case 'promotional':
                        const priceParts = priceField.split('>');
                        if (priceParts.length === 2) {
                            const oldPrice = parsePrice(priceParts[0]);
                            const newPrice = parsePrice(priceParts[1]);
                            return `
                                <span class="text-gray-500 line-through mr-2">${formatCurrency(oldPrice)}</span>
                                <span style="color: var(--cor-sucesso); font-weight: bold;">${formatCurrency(newPrice)}</span>
                            `;
                        }
                        // Fallback se o formato estiver incorreto
                        return formatCurrency(parsePrice(priceField));

                    case 'fixed':
                    default:
                        const price = parsePrice(priceField);
                        return formatCurrency(price);
                }
            } catch (error) {
                errorLog('Erro em getBasePriceDisplay:', error, 'priceField:', priceField);
                return '💬 Consulte';
            }
        }

        
        // Exibição inteligente de preços
        function getPriceDisplay(priceField) {
            const type = getPriceType(priceField);
        
            switch(type) {
                case 'consultation':
                    return '<span style="color: var(--cor-secundaria); font-weight: bold;">💬 Consulte</span>';
                case 'multiple':
                    const prices = parseMultiplePrices(priceField);
                    if (prices.length === 0) return '<span style="color: var(--cor-secundaria); font-weight: bold;">💬 Consulte</span>';
                    const values = prices.map(p => p.price);
                    return `${formatCurrency(Math.min(...values))} - ${formatCurrency(Math.max(...values))}`;
                case 'promotional':
                    const priceParts = priceField.split('>');
                    if (priceParts.length === 2) {
                        const oldPrice = parsePrice(priceParts[0]);
                        const newPrice = parsePrice(priceParts[1]);
                        return `
                                <span class="text-gray-500 line-through mr-2 text-sm">${formatCurrency(oldPrice)}</span>
                                <span style="color: var(--cor-sucesso); font-weight: bold;">${formatCurrency(newPrice)}</span>
                            `;
                        }
                        // Fallback se o formato estiver incorreto
                        return formatCurrency(parsePrice(priceField));
                        
                case 'fixed':
                default:
                    return formatCurrency(parsePrice(priceField));
            }
        }

        // Send to WhatsApp or Webhook
        function sendToWhatsApp() {
            if (cart.length === 0) return;
            
            // Get configuration data
            const contactInfo = getContactInfo();
            const envioConfig = getEnvioConfig();
            const appConfig = getAppConfig();
            
            if (typeof debugLog === 'function') {
                debugLog('=== DEBUG SEND TO WHATSAPP ===');
                debugLog('envioConfig:', envioConfig);
                debugLog('whatsapp_web value:', envioConfig.whatsapp_web);
                debugLog('webhook_url:', envioConfig.webhook_url);
                debugLog('contactInfo:', contactInfo);
                debugLog('orderData:', orderData);
                debugLog('cart:', cart);
                debugLog('==============================');
            }
            
            // Get restaurant name and phone number from configuration
            const restaurantName = appConfig.nome_restaurante || "Cardápio Digital";
            const phoneNumber = contactInfo.whatsapp || "5519998021956";
            
            // Format the order message
            const message = formatOrderMessage(restaurantName);
            if (typeof debugLog === 'function') {
                debugLog('Formatted message:', message);
            }
            
            // Don't clear cart here - only clear after successful webhook/WhatsApp send
            
            // Check sending method based on configuration
            if (envioConfig.whatsapp_web === 'Sim') {
                if (typeof debugLog === 'function') {
                    debugLog('Using WhatsApp Web method');
                }
                // Send via WhatsApp Web
                sendViaWhatsAppWeb(phoneNumber, message);
            } else {
                if (typeof debugLog === 'function') {
                    debugLog('Using Webhook method');
                }
                // Send via Webhook
                sendViaWebhook(message, envioConfig.webhook_url);
            }
        }
        
        // Format order message
        function formatOrderMessage(restaurantName) {
            if (typeof debugLog === 'function') {
                debugLog('=== DEBUG FORMAT ORDER MESSAGE ===');
                debugLog('restaurantName:', restaurantName);
                debugLog('orderData:', orderData);
                debugLog('cart:', cart);
                debugLog('===================================');
            }
            
            let message = `🔔 *NOVO PEDIDO* 🔔\n`;
            message += `━━━━━━━━━━━━━━\n\n`;
            
            // Customer info
            message += `👤 *Cliente:* ${orderData.customerName}\n`;
            if (orderData.customerWhatsApp) {
                message += `📱 *WhatsApp:* ${orderData.customerWhatsApp}\n`;
            }
            
            // Delivery type
            const deliveryTypes = {
                'local': '🍽️ Consumir no Local',
                'pickup': '🥡 Retirar no Balcão', 
                'delivery': '🛵 Delivery',
                'default': '📋 Padrão'
            };
            message += `📍 *Entrega:* ${deliveryTypes[orderData.deliveryType]}\n`;
            
            // Additional info based on delivery type
            if (orderData.deliveryType === 'local' && orderData.tableNumber) {
                message += `🪑 *Mesa/Comanda:* ${orderData.tableNumber}\n`;
            }
            
            // Debug da condição de endereço
            debugLog('DEBUG - Condição de endereço:');
            debugLog('deliveryType:', orderData.deliveryType);
            debugLog('orderData.address:', orderData.address);
            debugLog('orderData.address.street:', orderData.address.street);
            debugLog('Condição atendida?', orderData.deliveryType === 'delivery' && orderData.address.street);
            
            if (orderData.deliveryType === 'delivery' && orderData.address.street) {
                message += `🏠 *Endereço:*\n`;
                
                // Verificar se é endereço manual ou automático
                debugLog('DEBUG - Verificando tipo de endereço:');
                debugLog('isManual:', orderData.address.isManual);
                debugLog('deliveryFee:', orderData.address.deliveryFee);
                
                if (orderData.address.isManual) {
                    // Endereço manual - formato diferenciado
                    message += `   ${orderData.address.street}\n`;
                    message += `   ${orderData.address.neighborhood}\n`;
                    message += `   ${orderData.address.city}\n`;
                    message += `   *Endereço informado manualmente*\n`;
                } else {
                    // Endereço automático via CEP - formato original
                    message += `   ${orderData.address.street}, ${orderData.address.number}`;
                    if (orderData.address.complement) {
                        message += ` - ${orderData.address.complement}`;
                    }
                    message += `\n   ${orderData.address.neighborhood}\n`;
                    message += `   ${orderData.address.city} - ${orderData.address.state}\n`;
                }
                
                // Adicionar taxa de delivery se existir (funciona para ambos os modos)
                debugLog('DEBUG - Verificando taxa de delivery:');
                debugLog('orderData.address:', orderData.address);
                debugLog('orderData.address.deliveryFee:', orderData.address.deliveryFee);
                debugLog('currentDeliveryFee:', currentDeliveryFee);
                
                // Usar orderData.address.deliveryFee ou currentDeliveryFee como fallback
                const deliveryFee = orderData.address.deliveryFee || currentDeliveryFee;
                debugLog('deliveryFee final:', deliveryFee);
                
                if (deliveryFee && deliveryFee > 0) {
                    message += `\n🚚 *Taxa de Delivery:* ${formatCurrency(deliveryFee)} (${orderData.address.neighborhood})\n`;
                    debugLog('Taxa de delivery adicionada à mensagem:', deliveryFee);
                } else {
                    debugLog('Taxa de delivery NÃO adicionada - nenhuma taxa encontrada');
                }
            }
            
            message += `\n━━━━━━━━━━━━━━\n`;
            message += `🛍️ *ITENS DO PEDIDO:*\n\n`;
            
            // Items
            cart.forEach(item => {
                // Verificar se o item tem preço válido
                const itemPrice = parseFloat(item.preco);
                const hasValidPrice = !isNaN(itemPrice) && itemPrice > 0;
                const itemSubtotal = hasValidPrice ? itemPrice * item.quantity : 0;
                
                message += `• *${item.nome}* (${item.sku})\n`;
                if (item.variationText) {
                    // Melhorar formatação das variações no WhatsApp - substituir pipes por quebras de linha
                    const formattedVariations = item.variationText.replace(/\s*\|\s*/g, '\n     ');
                    message += `  └ ✓ ${formattedVariations}\n`;
                }
                if (item.removalText) {
                    // Melhorar formatação das remoções no WhatsApp - substituir pipes por quebras de linha
                    const formattedRemovals = item.removalText.replace(/\s*\|\s*/g, '\n     ');
                    // Remover duplicação do texto "Remover Ingredientes:" se já estiver presente
                    const cleanRemovals = formattedRemovals.replace(/^Remover Ingredientes:\s*/i, '');
                    message += `  └ 🚫 Remover Ingredientes: ${cleanRemovals}\n`;
                }
                if (item.notes) {
                    message += `  └ Obs: ${item.notes}\n`;
                }
                
                // Exibir preço baseado na validade com formatação melhorada
                if (hasValidPrice) {
                    message += `  └ 📊 Qtd: ${item.quantity}x\n`;
                    message += `  └ 💰 Unitário: ${formatCurrency(itemPrice)}\n`;
                    message += `  └ 🧮 Subtotal: ${formatCurrency(itemSubtotal)}\n\n\n`;
                } else {
                    message += `  └ 📊 Qtd: ${item.quantity}x\n`;
                    message += `  └ 💰 Preço: 💬 Consulte\n\n\n`;
                }
            });
            
            // Total com breakdown detalhado - calcular apenas itens com preço válido
            let subtotal = cart.reduce((sum, item) => {
                const itemPrice = parseFloat(item.preco);
                if (isNaN(itemPrice) || itemPrice <= 0) {
                    return sum; // Ignora itens de consulta
                }
                return sum + (itemPrice * item.quantity);
            }, 0);
            let total = subtotal;
            
            // Adicionar taxa de delivery ao total se existir
            debugLog('DEBUG - Calculando total com taxa:');
            debugLog('Subtotal produtos:', subtotal);
            debugLog('deliveryType:', orderData.deliveryType);
            debugLog('address:', orderData.address);
            
            // Usar orderData.address.deliveryFee ou currentDeliveryFee como fallback
            const totalDeliveryFee = (orderData.address && orderData.address.deliveryFee) || currentDeliveryFee;
            debugLog('totalDeliveryFee:', totalDeliveryFee);
            
            if (orderData.deliveryType === 'delivery' && totalDeliveryFee && totalDeliveryFee > 0) {
                total += totalDeliveryFee;
                debugLog('Taxa adicionada ao total:', totalDeliveryFee);
            }
            
            // Verificar se há itens de consulta e itens com preço
            const hasConsultationItems = cart.some(item => {
                const itemPrice = parseFloat(item.preco);
                return isNaN(itemPrice) || itemPrice <= 0;
            });
            
            const hasPricedItems = cart.some(item => {
                const itemPrice = parseFloat(item.preco);
                return !isNaN(itemPrice) && itemPrice > 0;
            });
            
            // ✅ LÓGICA: Só mostrar resumo financeiro se houver itens com preço
            if (hasPricedItems) {
                message += `━━━━━━━━━━━━━━\n`;
                message += `💰 *RESUMO FINANCEIRO:*\n\n`;
                
                // Breakdown detalhado
                if (hasConsultationItems) {
                    message += `💵 Subtotal produtos: ${formatCurrency(subtotal)} + itens para consulta\n`;
                } else {
                    message += `💵 Subtotal produtos: ${formatCurrency(subtotal)}\n`;
                }
                
                if (orderData.deliveryType === 'delivery' && totalDeliveryFee && totalDeliveryFee > 0) {
                    message += `🚚 Taxa de delivery: ${formatCurrency(totalDeliveryFee)}\n`;
                }
                
                // Mostrar total antes do desconto se houver cupom
                if (appliedCoupon && couponDiscount > 0) {
                    message += `Total: ${formatCurrency(total)}\n`;
                }
                
                // Adicionar informações do cupom se aplicado
                if (appliedCoupon && couponDiscount > 0) {
                    const discountType = appliedCoupon.tipo_desconto || appliedCoupon.tipo || '';
                    let typeText = '';
                    
                    switch (discountType.toLowerCase()) {
                        case 'produtos':
                            typeText = 'nos produtos';
                            break;
                        case 'frete':
                            typeText = 'no frete';
                            break;
                        case 'total':
                            typeText = 'no total';
                            break;
                    }
                    
                    message += `🎟️ Cupom ${appliedCoupon.codigo_cupom || appliedCoupon.codigo}: -${formatCurrency(couponDiscount)} (${typeText})\n`;
                    total = Math.max(0, total - couponDiscount);
                    debugLog('Desconto aplicado:', couponDiscount, 'Total final:', total);
                }
                
                message += `\n💰 *TOTAL FINAL: ${formatCurrency(total)}*\n`;
                message += `━━━━━━━━━━━━━━\n`;
            } else {
                // ✅ TODOS OS ITENS SÃO DE CONSULTA - NÃO MOSTRAR RESUMO FINANCEIRO
                debugLog('📝 Todos os itens são de consulta - resumo financeiro omitido');
                message += `━━━━━━━━━━━━━━\n`;
                message += `💬 *Valores para consulta no estabelecimento*\n`;
                message += `━━━━━━━━━━━━━━\n`;
            }
            
            // Payment info (only for pickup, delivery, default AND if payment field is enabled AND if there are priced items)
            const checkoutConfig = getCheckoutConfig();
            const deliveryTypesWithPayment = ['pickup', 'delivery', 'default'];
            if (deliveryTypesWithPayment.includes(orderData.deliveryType) && checkoutConfig.step3_show_formas_pag === 'Sim' && hasPricedItems) {
                // Get payment methods from spreadsheet configuration
                const configuredMethods = checkoutConfig.step3_formas_pag;
                const paymentMethods = {};
                
                if (configuredMethods && configuredMethods.trim() !== '') {
                    // Parse configured payment methods
                    const methodsList = configuredMethods.split(',').map(method => method.trim());
                    
                    // Create dynamic mapping with emojis
                    methodsList.forEach(method => {
                        const methodKey = method.toLowerCase().replace(/\s+/g, '-');
                        let emoji = '💳'; // Default credit card emoji
                        
                        // Assign specific emojis based on method name
                        if (method.toLowerCase().includes('dinheiro')) {
                            emoji = '💵';
                        } else if (method.toLowerCase().includes('pix')) {
                            emoji = '📱';
                        } else if (method.toLowerCase().includes('cartão') || method.toLowerCase().includes('cartao')) {
                            emoji = '💳';
                        } else if (method.toLowerCase().includes('alelo') || method.toLowerCase().includes('vale') || method.toLowerCase().includes('ticket')) {
                            emoji = '🎫'; // Simpler ticket emoji
                        }
                        
                        paymentMethods[methodKey] = `${emoji} ${method}`;
                    });
                }
                
                // Só incluir se paymentMethod estiver definido
                if (orderData.paymentMethod && paymentMethods[orderData.paymentMethod]) {
                    message += `\n*Pagamento:* ${paymentMethods[orderData.paymentMethod]}\n`;
                    
                    if (orderData.paymentMethod === 'dinheiro' && orderData.changeAmount) {
                        const changeValue = getNumericValue(orderData.changeAmount);
                        message += `💸 *Troco para:* ${formatCurrency(changeValue)}\n`;
                    }
                    message += `━━━━━━━━━━━━━━\n`;
                }
            }
            
            // Notes
            if (orderData.notes) {
                message += `\n📝 *Observações:*\n${orderData.notes}\n`;
                message += `━━━━━━━━━━━━━━\n`;
            }
            
            message += `\n⏰ *Pedido realizado em:* ${new Date().toLocaleString('pt-BR')}\n`;
            message += `\n✅ *Aguardando confirmação do estabelecimento*`;
            
            return message;
        }
        
        // Format order message for thermal printing (no emojis, clean format)
        function formatOrderMessageThermal(restaurantName) {
            if (typeof debugLog === 'function') {
                debugLog('=== DEBUG FORMAT THERMAL MESSAGE ===');
                debugLog('restaurantName:', restaurantName);
                debugLog('orderData:', orderData);
                debugLog('cart:', cart);
                debugLog('=====================================');
            }
            
            let message = `NOVO PEDIDO\n`;
            message += `================================\n\n`;
            
            // Customer info
            message += `Cliente: ${orderData.customerName}\n`;
            if (orderData.customerWhatsApp) {
                message += `WhatsApp: ${orderData.customerWhatsApp}\n`;
            }
            
            // Delivery type
            const deliveryTypes = {
                'local': 'Consumir no Local',
                'pickup': 'Retirar no Balcao', 
                'delivery': 'Delivery',
                'default': 'Padrao'
            };
            message += `Entrega: ${deliveryTypes[orderData.deliveryType]}\n`;
            
            // Additional info based on delivery type
            if (orderData.deliveryType === 'local' && orderData.tableNumber) {
                message += `Mesa: ${orderData.tableNumber}\n`;
            }
            
            if (orderData.deliveryType === 'delivery' && orderData.address) {
                message += `Endereco: ${orderData.address}\n`;
            }
            
            message += `\n================================\n`;
            message += `ITENS DO PEDIDO:\n\n`;
            
            // Items
            let hasConsultationItems = false;
            cart.forEach(item => {
                const itemPrice = (typeof parsePrice === 'function') ? parsePrice(item.preco) : parseFloat(String(item.preco).replace(/[^0-9.,]/g, '').replace(',', '.'));
                const hasValidPrice = !isNaN(itemPrice) && itemPrice > 0;
                const itemSubtotal = hasValidPrice ? itemPrice * item.quantity : 0;
                
                if (!hasValidPrice) {
                    hasConsultationItems = true;
                }
                
                message += `- ${item.nome} (${item.sku})\n`;
                if (item.variationText) {
                    // Remove emojis e formata para impressao termica
                    const cleanVariations = item.variationText.replace(/\s*\|\s*/g, '\n  ');
                    message += `  Variacoes: ${cleanVariations}\n`;
                }
                if (item.removalText) {
                    // Remove emojis e duplicacao
                    const cleanRemovals = item.removalText.replace(/\s*\|\s*/g, '\n  ').replace(/^Remover Ingredientes:\s*/i, '');
                    message += `  Remover: ${cleanRemovals}\n`;
                }
                if (item.notes) {
                    message += `  Obs: ${item.notes}\n`;
                }
                
                // Pricing info
                if (hasValidPrice) {
                    message += `  Qtd: ${item.quantity}x\n`;
                    message += `  Unitario: ${formatCurrency(itemPrice)}\n`;
                    message += `  Subtotal: ${formatCurrency(itemSubtotal)}\n\n`;
                } else {
                    message += `  Qtd: ${item.quantity}x\n`;
                    message += `  Preco: Consulte\n\n`;
                }
            });
            
            // Financial summary
            // Usa o cupom aplicado globalmente, se existir
            const coupon = (typeof appliedCoupon !== 'undefined' && appliedCoupon) ? appliedCoupon : null;
            let couponDiscount = (typeof window.couponDiscount === 'number') ? window.couponDiscount : 0;
            if (coupon && (!couponDiscount || couponDiscount <= 0) && typeof calculateCouponDiscount === 'function') {
                try {
                    couponDiscount = calculateCouponDiscount(coupon) || 0;
                } catch (_) { /* noop */ }
            }
            
            // Calculate totals
            let subtotal = cart.reduce((sum, item) => {
                const price = (typeof parsePrice === 'function') ? parsePrice(item.preco) : parseFloat(String(item.preco).replace(/[^0-9.,]/g, '').replace(',', '.'));
                const hasValidPrice = !isNaN(price) && price > 0;
                return sum + (hasValidPrice ? price * item.quantity : 0);
            }, 0);
            
            const totalDeliveryFee = (orderData && orderData.deliveryType === 'delivery')
                ? ((orderData.address && typeof orderData.address.deliveryFee !== 'undefined')
                    ? orderData.address.deliveryFee
                    : (typeof currentDeliveryFee !== 'undefined' && currentDeliveryFee !== null ? currentDeliveryFee : 0))
                : 0;
            let total = subtotal + totalDeliveryFee - couponDiscount;
            
            if (subtotal > 0 || totalDeliveryFee > 0 || couponDiscount > 0) {
                message += `================================\n`;
                message += `RESUMO FINANCEIRO:\n\n`;
                
                if (hasConsultationItems) {
                    message += `Subtotal produtos: ${formatCurrency(subtotal)} + itens para consulta\n`;
                } else {
                    message += `Subtotal produtos: ${formatCurrency(subtotal)}\n`;
                }
                
                if (orderData.deliveryType === 'delivery' && totalDeliveryFee && totalDeliveryFee > 0) {
                    message += `Taxa de delivery: ${formatCurrency(totalDeliveryFee)}\n`;
                }
                
                if (coupon && couponDiscount > 0) {
                    message += `Total: ${formatCurrency(total)}\n`;
                    const discountType = coupon.tipo_desconto || coupon.tipo || '';
                    let typeText = '';
                    
                    switch (discountType.toLowerCase()) {
                        case 'produtos':
                            typeText = 'nos produtos';
                            break;
                        case 'frete':
                            typeText = 'no frete';
                            break;
                        case 'total':
                            typeText = 'no total';
                            break;
                        default:
                            typeText = 'aplicado';
                    }
                    
                    const couponCode = coupon.codigo_cupom || coupon.codigo || '';
                    message += `Cupom ${couponCode} (${typeText}): -${formatCurrency(couponDiscount)}\n`;
                }
                
                message += `--------------------------------\n`;
                message += `TOTAL FINAL: ${formatCurrency(total)}\n`;
            }
            
            // Payment method
            const paymentMethods = {
                'dinheiro': 'Dinheiro',
                'cartao': 'Cartao',
                'pix': 'PIX',
                'default': 'Nao informado'
            };
            message += `\nForma de pagamento: ${paymentMethods[orderData.paymentMethod] || paymentMethods.default}\n`;
            
            if (orderData.paymentMethod === 'dinheiro' && orderData.changeAmount) {
                message += `Troco para: ${formatCurrency(orderData.changeAmount)}\n`;
                const changeValue = orderData.changeAmount - total;
                if (changeValue > 0) {
                    message += `Valor do troco: ${formatCurrency(changeValue)}\n`;
                }
            }
            
            // Notes
            if (orderData.notes) {
                message += `\nObservacoes: ${orderData.notes}\n`;
            }
            
            message += `\nPedido realizado em: ${new Date().toLocaleString('pt-BR')}\n`;
            message += `\nAguardando confirmacao do estabelecimento`;
            
            return message;
        }
        
        // Send via WhatsApp Web (cross-platform)
        function sendViaWhatsAppWeb(phoneNumber, message) {
            debugLog('=== DEBUG WHATSAPP WEB ===');
            debugLog('phoneNumber:', phoneNumber);
            debugLog('message length:', message.length);
            debugLog('message preview:', message.substring(0, 100) + '...');
            
            // Use standard encodeURIComponent which properly handles emojis
            const encodedMessage = encodeURIComponent(message);
            debugLog('encodedMessage length:', encodedMessage.length);
            
            // Use api.whatsapp.com like ref.html for better compatibility
            const whatsappUrl = `https://api.whatsapp.com/send?phone=${phoneNumber}&text=${encodedMessage}`;
            debugLog('whatsappUrl:', whatsappUrl.substring(0, 150) + '...');
            
            // Show success message
            showCustomAlert('Pedido enviado com sucesso! Redirecionando para WhatsApp...', 'success');
            
            // Reset completo do sistema após preparação do WhatsApp
            resetSystemAfterOrder();
            debugLog('Sistema resetado completamente após envio');
            
            // Delay to show success message, then open WhatsApp
            setTimeout(() => {
                debugLog('Attempting to open WhatsApp...');
                try {
                    // Try to open in new window with fallback like ref.html
                    debugLog('Trying to open in new window...');
                    const newWindow = window.open(whatsappUrl, '_blank');
                    debugLog('New window result:', newWindow);
                    
                    if (!newWindow || newWindow.closed || typeof newWindow.closed === 'undefined') {
                        // If failed to open in new window, try same window
                        debugLog('Fallback: Opening in same window');
                        window.location.href = whatsappUrl;
                    } else {
                        debugLog('Successfully opened WhatsApp in new window');
                    }
                } catch (error) {
                    errorLog('Error opening window:', error);
                    // Fallback to wa.me if api.whatsapp.com fails
                    try {
                        const waUrl = `https://wa.me/${phoneNumber}?text=${encodedMessage}`;
                        debugLog('Trying alternative method:', waUrl);
                        window.location.href = waUrl;
                    } catch (fallbackError) {
                        errorLog('Fallback method failed:', fallbackError);
                        showCustomAlert('Não foi possível abrir o WhatsApp. Tente novamente.', 'error');
                    }
                }
            }, 1500);
        }
        
        /**
         * Reset completo do sistema após envio do pedido
         */
        function resetSystemAfterOrder() {
            debugLog('=== RESET COMPLETO DO SISTEMA ===');
            
            // 1. Limpar carrinho (memória e localStorage)
            cart = [];
            clearCartFromStorage(); // Limpa o localStorage do carrinho
            updateCartUI();
            
            // 2. Reset orderData
            orderData = {
                customerName: '',
                customerWhatsApp: '',
                deliveryType: '',
                address: {},
                tableNumber: '',
                paymentMethod: '',
                changeAmount: '',
                notes: ''
            };
            
            // 3. Reset taxa de delivery
            currentDeliveryFee = null;
            clearDeliveryFee();
            
            // 4. Reset todos os radio buttons
            const radioButtons = document.querySelectorAll('input[type="radio"]');
            radioButtons.forEach(radio => {
                radio.checked = false;
            });
            
            // 5. Reset todos os campos de input
            const inputs = document.querySelectorAll('input[type="text"], input[type="tel"], textarea');
            inputs.forEach(input => {
                input.value = '';
            });
            
            // 6. Ocultar campos de endereço
            const addressFields = document.getElementById('address-fields');
            if (addressFields) {
                addressFields.classList.add('hidden');
            }
            
            // 7. Reset step atual para step 1
            currentStep = 1;
            
            // 8. Reset sistema de cupons
            resetCouponSystem();
            
            // 9. Fechar checkout
            closeCheckout();
            
            debugLog('Sistema resetado completamente');
            debugLog('orderData após reset:', orderData);
            debugLog('cart após reset:', cart);
            debugLog('currentDeliveryFee após reset:', currentDeliveryFee);
        }
        
        // Send via Webhook
        function sendViaWebhook(message, webhookUrl) {
            const envioConfig = getEnvioConfig();
            const webhookToken = envioConfig.webhook_token || '';

            debugLog('=== DEBUG WEBHOOK ===');
            debugLog('Webhook URL recebido:', webhookUrl);
            debugLog('Modo envio (whatsapp_web):', envioConfig.whatsapp_web);
            debugLog('Token configurado?', webhookToken ? 'Sim' : 'Não');
            debugLog('=====================');

            if (!webhookUrl || webhookUrl.trim() === '') {
                showCustomAlert('Erro: URL do webhook não configurada. Verifique as configurações.', 'error');
                return;
            }

            try {
                const trimmed = webhookUrl.trim();
                if (!/^https?:\/\//i.test(trimmed)) {
                    showCustomAlert('Erro: URL do webhook inválida. Use o endereço completo iniciando com http(s)://', 'error');
                    return;
                }
                if (window.location.protocol === 'https:' && /^http:\/\//i.test(trimmed)) {
                    showCustomAlert('Erro: Webhook HTTP bloqueado em página HTTPS (Mixed Content). Use uma URL HTTPS para o webhook.', 'error');
                    return;
                }
            } catch (e) {
                errorLog('Validação de URL do webhook falhou:', e);
            }

            let webhookParams = {};
            let cleanWebhookUrl = webhookUrl;

            try {
                const url = new URL(webhookUrl);
                cleanWebhookUrl = `${url.protocol}//${url.host}${url.pathname}`;
                url.searchParams.forEach((value, key) => {
                    webhookParams[key] = value;
                });
                debugLog('🔗 URL limpa do webhook:', cleanWebhookUrl);
                if (Object.keys(webhookParams).length > 0) {
                    debugLog('📝 Parâmetros extraídos:', webhookParams);
                }
            } catch (error) {
                warnLog('⚠️ Erro ao extrair parâmetros da URL. Usando URL original.', error);
                cleanWebhookUrl = webhookUrl;
            }

            debugLog('Enviando webhook para:', cleanWebhookUrl);
            debugLog('Dados do pedido (orderData):', orderData);
            debugLog('Itens do carrinho:', cart);

            const thermalContactInfo = getContactInfo();
            const thermalRestaurantName = thermalContactInfo.nome || getCompanyName() || 'Restaurante';
            const thermalMessage = formatOrderMessageThermal(thermalRestaurantName);
            debugLog('Mensagem térmica gerada:', thermalMessage.substring(0, 100) + '...');

            const contactInfo = thermalContactInfo;
            const adminWhatsApp = contactInfo.whatsapp || '';

            debugLog('=== CÁLCULO DE TOTAIS PARA WEBHOOK (com cupom e taxa) ===');
            const subtotalProducts = cart.reduce((sum, item) => {
                const priceNum = parsePrice(item.preco);
                return priceNum > 0 ? sum + priceNum * item.quantity : sum;
            }, 0);
            const deliveryFee = orderData.deliveryType === 'delivery'
                ? (orderData?.address?.deliveryFee || currentDeliveryFee || 0)
                : 0;
            const totalBeforeDiscount = subtotalProducts + deliveryFee;
            const hasCoupon = !!appliedCoupon;
            const couponDiscountValue = hasCoupon ? (typeof couponDiscount === 'number' ? couponDiscount : window.couponDiscount || 0) : 0;
            const totalFinal = Math.max(totalBeforeDiscount - couponDiscountValue, 0);
            debugLog('Subtotal produtos (num):', subtotalProducts);
            debugLog('Taxa de entrega (num):', deliveryFee);
            debugLog('Total antes do desconto (num):', totalBeforeDiscount);
            debugLog('Cupom aplicado?', hasCoupon, 'Desconto (num):', (couponDiscountValue || 0));
            debugLog('Total final (num):', totalFinal);

            const timestampIso = new Date().toISOString();
            const eventId = (typeof crypto !== 'undefined' && typeof crypto.randomUUID === 'function')
                ? crypto.randomUUID()
                : `evt_${Date.now()}_${Math.floor(Math.random() * 1_000_000)}`;

            const metaInfo = {
                source: 'cardapio-sheets',
                version: APP_VERSION,
                origin: window.location.origin || null,
                user_agent: (typeof navigator !== 'undefined' && navigator?.userAgent) ? navigator.userAgent : null
            };

            const orderPayload = {
                event_id: eventId,
                whatsapp_admin: adminWhatsApp,
                whatsapp_customer: orderData.customerWhatsApp || '',
                customer_name: orderData.customerName,
                timestamp: timestampIso,
                total: totalFinal,
                whatsapp_message: message,
                formatted_message: message,
                thermal_message: thermalMessage,
                webhook_params: webhookParams,
                meta: metaInfo,
                has_variations: cart.some(item => item.variationText || item.removalText),
                has_removals: cart.some(item => item.removalText),
                total_items_with_variations: cart.filter(item => item.variationText || item.removalText).length,
                totals: {
                    subtotal_products_numeric: subtotalProducts,
                    subtotal_products_formatted: formatCurrency(subtotalProducts),
                    delivery_fee_numeric: deliveryFee,
                    delivery_fee_formatted: formatCurrency(deliveryFee),
                    total_before_discount_numeric: totalBeforeDiscount,
                    total_before_discount_formatted: formatCurrency(totalBeforeDiscount),
                    total_final_numeric: totalFinal,
                    total_final_formatted: formatCurrency(totalFinal)
                },
                coupon_applied: hasCoupon,
                coupon: hasCoupon ? {
                    code: (appliedCoupon?.codigo_cupom || appliedCoupon?.codigo || null),
                    type: ((appliedCoupon?.tipo_desconto || appliedCoupon?.tipo || '') || '').toLowerCase() || null,
                    discount_numeric: (couponDiscountValue || 0),
                    discount_formatted: formatCurrency(couponDiscountValue || 0),
                    applies_to: ((appliedCoupon?.tipo_desconto || appliedCoupon?.tipo || '') || '').toLowerCase() || null
                } : null,
                customer: {
                    name: orderData.customerName,
                    delivery_type: orderData.deliveryType,
                    table_number: orderData.tableNumber || null,
                    address: orderData.address || null,
                    payment_method: orderData.paymentMethod,
                    change_amount: (() => {
                        const rawValue = orderData.changeAmount;
                        console.log('[Supabase] change_amount RAW:', rawValue);
                        
                        if (!rawValue || rawValue === '') {
                            console.log('[Supabase] change_amount é vazio, enviando NULL');
                            return null;
                        }
                        
                        const cleanValue = String(rawValue).replace(/[^\d,.-]/g, '').replace(',', '.');
                        const numericValue = parseFloat(cleanValue);
                        
                        console.log('[Supabase] change_amount LIMPO:', cleanValue);
                        console.log('[Supabase] change_amount NUMÉRICO:', numericValue);
                        console.log('[Supabase] change_amount É VÁLIDO?', !isNaN(numericValue));
                        
                        return !isNaN(numericValue) ? numericValue : null;
                    })(),
                    notes: orderData.notes || null
                },
                items: cart.map(item => ({
                    id: item.id,
                    name: item.nome,
                    sku: item.sku,
                    price: item.preco,
                    price_numeric: parsePrice(item.preco),
                    quantity: item.quantity,
                    subtotal: parsePrice(item.preco) > 0 ? parsePrice(item.preco) * item.quantity : 0,
                    subtotal_numeric: parsePrice(item.preco) > 0 ? parsePrice(item.preco) * item.quantity : 0,
                    variations_text: item.variationText || null,
                    removal_text: item.removalText || null,
                    variations_detailed: item.variations || null,
                    variations: item.variationText || null,
                    notes: item.notes || null
                })),
                currency: getCurrentCurrency()
            };

            debugLog('Payload do webhook:', JSON.stringify(orderPayload, null, 2));

            if (Object.keys(webhookParams).length > 0) {
                debugLog('=== PARÂMETROS DA URL ===');
                Object.entries(webhookParams).forEach(([key, value]) => {
                    debugLog(`🔑 ${key}: ${value}`);
                });
                debugLog('========================');
            } else {
                debugLog('📝 Nenhum parâmetro adicional encontrado na URL do webhook');
            }

            debugLog('=== RESUMO DAS VARIAÇÕES ===');
            debugLog('📊 Tem variações:', orderPayload.has_variations);
            debugLog('🚫 Tem remoções:', orderPayload.has_removals);
            debugLog('📝 Itens com variações:', orderPayload.total_items_with_variations);
            orderPayload.items.forEach((item, index) => {
                if (item.variations_text || item.removal_text) {
                    debugLog(`🍽️ Item ${index + 1}: ${item.name}`);
                    if (item.variations_text) debugLog('  ➕ Adições:', item.variations_text);
                    if (item.removal_text) debugLog('  🚫 Remoções:', item.removal_text);
                    if (item.variations_detailed) debugLog('  🔍 Detalhado:', item.variations_detailed);
                }
            });
            debugLog('================================');

            showCustomAlert('Enviando pedido...', 'info');

            const postHeaders = {
                'Content-Type': 'application/json',
                'X-Requested-With': 'CardapioSheets',
                'X-Webhook-Event': eventId,
                'X-Cardapio-Version': APP_VERSION
            };

            if (webhookToken) {
                postHeaders.Authorization = `Bearer ${webhookToken}`;
            }

            const postRequestOptions = {
                method: 'POST',
                headers: postHeaders,
                body: JSON.stringify(orderPayload),
                mode: 'cors',
                keepalive: true,
                credentials: 'omit'
            };

            function sendPostRequest() {
                debugLog('📤 Enviando requisição POST para o webhook (JSON)');
                return fetch(cleanWebhookUrl, postRequestOptions).then(async response => {
                    const contentType = response.headers?.get ? response.headers.get('content-type') || '' : '';
                    let responseBody = null;
                    try {
                        if (contentType.includes('application/json')) {
                            responseBody = await response.json();
                        } else {
                            responseBody = await response.text();
                        }
                    } catch (parseError) {
                        debugLog('Não foi possível interpretar a resposta do webhook:', parseError);
                    }

                    debugLog('📬 Resposta do webhook POST:', response.status, responseBody);

                    if (!response.ok) {
                        const errorMessage = (responseBody && typeof responseBody === 'object' && responseBody.message)
                            ? responseBody.message
                            : (typeof responseBody === 'string' && responseBody.trim() ? responseBody : `HTTP ${response.status}`);
                        throw new Error(errorMessage);
                    }

                    return responseBody;
                });
            }

            function executeGetFallback() {
                debugLog('⚙️ Executando fallback GET para o webhook');

                const params = new URLSearchParams();
                params.append('data', JSON.stringify(orderPayload));
                params.append('whatsapp_admin', adminWhatsApp);
                const customerWhatsAppDigits = (orderData.customerWhatsApp || '').replace(/\D/g, '');
                params.append('whatsapp_customer', customerWhatsAppDigits);
                params.append('customer_name', orderData.customerName);
                params.append('timestamp', timestampIso);
                params.append('total', totalFinal);
                params.append('total_final', totalFinal);
                params.append('total_before_discount', totalBeforeDiscount);
                params.append('subtotal_products', subtotalProducts);
                params.append('delivery_fee', deliveryFee);
                if (hasCoupon) {
                    params.append('coupon_code', (appliedCoupon?.codigo_cupom || appliedCoupon?.codigo || ''));
                    params.append('coupon_type', ((appliedCoupon?.tipo_desconto || appliedCoupon?.tipo || '') || '').toLowerCase());
                    params.append('coupon_discount', (couponDiscountValue || 0));
                }
                params.append('message', message);
                debugLog('📝 Mensagem adicionada como variável separada (GET fallback):', message.substring(0, 100) + '...');

                const replicateWebhookParamsInQuery = false;
                if (replicateWebhookParamsInQuery && Object.keys(webhookParams).length > 0) {
                    debugLog('🔑 Replicando parâmetros da URL na query (habilitado)');
                    Object.entries(webhookParams).forEach(([key, value]) => {
                        params.append(key, value);
                        debugLog(`  ✔️ ${key}: ${value}`);
                    });
                }

                let finalUrl = `${cleanWebhookUrl}?${params.toString()}`;
                debugLog('📍 URL GET (tamanho):', finalUrl.length);
                if (finalUrl.length > 7500) {
                    debugLog('⚠️ URL do webhook muito longa (', finalUrl.length, 'chars). Removendo parâmetro "message" da query...');
                    params.delete('message');
                    finalUrl = `${cleanWebhookUrl}?${params.toString()}`;
                    debugLog('📍 URL otimizada (tamanho):', finalUrl.length);
                }

                debugLog('📍 URL GET final:', finalUrl);

                try {
                    const dataParam = params.get('data');
                    const parsedData = JSON.parse(dataParam);
                    debugLog('  ✔️ Payload em data:', parsedData);
                    debugLog('  ✔️ webhook_params presente:', 'webhook_params' in parsedData);
                    debugLog('  ✔️ Conteúdo de webhook_params:', parsedData.webhook_params);
                } catch (parseErr) {
                    errorLog('  ❌ Erro ao analisar JSON em data:', parseErr);
                }

                return fetch(finalUrl, {
                    method: 'GET',
                    mode: 'no-cors',
                    cache: 'no-cache',
                    keepalive: true
                })
                    .then(response => {
                        debugLog('📬 Resposta do webhook GET:', response);
                        debugLog('ℹ️ Modo no-cors: não é possível ler o status da resposta');
                        debugLog('🚨 DEBUG: Requisição GET enviada para:', cleanWebhookUrl);
                        debugLog('🚨 DEBUG: Payload completo enviado:', orderPayload);
                        debugLog('🚨 DEBUG: webhook_params enviado:', orderPayload.webhook_params);
                        debugLog('🚨 DEBUG: Parâmetros adicionados diretamente à URL:');
                        debugLog('  ✔️ whatsapp_admin:', adminWhatsApp);
                        debugLog('  ✔️ whatsapp_customer:', orderData.customerWhatsApp || '');
                        debugLog('  ✔️ customer_name:', orderData.customerName);
                        debugLog('  ✔️ total:', typeof totalFinal !== 'undefined' ? totalFinal : '(indisponível)');
                        debugLog('  ✔️ message: [MENSAGEM COMPLETA ENVIADA COMO VARIÁVEL SEPARADA]');
                        Object.entries(webhookParams).forEach(([key, value]) => {
                            debugLog(`  ✔️ ${key}: ${value}`);
                        });

                        setTimeout(() => {
                            showCustomAlert('Pedido enviado com sucesso!', 'success');
                            resetSystemAfterOrder();
                        }, 1000);
                    })
                    .catch(error => {
                        errorLog('Erro no envio via GET:', error);
                        const isFailedToFetch = error?.name === 'TypeError' && error?.message?.includes('Failed to fetch');
                        const isAbort = error?.message?.includes('ERR_ABORTED') || error?.name === 'AbortError';
                        if (isFailedToFetch) {
                            showCustomAlert('Erro de conexão: Não foi possível enviar o pedido. Verifique a URL do webhook.', 'error');
                        } else if (!isAbort) {
                            showCustomAlert(`Erro ao enviar pedido: ${error.message}`, 'error');
                        }
                    });
            }

            sendPostRequest()
                .then(responseBody => {
                    let successMessage = 'Pedido enviado com sucesso!';
                    if (responseBody && typeof responseBody === 'object' && responseBody.message) {
                        successMessage = responseBody.message;
                    } else if (typeof responseBody === 'string' && responseBody.trim()) {
                        successMessage = responseBody;
                    }

                    showCustomAlert(successMessage, 'success');
                    resetSystemAfterOrder();
                })
                .catch(error => {
                    warnLog('Erro no envio via POST:', error);
                    const isNetworkError = error?.name === 'TypeError' || (error?.message && error.message.includes('Failed to fetch'));

                    if (isNetworkError) {
                        warnLog('Tentando fallback via GET devido a erro de rede/CORS');
                        showCustomAlert('Conexão instável, tentando método alternativo...', 'warning');
                        executeGetFallback();
                        return;
                    }

                    showCustomAlert(`Erro ao enviar pedido: ${error.message}`, 'error');
                });
        }

        // Scroll to category
        function scrollToCategory(category) {
            
            // Wait for data to be loaded and DOM to be ready
            if (!isDataLoaded) {
                setTimeout(() => scrollToCategory(category), 200);
                return;
            }
            
            // Desabilitar scroll spy temporariamente para evitar conflitos
            disableScrollSpyTemporarily();
            
            // Update active category immediately for better UX
            updateActiveCategory(category);
            
            // Perform scroll without additional delay
            requestAnimationFrame(() => {
                // Function to perform the scroll with multiple fallback strategies
                function performScroll() {
                    // Strategy 1: Try exact ID match
                    let section = document.getElementById(category);
                    
                    // Strategy 2: If not found, try to find by data-category in sections
                    if (!section) {
                        section = document.querySelector(`section[data-category="${category}"]`);
                    }
                    
                    // Strategy 3: Try to find section containing items with matching category
                    if (!section) {
                        const categoryItem = document.querySelector(`[data-category="${category}"]`);
                        if (categoryItem) {
                            // Look for a section that might contain this category's items
                            const allSections = document.querySelectorAll('section[id]');
                            for (const sec of allSections) {
                                if (sec.id === category || sec.id.includes(category) || category.includes(sec.id)) {
                                    section = sec;
                                    break;
                                }
                            }
                        }
                    }
                    
                    if (section) {
                        const offset = 150; // Account for sticky headers
                        const elementPosition = section.offsetTop - offset;
                        window.scrollTo({ 
                            top: Math.max(0, elementPosition), 
                            behavior: 'smooth' 
                        });
                        return true;
                    }
                    return false;
                }
                
                // Try immediate scroll
                if (performScroll()) {
                    return;
                }
                
                // If section not found, try multiple retries
                let retryCount = 0;
                const maxRetries = 5;
                
                function retryScroll() {
                    if (retryCount >= maxRetries) {
                        // Final fallback: scroll to first section if category exists in menu
                        const firstSection = document.querySelector('section[id]');
                        if (firstSection) {
                            window.scrollTo({ top: firstSection.offsetTop - 150, behavior: 'smooth' });
                        }
                        return;
                    }
                    
                    retryCount++;
                    const delay = retryCount * 200; // 200ms, 400ms, 600ms, etc.
                    
                    setTimeout(() => {
                        if (!performScroll()) {
                            retryScroll();
                        }
                    }, delay);
                }
                
                retryScroll();
            }, 100); // Initial delay to ensure DOM rendering
        }

        // SCROLL SPY DEFINITIVO - Técnica tradicional e confiável
        let scrollSpyEnabled = true;
        let scrollSpyTimeout = null;
        let currentActiveCategory = null;
        
        function setupScrollSpy() {
            // Event listener de scroll otimizado
            let ticking = false;
            
            function updateScrollSpy() {
                // 🔍 DEBUG: Verificar se scroll spy está habilitado
                if (!scrollSpyEnabled) {
                    debugLog('🚫 updateScrollSpy: BLOQUEADO (scrollSpyEnabled = false)');
                    ticking = false;
                    return;
                }
                
                debugLog('🔍 updateScrollSpy: EXECUTANDO (scrollSpyEnabled = true)');
                
                // Calcular offset do header + menu
                const header = document.querySelector('header');
                const nav = document.getElementById('category-nav');
                const headerHeight = header ? header.offsetHeight : 0;
                const navHeight = nav ? nav.offsetHeight : 0;
                const totalOffset = headerHeight + navHeight + 20; // 20px margem
                
                const scrollPosition = window.scrollY + totalOffset;
                debugLog('📍 Posição do scroll:', scrollPosition);
                
                // Pegar todas as seções ativas
                const sections = categoriesData
                    .filter(cat => cat.status === 'Ativo')
                    .map(cat => {
                        const element = document.getElementById(cat.nome_categoria);
                        if (element) {
                            return {
                                name: cat.nome_categoria,
                                element: element,
                                top: element.offsetTop,
                                bottom: element.offsetTop + element.offsetHeight
                            };
                        }
                        return null;
                    })
                    .filter(section => section !== null)
                    .sort((a, b) => a.top - b.top);
                
                if (sections.length === 0) return;
                
                let activeSection = null;
                
                // Se estiver no topo da página, ativar primeira seção
                if (window.scrollY < 100) {
                    activeSection = sections[0].name;
                } else {
                    // Encontrar a seção ativa baseada na posição do scroll
                    for (let i = sections.length - 1; i >= 0; i--) {
                        if (scrollPosition >= sections[i].top) {
                            activeSection = sections[i].name;
                            break;
                        }
                    }
                    
                    // Se não encontrou nenhuma, usar a primeira
                    if (!activeSection) {
                        activeSection = sections[0].name;
                    }
                }
                
                // 🔍 DEBUG: Verificar detecção de categoria ativa
                debugLog('🎯 Categoria detectada pelo scroll:', activeSection);
                debugLog('📏 Categoria atual armazenada:', currentActiveCategory);
                debugLog('⚖️ Comparação (activeSection !== currentActiveCategory):', activeSection !== currentActiveCategory);
                
                // Só atualizar se mudou
                if (activeSection && activeSection !== currentActiveCategory) {
                    debugLog('✅ MUDOU! Atualizando categoria de', currentActiveCategory, 'para', activeSection);
                    currentActiveCategory = activeSection;
                    updateActiveCategory(activeSection);
                } else {
                    debugLog('🚫 NÃO MUDOU - mantendo categoria atual:', currentActiveCategory);
                }
                
                ticking = false;
            }
            
            function onScroll() {
                debugLog('📜 onScroll chamada - ticking:', ticking);
                if (!ticking) {
                    requestAnimationFrame(updateScrollSpy);
                    ticking = true;
                }
            }
            
            // Adicionar event listener
            window.addEventListener('scroll', onScroll, { passive: true });
            
            // Executar uma vez para definir estado inicial
            setTimeout(updateScrollSpy, 100);
        }
        
        // Desabilitar scroll spy temporariamente após cliques
        function disableScrollSpyTemporarily() {
            debugLog('🚫 Scroll spy DESABILITADO temporariamente');
            scrollSpyEnabled = false;
            if (scrollSpyTimeout) {
                clearTimeout(scrollSpyTimeout);
                debugLog('⏰ Timeout anterior cancelado');
            }
            scrollSpyTimeout = setTimeout(() => {
                scrollSpyEnabled = true;
                debugLog('✅ Scroll spy REABILITADO após 1.5s');
                debugLog('🔄 Estado atual scrollSpyEnabled:', scrollSpyEnabled);
            }, 1500); // 1.5 segundos
            debugLog('⏱️ Novo timeout de 1.5s iniciado');
        }

        // Atualizar categoria ativa - VERSÃO CORRIGIDA
        function updateActiveCategory(category) {
            // ✅ CORREÇÃO CRÍTICA: Atualizar variável de controle do scroll spy
            // Isso resolve o bug onde scroll spy "trava" após clicar em categoria
            currentActiveCategory = category;
            
            // Remover classe active de todos os botões
            document.querySelectorAll('.category-item').forEach(item => {
                item.classList.remove('active');
            });
            
            // Adicionar classe active no botão correspondente
            const activeButton = document.querySelector(`[data-category="${category}"]`);
            if (activeButton) {
                activeButton.classList.add('active');
                
                // Centralizar botão ativo no scroll horizontal
                activeButton.scrollIntoView({
                    behavior: 'smooth',
                    block: 'nearest',
                    inline: 'center'
                });
            }
            
            // 🐛 DEBUG: Log para verificar se categoria foi atualizada corretamente
            debugLog('🎯 Categoria ativa sincronizada:', category);
        }

        // Função removida - agora usamos scrollIntoView nativo

        // Setup search
        function setupSearch() {
            const searchInput = document.getElementById('search');
            const clearBtn = document.getElementById('clear-search');
            
            // Verificação defensiva - elementos devem existir
            if (!searchInput) {
                if (typeof warnLog === 'function') warnLog('⚠️ Search input element not found');
                return;
            }
            
            if (!clearBtn) {
                if (typeof warnLog === 'function') warnLog('⚠️ Clear search button element not found');
                return;
            }
            
            // Search on input
            searchInput.addEventListener('input', (e) => {
                const query = e.target.value.trim();
                
                // Show/hide clear button
                if (query.length > 0) {
                    clearBtn.classList.remove('hidden');
                } else {
                    clearBtn.classList.add('hidden');
                }
                
                performSearchWithQuery(query);
            });
            
            // Search on Enter key
            searchInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    performSearch();
                }
            });
            
            if (typeof debugLog === 'function') debugLog('✅ Search functionality initialized');
        }
        
        // Perform search
        function performSearch() {
            const searchInput = document.getElementById('search');
            
            // Verificação defensiva - elemento deve existir
            if (!searchInput) {
                if (typeof warnLog === 'function') warnLog('⚠️ Search input element not found in performSearch');
                return;
            }
            
            const query = searchInput.value.trim().toLowerCase();
            
            if (query.length === 0) {
                showToast('Digite algo para pesquisar', 'warning', 2000);
                searchInput.focus();
                return;
            }
            
            performSearchWithQuery(query);
            
            // Show feedback
            const results = document.querySelectorAll('.food-card:not([style*="display: none"])').length;
            if (results === 0) {
                showToast('Nenhum prato encontrado para sua busca', 'warning', 3000);
            } else {
                showToast(`${results} prato${results > 1 ? 's' : ''} encontrado${results > 1 ? 's' : ''}`, 'success', 2000);
            }
        }
        
        // Perform search with query
        function performSearchWithQuery(query) {
            const searchQuery = query.toLowerCase().trim();
            const cards = document.querySelectorAll('.food-card');
            
            if (cards.length === 0) {
                console.warn('Nenhum card encontrado para busca');
                return;
            }
            
            let visibleCount = 0;
            cards.forEach(card => {
                try {
                    // Buscar por múltiplos seletores para maior compatibilidade
                    const nameElement = card.querySelector('h3') || card.querySelector('.font-semibold');
                    const descElement = card.querySelector('p') || card.querySelector('.description');
                    const skuElement = card.querySelector('.text-xs') || card.querySelector('.font-mono');
                    
                    let shouldShow = false;
                    
                    // Se query está vazia, mostrar todos
                    if (searchQuery === '') {
                        shouldShow = true;
                    } else {
                        // Buscar no nome
                        if (nameElement && nameElement.textContent.toLowerCase().includes(searchQuery)) {
                            shouldShow = true;
                        }
                        
                        // Buscar na descrição
                        if (!shouldShow && descElement && descElement.textContent.toLowerCase().includes(searchQuery)) {
                            shouldShow = true;
                        }
                        
                        // Buscar no SKU
                        if (!shouldShow && skuElement && skuElement.textContent.toLowerCase().includes(searchQuery)) {
                            shouldShow = true;
                        }
                        
                        // Buscar em todo o texto do card como fallback
                        if (!shouldShow && card.textContent.toLowerCase().includes(searchQuery)) {
                            shouldShow = true;
                        }
                    }
                    
                    // Aplicar visibilidade
                    if (shouldShow) {
                        card.style.display = 'block';
                        card.style.opacity = '1';
                        visibleCount++;
                    } else {
                        card.style.display = 'none';
                        card.style.opacity = '0';
                    }
                    
                } catch (error) {
                    errorLog('Erro ao processar card na busca:', error);
                    // Em caso de erro, manter o card visível
                    card.style.display = 'block';
                    card.style.opacity = '1';
                }
            });
            
            // Ocultar categorias vazias
            hideEmptyCategories(searchQuery);
            
            // Atualizar contadores e feedback visual
            updateSearchResults(visibleCount, searchQuery);
        }
        
        // Hide empty categories during search
        function hideEmptyCategories(searchQuery) {
            const sections = document.querySelectorAll('section[id]:not(#google-reviews-section)');
            
            sections.forEach(section => {
                try {
                    // Encontrar todos os cards visíveis nesta seção
                    const visibleCards = section.querySelectorAll('.food-card[style*="display: block"], .food-card:not([style*="display: none"])');
                    
                    // Se não há query de busca, mostrar todas as seções
                    if (!searchQuery || searchQuery.trim() === '') {
                        section.style.display = 'block';
                        section.style.opacity = '1';
                    } else {
                        // Se há query mas nenhum card visível, ocultar a seção
                        if (visibleCards.length === 0) {
                            section.style.display = 'none';
                            section.style.opacity = '0';
                        } else {
                            section.style.display = 'block';
                            section.style.opacity = '1';
                        }
                    }
                } catch (error) {
                    if (typeof errorLog === 'function') errorLog('Erro ao processar seção na busca:', error);
                    // Em caso de erro, manter a seção visível
                    section.style.display = 'block';
                    section.style.opacity = '1';
                }
            });
        }
        
        // Update search results feedback
        function updateSearchResults(visibleCount, query) {
            if (query && query.length > 0) {
                if (visibleCount === 0) {
                    showToast('Nenhum prato encontrado para sua busca', 'warning', 3000);
                } else {
                    showToast(`${visibleCount} prato${visibleCount > 1 ? 's' : ''} encontrado${visibleCount > 1 ? 's' : ''}`, 'success', 2000);
                }
            }
        }
        
        // Clear search
        function clearSearch() {
            const searchInput = document.getElementById('search');
            const clearBtn = document.getElementById('clear-search');
            
            // Verificação defensiva - elementos devem existir
            if (!searchInput) {
                if (typeof warnLog === 'function') warnLog('⚠️ Search input element not found in clearSearch');
                return;
            }
            
            if (!clearBtn) {
                if (typeof warnLog === 'function') warnLog('⚠️ Clear search button element not found in clearSearch');
                return;
            }
            
            searchInput.value = '';
            clearBtn.classList.add('hidden');
            
            // Show all items with improved reset
            document.querySelectorAll('.food-card').forEach(card => {
                card.style.display = 'block';
                card.style.opacity = '1';
            });
            
            // Mostrar todas as categorias
            hideEmptyCategories('');
            
            showToast('Busca limpa! Mostrando todos os pratos', 'success', 2000);
            searchInput.focus();
        }

        // Find product by ID
        function findProductById(id) {
            for (const category of Object.values(menuData)) {
                const product = category.find(item => item.id === id);
                if (product) return product;
            }
            return null;
        }

        // Share general page
        function shareGeneral() {
            const url = window.location.href.split('#')[0];
            const companyName = getCompanyName();
            const slogan = getSlogan();
            const text = `🍽️ Confira o cardápio do ${companyName} - ${slogan}!`;
            const shareText = `${text}\n${url}`;
            
            navigator.clipboard.writeText(shareText).then(() => {
                showToast('📋 Link do cardápio copiado! Cole e compartilhe com seus amigos', 'success', 3000);
            }).catch(() => {
                // Fallback se clipboard não funcionar
                showToast('❌ Não foi possível copiar automaticamente', 'error', 2000);
                setTimeout(() => {
                    prompt('Copie o link manualmente:', url);
                }, 500);
            });
        }

        // Share specific category
        function shareCategory(category) {
            // Get category display name from dynamic data
            const categoryData = categoriesData.find(cat => cat.nome_categoria === category);
            const categoryName = categoryData ? categoryData.titulo_exibicao : category;
            const companyName = getCompanyName();
            
            const url = `${window.location.href.split('#')[0]}#${category}`;
            const text = `🍽️ Confira ${categoryName} do ${companyName}!`;
            const shareText = `${text}\n${url}`;
            
            navigator.clipboard.writeText(shareText).then(() => {
                showToast(`📋 Link de ${categoryName} copiado! Compartilhe!`, 'success', 3000);
            }).catch(() => {
                // Fallback se clipboard não funcionar
                showToast('❌ Não foi possível copiar automaticamente', 'error', 2000);
                setTimeout(() => {
                    prompt('Copie o link da categoria:', url);
                }, 500);
            });
        }

        // Handle initial hash navigation
        function handleInitialHash() {
            const hash = window.location.hash.substring(1);
            if (hash && categoriesData) {
                const validCategories = categoriesData
                    .filter(cat => cat.status === 'Ativo')
                    .map(cat => cat.nome_categoria);
                
                if (validCategories.includes(hash)) {
                    setTimeout(() => {
                        scrollToCategory(hash);
                    }, 1000); // Increased delay to ensure data is loaded
                }
            }
        }

        // Scroll field to center when focused (mobile keyboard fix)
        function scrollToField(field) {
            // Apply visual focus styles
            field.style.borderColor = 'var(--cor-primaria)';
            field.style.outline = '2px solid var(--cor-primaria)';
            field.style.outlineOffset = '2px';
            
            setTimeout(() => {
                // Find the modal container with overflow-y-auto
                const modalContainer = document.querySelector('#product-modal .overflow-y-auto');
                if (!modalContainer) {
                    if (typeof debugLog === 'function') debugLog('❌ Product modal container not found');
                    return;
                }
                
                // Get field position relative to modal container
                const fieldRect = field.getBoundingClientRect();
                const containerRect = modalContainer.getBoundingClientRect();
                const fieldHeight = fieldRect.height;
                const containerHeight = containerRect.height;
                
                // Calculate relative position within the modal
                const fieldTopInModal = fieldRect.top - containerRect.top + modalContainer.scrollTop;
                
                // Calculate position to center the field in visible area, accounting for mobile keyboard
                const viewportHeight = window.innerHeight;
                const keyboardHeight = viewportHeight * 0.4; // Estimate keyboard height (40% of viewport)
                const availableHeight = Math.min(containerHeight, viewportHeight - keyboardHeight);
                const targetScrollPosition = fieldTopInModal - (availableHeight / 2) + (fieldHeight / 2);
                
                // Smooth scroll within modal container
                modalContainer.scrollTo({
                    top: Math.max(0, targetScrollPosition),
                    behavior: 'smooth'
                });
                
                if (typeof debugLog === 'function') debugLog('📝 Product notes field focused and centered within modal');
            }, 300); // Delay to allow keyboard to appear
        }

        // Reset modal scroll when field loses focus
        function resetModalScroll() {
            // Reset visual styles
            const field = document.getElementById('product-notes');
            if (field) {
                field.style.borderColor = '';
                field.style.outline = 'none';
            }
            
            setTimeout(() => {
                const modalContainer = document.querySelector('#product-modal .overflow-y-auto');
                if (!modalContainer) return;
                
                // Smooth scroll back to top of modal
                modalContainer.scrollTo({
                    top: 0,
                    behavior: 'smooth'
                });
                
                if (typeof debugLog === 'function') debugLog('🔄 Product modal scroll reset');
            }, 100);
        }

        // Open lightbox
        function openLightbox(imageSrc, title) {
            const lightbox = document.getElementById('image-lightbox');
            const lightboxImage = document.getElementById('lightbox-image');
            const lightboxTitle = document.getElementById('lightbox-title');
            
            lightboxImage.src = imageSrc;
            lightboxTitle.textContent = title;
            
            lightbox.classList.remove('hidden');
            
            // Prevent body scroll
            document.body.style.overflow = 'hidden';
        }

        // Close lightbox
        function closeLightbox(event) {
            if (event && event.target !== event.currentTarget && !event.target.closest('button')) {
                return;
            }
            
            const lightbox = document.getElementById('image-lightbox');
            lightbox.classList.add('hidden');
            
            // Restore body scroll
            document.body.style.overflow = '';
        }

        // Close lightbox on ESC key
        document.addEventListener('keydown', function(event) {
            if (event.key === 'Escape') {
                const lightbox = document.getElementById('image-lightbox');
                if (!lightbox.classList.contains('hidden')) {
                    closeLightbox();
                }
            }
        });

        // Operating Hours Functions
        async function updateOperatingHours() {
            try {
                // Fetch CSV data directly for real-time updates
                const response = await fetch(HOURS_CSV_URL);
                const csvText = await response.text();
                
                // Parse CSV manually
                const lines = csvText.trim().split('\n');
                
                // Usar timezone global do config.js
                const timezone = globalTimezone;
                debugLog('🕰️ Timezone usado para horários:', timezone);
                
                const headers = lines[0].split(','); // Use first line as headers
                
                // Get current time using global timezone functions
                const timezoneDate = getCurrentDateInTimezone();
                const dayOfWeek = getDayOfWeekInPortuguese(timezoneDate.getDay());
                const currentTime = timezoneDate.getHours() * 60 + timezoneDate.getMinutes(); // Convert to minutes
                
                debugLog('- Data/hora atual:', formatDateInTimezone(timezoneDate));
                debugLog('- Dia da semana:', dayOfWeek);
                debugLog('- Horário em minutos:', currentTime);
                
                // Find today's schedule from CSV data
                let todaySchedule = null;
                debugLog('- Procurando cronograma para:', dayOfWeek);
                
                for (let i = 1; i < lines.length; i++) { // Mudança: começar da linha 1
                    const values = lines[i].split(',');
                    const dayName = values[0];
                    debugLog(`  - Linha ${i}: ${dayName} (comparando com ${dayOfWeek})`);
                    
                    if (dayName && dayName.toLowerCase().trim() === dayOfWeek.toLowerCase()) {
                        todaySchedule = {
                            day: dayName,
                            period1: values[1],
                            period2: values[2],
                            period3: values[3]
                        };
                        debugLog('- Cronograma encontrado:', todaySchedule);
                        break;
                    }
                }
                
                if (!todaySchedule) {
                    errorLog('❌ Nenhum cronograma encontrado para hoje:', dayOfWeek);
                    return;
                }
                
                debugLog('🔍 Verificando se está aberto...');
                let isOpen = checkIfOpenFromPeriods(todaySchedule, currentTime);
                let nextCloseTime = getNextCloseTimeFromPeriods(todaySchedule, currentTime);

                if (!isOpen) {
                    const carryoverStatus = getPreviousDayCarryoverStatus(lines, dayOfWeek, currentTime);
                    if (carryoverStatus.isOpen) {
                        isOpen = true;
                        nextCloseTime = carryoverStatus.nextCloseTime;
                        debugLog('🔁 Aberto por período que atravessa a meia-noite do dia anterior');
                    }
                }

                debugLog('- Status:', isOpen ? 'ABERTO' : 'FECHADO');
                debugLog('- Próximo fechamento:', nextCloseTime || 'N/A');
                
                // Update status indicator
                const statusText = document.getElementById('status-text');
                const hoursText = document.getElementById('hours-text');
                const statusDot = document.getElementById('status-dot');
                
                if (statusText && hoursText) {
                    // Limpar texto antes de adicionar emoji para evitar duplicação
                    const baseText = isOpen ? 'Aberto' : 'Fechado';
                    const emoji = isOpen ? '🟢' : '🔴';
                    
                    statusText.textContent = `${emoji} ${baseText}`;
                    statusText.className = 'font-medium';
                    statusText.style.color = isOpen ? 'var(--cor-sucesso)' : 'var(--cor-erro)';
                    
                    // Remover referência ao statusDot que não existe mais
                    // statusDot removido - usando apenas emoji
                    
                    if (isOpen && nextCloseTime) {
                        hoursText.textContent = `até ${nextCloseTime}`;
                    } else if (!isOpen) {
                        const nextOpenTime = getNextOpenTimeFromPeriods(todaySchedule, currentTime);
                        if (nextOpenTime) {
                            hoursText.textContent = `Abre às ${nextOpenTime}`;
                        } else {
                            hoursText.textContent = 'Hoje';
                        }
                    } else {
                        hoursText.textContent = dayOfWeek;
                    }
                }
                
            } catch (error) {
                errorLog('Error updating operating hours:', error);
                // Fallback to static display
                const statusText = document.getElementById('status-text');
                const hoursText = document.getElementById('hours-text');
                
                if (statusText && hoursText) {
                    // Fallback com emoji limpo
                    statusText.textContent = '🟢 Aberto';
                    statusText.className = 'font-medium';
                    statusText.style.color = 'var(--cor-sucesso)';
                    hoursText.textContent = 'até 23h';
                }
            }
        }

        function getDayOfWeekInPortuguese(dayIndex) {
            const days = [
                'domingo', 'segunda-feira', 'terça-feira', 'quarta-feira',
                'quinta-feira', 'sexta-feira', 'sábado'
            ];
            return days[dayIndex];
        }

        function getPreviousDayName(dayName) {
            if (!dayName) return null;
            const days = [
                'domingo', 'segunda-feira', 'terça-feira', 'quarta-feira',
                'quinta-feira', 'sexta-feira', 'sábado'
            ];
            const normalized = dayName.toLowerCase();
            const index = days.indexOf(normalized);
            if (index === -1) return null;
            const prevIndex = (index + 6) % 7;
            return days[prevIndex];
        }

        function timeToMinutes(timeStr) {
            if (!timeStr) return 0;
            const [hours, minutes] = timeStr.split(':').map(Number);
            return hours * 60 + minutes;
        }

        function minutesToTime(minutes) {
            const hours = Math.floor(minutes / 60);
            const mins = minutes % 60;
            return `${hours.toString().padStart(2, '0')}:${mins.toString().padStart(2, '0')}`;
        }

        /**
         * Faz o parsing de um período textual (ex: "23:00-04:00")
         * e indica se atravessa a meia-noite.
         */
        function parsePeriodString(periodStr) {
            if (!periodStr || typeof periodStr !== 'string') {
                return null;
            }

            const sanitized = periodStr.replace(/\s+/g, '');
            const parts = sanitized.split('-');

            if (parts.length !== 2) {
                return null;
            }

            const start = timeToMinutes(parts[0]);
            const end = timeToMinutes(parts[1]);

            if (Number.isNaN(start) || Number.isNaN(end)) {
                return null;
            }

            return {
                start,
                end,
                crossesMidnight: end <= start
            };
        }

        /**
         * Verifica se o horário atual (em minutos) está dentro do período informado.
         */
        function isTimeWithinPeriod(currentTime, period) {
            if (!period) return false;

            if (!period.crossesMidnight) {
                return currentTime >= period.start && currentTime < period.end;
            }

            // Quando atravessa a meia-noite, aceita valores após o início OU antes do fim
            return currentTime >= period.start || currentTime < period.end;
        }

        function formatMinutesAsHourLabel(minutes) {
            const hours = Math.floor(minutes / 60);
            const remaining = minutes % 60;
            if (remaining === 0) {
                return `${hours}h`;
            }
            return `${hours}h${remaining.toString().padStart(2, '0')}`;
        }

        function getPreviousDayCarryoverStatus(lines, currentDayName, currentTime) {
            const previousDay = getPreviousDayName(currentDayName);
            if (!previousDay) {
                return { isOpen: false, nextCloseTime: null };
            }

            for (let i = 1; i < lines.length; i++) {
                const line = lines[i];
                if (!line || line.trim() === '') continue;

                const values = line.split(',').map(v => v.trim());
                const dayName = values[0];

                if (dayName && dayName.toLowerCase() === previousDay) {
                    for (let j = 1; j < values.length; j++) {
                        const periodString = values[j];
                        if (!periodString) continue;

                        const period = parsePeriodString(periodString);
                        if (period && period.crossesMidnight && currentTime < period.end) {
                            const nextClose = period.end === 0 ? '00h' : formatMinutesAsHourLabel(period.end);
                            return { isOpen: true, nextCloseTime: nextClose };
                        }
                    }
                    break;
                }
            }

            return { isOpen: false, nextCloseTime: null };
        }

        function checkIfOpen(schedule, currentTime) {
            // Get time periods - new format with Período 1, 2, 3
            const periods = [
                schedule['Período 1'] || schedule['Período 1 '] || schedule[' Período 1'] || schedule[' Período 1 '],
                schedule['Período 2'] || schedule['Período 2 '] || schedule[' Período 2'] || schedule[' Período 2 '],
                schedule['Período 3'] || schedule['Período 3 '] || schedule[' Período 3'] || schedule[' Período 3 ']
            ];
            
            // Check all periods
            for (const periodTime of periods) {
                if (periodTime && periodTime.trim() && periodTime.trim() !== '') {
                    const period = parsePeriodString(periodTime);
                    if (isTimeWithinPeriod(currentTime, period)) {
                        return true;
                    }
                }
            }
            return false;
        }
        
        function checkIfOpenFromPeriods(schedule, currentTime) {
            // Get time periods from CSV format
            const periods = [schedule.period1, schedule.period2, schedule.period3];
            
            debugLog('🔍 checkIfOpenFromPeriods - Verificando se está aberto:');
            debugLog(`  - Horário atual: ${Math.floor(currentTime/60)}:${String(currentTime%60).padStart(2,'0')} (${currentTime} minutos)`);
            debugLog('  - Períodos:', periods);
            
            // Check all periods
            for (let i = 0; i < periods.length; i++) {
                const periodTime = periods[i];
                if (periodTime && periodTime.trim() && periodTime.trim() !== '') {
                    debugLog(`  - Verificando período ${i+1}: "${periodTime}"`);

                    const period = parsePeriodString(periodTime);
                    if (!period) {
                        debugLog(`    - ⚠️ Formato inválido: "${periodTime}"`);
                        continue;
                    }

                    debugLog(`    - Início: ${minutesToTime(period.start)} (${period.start} min)`);
                    debugLog(`    - Fim: ${minutesToTime(period.end)} (${period.end} min)`);
                    debugLog(`    - Atravessa meia-noite? ${period.crossesMidnight}`);

                    const isInPeriod = isTimeWithinPeriod(currentTime, period);
                    debugLog(`    - Resultado: ${isInPeriod}`);

                    if (isInPeriod) {
                        debugLog(`  ✅ ABERTO - Dentro do período ${i+1}`);
                        return true;
                    }
                }
            }
            debugLog('  ❌ FECHADO - Fora de todos os períodos');
            return false;
        }

        function getNextCloseTime(schedule, currentTime) {
            // Get time periods - new format with Período 1, 2, 3
            const periods = [
                schedule['Período 1'] || schedule['Período 1 '] || schedule[' Período 1'] || schedule[' Período 1 '],
                schedule['Período 2'] || schedule['Período 2 '] || schedule[' Período 2'] || schedule[' Período 2 '],
                schedule['Período 3'] || schedule['Período 3 '] || schedule[' Período 3'] || schedule[' Período 3 ']
            ];
            
            // Check all periods to find which one we're in
            for (const periodTime of periods) {
                if (periodTime && periodTime.trim() && periodTime.trim() !== '') {
                    const period = parsePeriodString(periodTime);
                    if (!period) continue;

                    if (period.crossesMidnight && period.end === 0) {
                        if (isTimeWithinPeriod(currentTime, period)) {
                            return '00h';
                        }
                        continue;
                    }

                    if (isTimeWithinPeriod(currentTime, period)) {
                        return formatMinutesAsHourLabel(period.end);
                    }
                }
            }
            return null;
        }

        function getNextOpenTime(schedule, currentTime) {
            // Get time periods - new format with Período 1, 2, 3
            const periods = [
                schedule['Período 1'] || schedule['Período 1 '] || schedule[' Período 1'] || schedule[' Período 1 '],
                schedule['Período 2'] || schedule['Período 2 '] || schedule[' Período 2'] || schedule[' Período 2 '],
                schedule['Período 3'] || schedule['Período 3 '] || schedule[' Período 3'] || schedule[' Período 3 ']
            ];
            
            // Find the next opening time
            for (const periodTime of periods) {
                if (periodTime && periodTime.trim() && periodTime.trim() !== '') {
                    const period = parsePeriodString(periodTime);
                    if (!period) continue;

                    if (!period.crossesMidnight) {
                        if (currentTime < period.start) {
                            return formatMinutesAsHourLabel(period.start);
                        }
                    } else {
                        if (currentTime < period.start && currentTime >= period.end) {
                            return formatMinutesAsHourLabel(period.start);
                        }
                    }
                }
            }
            return null;
        }
        
        function getNextCloseTimeFromPeriods(schedule, currentTime) {
            // Get time periods from CSV format
            const periods = [schedule.period1, schedule.period2, schedule.period3];
            
            // Check all periods to find which one we're in
            for (const periodTime of periods) {
                if (periodTime && periodTime.trim() && periodTime.trim() !== '') {
                    const period = parsePeriodString(periodTime);
                    if (!period) continue;

                    if (period.crossesMidnight && period.end === 0) {
                        if (isTimeWithinPeriod(currentTime, period)) {
                            return '00h';
                        }
                        continue;
                    }

                    if (isTimeWithinPeriod(currentTime, period)) {
                        return formatMinutesAsHourLabel(period.end);
                    }
                }
            }
            return null;
        }
        
        function getNextOpenTimeFromPeriods(schedule, currentTime) {
            // Get time periods from CSV format
            const periods = [schedule.period1, schedule.period2, schedule.period3];
            
            // Find the next opening time
            for (const periodTime of periods) {
                if (periodTime && periodTime.trim() && periodTime.trim() !== '') {
                    const period = parsePeriodString(periodTime);
                    if (!period) continue;

                    if (!period.crossesMidnight) {
                        if (currentTime < period.start) {
                            return formatMinutesAsHourLabel(period.start);
                        }
                    } else {
                        if (currentTime < period.start && currentTime >= period.end) {
                            return formatMinutesAsHourLabel(period.start);
                        }
                    }
                }
            }
            return null;
        }

        async function openHoursModal() {
            debugLog('Opening hours modal...');
            const modal = document.getElementById('hours-modal');
            const content = document.getElementById('hours-content');
            
            // Show loading state
            content.innerHTML = '<p style="color: var(--cor-texto)">Carregando horários...</p>';
            modal.classList.remove('hidden');
            document.body.style.overflow = 'hidden';
            
            try {
                // Fetch CSV data directly
                const response = await fetch(HOURS_CSV_URL);
                const csvText = await response.text();
                
                debugLog('CSV loaded successfully:', csvText.substring(0, 200));
                
                // Parse CSV manually
                const lines = csvText.trim().split('\n');
                
                debugLog('📊 Total de linhas no CSV:', lines.length);
                debugLog('📊 Primeiras 3 linhas:', lines.slice(0, 3));
                
                // Extract timezone from first line
                let timezone = 'America/Sao_Paulo'; // Default timezone
                if (lines[0] && lines[0].includes('Time Zone')) {
                    const timezoneLine = lines[0].split(',');
                    if (timezoneLine.length > 1 && timezoneLine[1].trim()) {
                        timezone = timezoneLine[1].trim();
                    }
                }
                
                debugLog('🌍 Timezone detectado:', timezone);
                
                // Identificar linha de cabeçalho
                let headerLineIndex = 1;
                let dataStartIndex = 2;
                
                // Verificar se a linha 1 contém cabeçalhos ou dados
                if (lines[1]) {
                    const firstLineValues = lines[1].split(',');
                    const firstValue = firstLineValues[0]?.trim().toLowerCase();
                    
                    // Se a primeira coluna contém "dia" ou "day" ou "período", é cabeçalho
                    if (firstValue && (firstValue.includes('dia') || firstValue.includes('day') || firstValue.includes('período'))) {
                        headerLineIndex = 1;
                        dataStartIndex = 2;
                        debugLog('📋 Cabeçalhos encontrados na linha 1');
                    } else {
                        // Se não, os dados começam na linha 1
                        headerLineIndex = -1; // Sem cabeçalho
                        dataStartIndex = 1;
                        debugLog('📋 Dados começam na linha 1 (sem cabeçalho)');
                    }
                }
                
                const headers = headerLineIndex >= 0 ? lines[headerLineIndex].split(',') : [];
                debugLog('📋 Cabeçalhos:', headers);
                
                let html = '';
                
                // Process each day (starting from dataStartIndex)
                debugLog('🔄 Processando dias a partir da linha:', dataStartIndex);
                for (let i = dataStartIndex; i < lines.length; i++) {
                    const values = lines[i].split(',');
                    const dayName = values[0]?.trim();
                    
                    debugLog(`📅 Linha ${i}: ${dayName} - Valores:`, values);
                    
                    if (!dayName || dayName === '') {
                        debugLog(`⚠️ Pulando linha ${i}: nome do dia vazio`);
                        continue;
                    }
                    
                    // Verificar se não é uma linha de cabeçalho perdida
                    const dayNameLower = dayName.toLowerCase();
                    if (dayNameLower.includes('dia') || dayNameLower.includes('day') || dayNameLower.includes('período')) {
                        debugLog(`⚠️ Pulando linha ${i}: parece ser cabeçalho - ${dayName}`);
                        continue;
                    }
                    
                    html += `
                        <div class="border-b pb-1 last:border-b-0" style="border-color: var(--cor-borda)">
                            <h3 class="font-medium mb-0.5 capitalize text-sm" style="color: var(--cor-texto)">${dayName}</h3>
                            <div class="space-y-0 text-xs" style="color: var(--cor-texto)">
                    `;
                    
                    let hasAnyPeriod = false;
                    
                    // Get current day for status indicator using timezone
                     const today = new Date();
                     const timezoneToday = new Date(today.toLocaleString("en-US", {timeZone: timezone}));
                     const currentDayIndex = timezoneToday.getDay(); // 0 = Sunday, 1 = Monday, etc.
                     const dayNames = ['Domingo', 'Segunda-Feira', 'Terça-Feira', 'Quarta-Feira', 'Quinta-Feira', 'Sexta-Feira', 'Sábado'];
                     const isToday = dayNames[currentDayIndex].toLowerCase() === dayName.toLowerCase();
                     
                     // Check each period (columns 1, 2, 3 for Período 1, 2, 3)
                     const periods = [];
                     for (let j = 1; j <= 3; j++) {
                         const periodTime = values[j];
                         if (periodTime && periodTime.trim() !== '') {
                             periods.push(periodTime.trim());
                         }
                     }
                     
                     if (periods.length > 0) {
                         hasAnyPeriod = true;
                         const periodsText = periods.join(' • ');
                         
                         // For today, check if currently open using the same logic as updateOperatingHours
                         let statusColor = 'var(--cor-sucesso)';
                         if (isToday) {
                             const currentTime = timezoneToday.getHours() * 60 + timezoneToday.getMinutes();
                             const todaySchedule = {
                                 period1: values[1],
                                 period2: values[2],
                                 period3: values[3]
                             };
                             let isCurrentlyOpen = checkIfOpenFromPeriods(todaySchedule, currentTime);

                             if (!isCurrentlyOpen) {
                                 const carryoverStatus = getPreviousDayCarryoverStatus(lines, dayName, currentTime);
                                 isCurrentlyOpen = carryoverStatus.isOpen;
                             }

                             statusColor = isCurrentlyOpen ? 'var(--cor-sucesso)' : 'var(--cor-erro)';
                         }
                         
                         html += `<div class="flex justify-between items-center">
                                     <span>${periodsText}</span>
                                     ${isToday ? `<span class="w-2 h-2 rounded-full ml-2" style="background-color: ${statusColor}"></span>` : ''}
                                 </div>`;
                     } else {
                         // Só mostrar "Fechado" se NÃO há períodos
                         html += `<div class="flex justify-between items-center">
                                     <span style="color: var(--cor-texto-secundario)">Fechado</span>
                                     ${isToday ? '<span class="w-2 h-2 rounded-full ml-2" style="background-color: var(--cor-erro)"></span>' : ''}
                                 </div>`;
                     }
                    
                    html += `</div></div>`;
                }
                
                debugLog('✅ Processamento concluído. Total de dias processados:', (html.match(/<h3 class="font-semibold/g) || []).length);
                
                content.innerHTML = html;
                
                // Iniciar relógio do timezone
                startTimezoneClock();
                
            } catch (error) {
                errorLog('Error loading hours:', error);
                content.innerHTML = '<p style="color: var(--cor-erro)">Erro ao carregar horários. Tente novamente.</p>';
                
                // Iniciar relógio mesmo com erro
                startTimezoneClock();
            }
        }

        function closeHoursModal() {
            const modal = document.getElementById('hours-modal');
            modal.classList.add('hidden');
            document.body.style.overflow = '';
            
            // Parar relógio do timezone
            stopTimezoneClock();
        }
        
        /**
         * ===== FUNÇÕES MODAL ESTABELECIMENTO FECHADO =====
         */
        
        /**
         * Mostra modal de estabelecimento fechado
         */
        async function showClosedModal() {
            const modal = document.getElementById('closed-modal');
            const nextOpenTimeElement = document.getElementById('next-open-time');
            
            // Mostrar modal
            modal.classList.remove('hidden');
            document.body.style.overflow = 'hidden';
            
            // Carregar próximo horário
            try {
                const nextTime = await getNextOpenTime();
                nextOpenTimeElement.textContent = nextTime;
            } catch (e) {
                nextOpenTimeElement.textContent = 'Consulte nossos horários';
            }
            
            debugLog('🚫 Modal de estabelecimento fechado exibido');
        }
        
        /**
         * Fecha modal de estabelecimento fechado
         */
        function closeClosedModal() {
            const modal = document.getElementById('closed-modal');
            modal.classList.add('hidden');
            document.body.style.overflow = '';
            
            debugLog('✅ Modal de estabelecimento fechado fechado');
        }
        
        /**
         * Verifica se o checkout está aberto
         */
        function isCheckoutOpen() {
            const cartModal = document.getElementById('cart-modal');
            const checkoutModal = document.getElementById('checkout-modal');
            return !cartModal.classList.contains('hidden') || !checkoutModal.classList.contains('hidden');
        }
        
        /**
         * Fecha checkout se estiver aberto
         */
        function closeCheckoutIfOpen() {
            const cartModal = document.getElementById('cart-modal');
            const checkoutModal = document.getElementById('checkout-modal');
            
            if (!cartModal.classList.contains('hidden')) {
                closeCart();
            }
            
            if (!checkoutModal.classList.contains('hidden')) {
                closeCheckout();
            }
        }
        
        /**
         * Verificação contínua do horário de funcionamento
         */
        async function checkOperatingHoursStatus() {
            try {
                const isOpen = await isCurrentlyOpen();
                
                if (!isOpen && isCheckoutOpen()) {
                    debugLog('⚠️ Estabelecimento fechou durante uso - fechando checkout');
                    closeCheckoutIfOpen();
                    showClosedModal();
                }
            } catch (e) {
                errorLog('Erro na verificação contínua de horário:', e);
            }
        }
        
        // setInterval removido para evitar duplicação - usando apenas updateOperatingHours
        
        /**
         * Atualiza o indicador visual de status (aberto/fechado)
         */
        async function updateOpenStatusIndicator() {
            try {
                const statusDot = document.getElementById('status-dot');
                const statusText = document.getElementById('status-text');
                
                if (!statusDot || !statusText) return;
                
                const isOpen = await isCurrentlyOpen();
                
                if (isOpen) {
                    // Aberto - Verde
                    statusDot.style.backgroundColor = '#10B981'; // Verde
                    statusText.textContent = 'Aberto';
                    statusText.style.color = '#10B981';
                    debugLog('✅ Status atualizado: ABERTO');
                } else {
                    // Fechado - Vermelho
                    statusDot.style.backgroundColor = '#EF4444'; // Vermelho
                    statusText.textContent = 'Fechado';
                    statusText.style.color = '#EF4444';
                    debugLog('🚫 Status atualizado: FECHADO');
                }
            } catch (e) {
                errorLog('Erro ao atualizar indicador de status:', e);
                // Status de erro - Amarelo
                const statusDot = document.getElementById('status-dot');
                const statusText = document.getElementById('status-text');
                if (statusDot && statusText) {
                    statusDot.style.backgroundColor = '#F59E0B';
                    statusText.textContent = '⚠️ Verificando...';
                    statusText.style.color = '#F59E0B';
                }
            }
        }
        
        // setInterval removido para evitar duplicação - usando apenas updateOperatingHours
        
        // Atualizar status na inicialização (após carregar config)
        document.addEventListener('DOMContentLoaded', () => {
            setTimeout(updateOpenStatusIndicator, 2000); // Aguardar 2s para config carregar
        });

        // setInterval duplicado removido - já existe na linha 3125

        // ===== FUNÇÕES RELÓGIO TIMEZONE =====
        
        let timezoneClockInterval = null;
        
        // Atualizar relógio do timezone
        function updateTimezoneClock() {
            try {
                const clockElement = document.getElementById('timezone-clock');
                const infoElement = document.getElementById('timezone-info');
                
                if (clockElement && infoElement) {
                    // Obter data/hora atual no timezone configurado
                    const currentDate = getCurrentDateInTimezone();
                    
                    // Formatar hora (HH:MM:SS)
                    const timeString = formatDateInTimezone(currentDate, {
                        hour: '2-digit',
                        minute: '2-digit',
                        second: '2-digit',
                        hour12: false
                    });
                    
                    // Formatar data completa
                    const dateString = formatDateInTimezone(currentDate, {
                        weekday: 'long',
                        year: 'numeric',
                        month: 'long',
                        day: 'numeric'
                    });
                    
                    // Atualizar elementos
                    clockElement.textContent = timeString;
                    infoElement.textContent = `${dateString} (${globalTimezone})`;
                }
            } catch (error) {
                errorLog('Erro ao atualizar relógio:', error);
                const clockElement = document.getElementById('timezone-clock');
                const infoElement = document.getElementById('timezone-info');
                
                if (clockElement && infoElement) {
                    clockElement.textContent = '--:--:--';
                    infoElement.textContent = 'Erro no timezone';
                }
            }
        }
        
        // Iniciar relógio quando modal abrir
        function startTimezoneClock() {
            debugLog('🕰️ Iniciando relógio do timezone...');
            
            // Atualizar imediatamente
            updateTimezoneClock();
            
            // Atualizar a cada segundo
            if (timezoneClockInterval) {
                clearInterval(timezoneClockInterval);
            }
            timezoneClockInterval = setInterval(updateTimezoneClock, 1000);
        }
        
        // Parar relógio quando modal fechar
        function stopTimezoneClock() {
            debugLog('🕰️ Parando relógio do timezone...');
            
            if (timezoneClockInterval) {
                clearInterval(timezoneClockInterval);
                timezoneClockInterval = null;
            }
        }

        // ===== FUNÇÕES QR CODE =====
        
        // Variável global para armazenar o QR Code gerado
        let generatedQRCode = null;
        
        /**
         * Habilita o botão de download após QR Code estar pronto
         */
        function enableDownloadButton() {
            const downloadButton = document.getElementById('download-qr-button');
            if (downloadButton) {
                downloadButton.disabled = false;
                downloadButton.textContent = '💾 Baixar QR Code PNG';
                downloadButton.style.background = 'linear-gradient(135deg, var(--cor-primaria), var(--cor-secundaria))';
                downloadButton.style.color = 'white';
                downloadButton.style.cursor = 'pointer';
                downloadButton.onmouseover = function() {
                    this.style.background = 'linear-gradient(135deg, var(--cor-secundaria), var(--cor-terciaria))';
                };
                downloadButton.onmouseout = function() {
                    this.style.background = 'linear-gradient(135deg, var(--cor-primaria), var(--cor-secundaria))';
                };
            }
        }
        
        /**
         * Desabilita o botão de download
         */
        function disableDownloadButton() {
            const downloadButton = document.getElementById('download-qr-button');
            if (downloadButton) {
                downloadButton.disabled = true;
                downloadButton.textContent = '⏳ Aguarde o QR Code...';
                downloadButton.style.background = 'linear-gradient(135deg, #ccc, #999)';
                downloadButton.style.color = '#666';
                downloadButton.style.cursor = 'not-allowed';
                downloadButton.onmouseover = null;
                downloadButton.onmouseout = null;
            }
        }
        
        /**
         * Abre o modal do QR Code e gera o código (versão simplificada)
         */
        async function openQRCodeModal() {
            const modal = document.getElementById('qrcode-modal');
            const qrcodeDisplay = document.getElementById('qrcode-display');
            const urlInput = document.getElementById('qrcode-url');
            const currentURL = window.location.href;
            
            // Configurar URL no input
            urlInput.value = currentURL;
            
            // Desabilitar botão de download inicialmente
            disableDownloadButton();
            
            // Mostrar modal
            modal.classList.remove('hidden');
            document.body.style.overflow = 'hidden';
            
            // Mostrar loading
            qrcodeDisplay.innerHTML = `
                <div style="text-align: center; padding: 40px; color: #666;">
                    <div style="font-size: 24px; margin-bottom: 10px;">⏳</div>
                    <p>Gerando QR Code...</p>
                </div>
            `;
            
            try {
                debugLog('🌐 Gerando QR Code via API online...');
                
                // Usar sempre API online para simplicidade e confiabilidade
                const encodedURL = encodeURIComponent(currentURL);
                const qrApiUrl = `https://api.qrserver.com/v1/create-qr-code/?size=300x300&data=${encodedURL}&format=png&margin=20&bgcolor=FFFFFF&color=000000`;
                
                // Armazenar URL da API para download direto
                window.currentQRCodeURL = qrApiUrl;
                
                // Criar imagem para exibição
                const img = document.createElement('img');
                img.src = qrApiUrl;
                img.alt = 'QR Code do Cardápio';
                img.style.width = '200px';
                img.style.height = '200px';
                img.style.border = '2px solid #ddd';
                img.style.borderRadius = '8px';
                img.style.display = 'block';
                img.style.margin = '0 auto';
                
                // Aguardar carregamento
                await new Promise((resolve, reject) => {
                    img.onload = () => {
                        debugLog('✅ QR Code carregado via API!');
                        resolve();
                    };
                    img.onerror = () => {
                        errorLog('❌ Erro ao carregar QR Code');
                        reject(new Error('Falha ao carregar QR Code'));
                    };
                    
                    // Timeout de 15 segundos
                    setTimeout(() => {
                        reject(new Error('Timeout ao carregar QR Code'));
                    }, 15000);
                });
                
                // Limpar e mostrar QR Code
                qrcodeDisplay.innerHTML = '';
                qrcodeDisplay.appendChild(img);
                
                // Habilitar botão de download
                enableDownloadButton();
                
                debugLog('✅ QR Code gerado e pronto para download!');
                debugLog('🔗 URL da API:', qrApiUrl);
                
            } catch (error) {
                errorLog('❌ Erro ao gerar QR Code:', error);
                
                // Manter botão desabilitado
                disableDownloadButton();
                
                // Mostrar erro com fallback
                qrcodeDisplay.innerHTML = `
                    <div style="color: #e74c3c; font-size: 14px; text-align: center; padding: 20px;">
                        <p style="margin-bottom: 10px;">❌ Erro ao gerar QR Code</p>
                        <p style="font-size: 12px; opacity: 0.8; margin-bottom: 15px;">Verifique sua conexão com a internet</p>
                        <div style="background: #f8f9fa; padding: 10px; border-radius: 6px; word-break: break-all; font-size: 11px; color: #333;">
                            ${currentURL}
                        </div>
                        <p style="font-size: 11px; margin-top: 10px; opacity: 0.6;">Copie o link acima para acessar o cardápio</p>
                    </div>
                `;
            }
        }
        
        /**
         * Fecha o modal do QR Code
         */
        function closeQRCodeModal() {
            debugLog('🔗 Fechando modal QR Code...');
            
            const modal = document.getElementById('qrcode-modal');
            modal.classList.add('hidden');
            document.body.style.overflow = '';
            
            // Limpar QR Code gerado
            generatedQRCode = null;
        }
        
        /**
         * Copia a URL do cardápio para a área de transferência
         */
        async function copyQRCodeURL(event) {
            const urlInput = document.getElementById('qrcode-url');
            const url = urlInput.value;
            
            try {
                await navigator.clipboard.writeText(url);
                
                // Feedback visual
                const button = event.target;
                const originalText = button.textContent;
                button.textContent = '✅ Copiado!';
                button.style.background = 'linear-gradient(135deg, #27ae60, #2ecc71)';
                
                setTimeout(() => {
                    button.textContent = originalText;
                    button.style.background = 'linear-gradient(135deg, var(--cor-primaria), var(--cor-secundaria))';
                }, 2000);
                
                debugLog('✅ URL copiada para área de transferência');
                
            } catch (error) {
                errorLog('❌ Erro ao copiar URL:', error);
                
                // Fallback para navegadores mais antigos
                urlInput.select();
                urlInput.setSelectionRange(0, 99999);
                document.execCommand('copy');
                
                // Feedback visual
                const button = event.target;
                const originalText = button.textContent;
                button.textContent = '✅ Copiado!';
                button.style.background = 'linear-gradient(135deg, #27ae60, #2ecc71)';
                
                setTimeout(() => {
                    button.textContent = originalText;
                    button.style.background = 'linear-gradient(135deg, var(--cor-primaria), var(--cor-secundaria))';
                }, 2000);
            }
        }
        
        /**
         * Faz download do QR Code (versão simplificada)
         */
        function downloadQRCode(event) {
            const button = event.target;
            
            // Verificar se o botão está habilitado
            if (button.disabled) {
                debugLog('⚠️ Botão ainda desabilitado');
                return;
            }
            
            const originalText = button.textContent;
            
            try {
                // Feedback visual
                button.textContent = '💾 Baixando...';
                button.style.background = 'linear-gradient(135deg, #f39c12, #e67e22)';
                
                // Verificar se temos a URL da API
                if (!window.currentQRCodeURL) {
                    throw new Error('URL do QR Code não encontrada');
                }
                
                // Método 1: Download direto via link
                const filename = 'qrcode-cardapio.png';
                
                // Método mais robusto para forçar download
                try {
                    // Tentar fetch para forçar download
                    fetch(window.currentQRCodeURL)
                        .then(response => response.blob())
                        .then(blob => {
                            // Criar URL do blob
                            const blobUrl = window.URL.createObjectURL(blob);
                            
                            // Criar link para download
                            const link = document.createElement('a');
                            link.href = blobUrl;
                            link.download = filename;
                            link.style.display = 'none';
                            
                            // Adicionar, clicar e remover
                            document.body.appendChild(link);
                            link.click();
                            document.body.removeChild(link);
                            
                            // Limpar URL do blob após delay
                            setTimeout(() => {
                                window.URL.revokeObjectURL(blobUrl);
                            }, 1000);
                        })
                        .catch(() => {
                            // Fallback: método tradicional
                            const link = document.createElement('a');
                            link.href = window.currentQRCodeURL;
                            link.download = filename;
                            link.style.display = 'none';
                            
                            document.body.appendChild(link);
                            link.click();
                            document.body.removeChild(link);
                        });
                } catch (fetchError) {
                    // Fallback final: método simples
                    const link = document.createElement('a');
                    link.href = window.currentQRCodeURL;
                    link.download = filename;
                    link.style.display = 'none';
                    
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                }
                
                // Feedback de sucesso
                button.textContent = '✅ Baixado!';
                button.style.background = 'linear-gradient(135deg, #27ae60, #2ecc71)';
                
                setTimeout(() => {
                    button.textContent = originalText;
                    button.style.background = 'linear-gradient(135deg, var(--cor-primaria), var(--cor-secundaria))';
                }, 2000);
                
                debugLog('✅ Download iniciado!');
                debugLog('📁 Arquivo:', filename);
                debugLog('🔗 URL:', window.currentQRCodeURL);
                
            } catch (error) {
                errorLog('❌ Erro ao baixar QR Code:', error);
                
                // Feedback visual de erro
                button.textContent = '❌ Erro no download';
                button.style.background = 'linear-gradient(135deg, #e74c3c, #c0392b)';
                
                setTimeout(() => {
                    button.textContent = originalText;
                    button.style.background = 'linear-gradient(135deg, var(--cor-primaria), var(--cor-secundaria))';
                }, 2000);
            }
        }

        // ===== SISTEMA DE MESA VIA URL =====
        
        // --- INÍCIO: Funções do Banner Promocional ---
        function closePromoBanner() {
            const banner = document.getElementById('promo-banner');
            if (banner) {
                banner.classList.add('hidden');
                // Salva no localStorage que o banner foi fechado hoje
                localStorage.setItem('promoBannerClosed', new Date().toDateString());
                infoLog('Banner promocional fechado pelo usuário.');
            }
        }
        // --- INÍCIO: Funções de Rastreio ---

        function openTrackingModal() {
            const modal = document.getElementById('tracking-modal');
            const modalContent = document.getElementById('tracking-modal-content');
            if (modal && modalContent) {
                modal.classList.remove('hidden');
                document.body.style.overflow = 'hidden';
                // Animação de entrada
                setTimeout(() => {
                    modalContent.classList.remove('translate-y-full');
                }, 10);
                // Tenta focar no input
                setTimeout(() => {
                    const input = document.getElementById('order-id-input');
                    if (input) input.focus();
                }, 300);
            }
        }

        function closeTrackingModal(event) {
            if (event && event.target.closest('#tracking-modal-content')) return;
            const modal = document.getElementById('tracking-modal');
            const modalContent = document.getElementById('tracking-modal-content');
            if (modal && modalContent) {
                modalContent.classList.add('translate-y-full');
                setTimeout(() => {
                modal.classList.add('hidden');
                document.body.style.overflow = '';
                // Limpa o resultado e o canal de escuta ao fechar
                document.getElementById('order-status-result').innerHTML = '';
                document.getElementById('order-status-result').classList.add('hidden');
                document.getElementById('order-id-input').value = '';
                unsubscribeFromOrder();
                }, 300);
            } 
        }

        function unsubscribeFromOrder() {
            if (orderChannel) {
                supabase.removeChannel(orderChannel);
                orderChannel = null;
                console.log('[Realtime] Inscrição de rastreio removida.');
            }
        }

        async function trackOrder() {
            const orderId = document.getElementById('order-id-input').value.trim().toUpperCase();
            const resultDiv = document.getElementById('order-status-result');
            const trackBtn = document.getElementById('track-btn');
            const searchIcon = document.getElementById('search-icon');
            const loadingSpinner = document.getElementById('loading-spinner');

            if (!audioUnlocked) {
                orderReadySound.load();
                orderReadySound.play().then(() => {
                    orderReadySound.pause();
                    audioUnlocked = true;
                    console.log("🔊 Áudio desbloqueado para autoplay.");
                }).catch(e => console.warn("Autoplay inicial bloqueado.", e));
            }

            unsubscribeFromOrder();

            if (!orderId) {
                resultDiv.innerHTML = `<p class="text-red-500 font-medium">Por favor, digite o código do seu pedido.</p>`;
                resultDiv.classList.remove('hidden');
                return;
            }

            trackBtn.disabled = true;
            searchIcon.classList.add('hidden');
            loadingSpinner.classList.remove('hidden');
            resultDiv.classList.add('hidden');

            try {
                const { data: orders, error } = await supabase.from('pedidos').select('*').eq('order_id', orderId).order('created_at', { ascending: false }).limit(1);
                if (error) throw error;

                if (orders.length > 0) {
                    displayOrderStatus(orders[0]);
                    subscribeToOrderUpdates(orders[0].id);
                } else {
                    resultDiv.innerHTML = `<div class="text-center"><div class="text-4xl mb-2">🤔</div><p class="text-gray-700 font-semibold">Nenhum pedido encontrado.</p><p class="text-gray-500 text-sm mt-1">Verifique se o código está correto.</p></div>`;
                }
            } catch (err) {
                console.error("Erro ao buscar pedido:", err);
                resultDiv.innerHTML = `<p class="text-red-500 font-medium">Ocorreu um erro ao buscar seu pedido. Tente novamente.</p>`;
            } finally {
                trackBtn.disabled = false;
                searchIcon.classList.remove('hidden');
                loadingSpinner.classList.add('hidden');
                resultDiv.classList.remove('hidden');
            }
        }

        function subscribeToOrderUpdates(orderId) {
            unsubscribeFromOrder();
            console.log(`[Realtime] Inscrevendo-se para atualizações do pedido ID: ${orderId}`);
            orderChannel = supabase.channel(`order-status-${orderId}`).on('postgres_changes', { event: 'UPDATE', schema: 'public', table: 'pedidos', filter: `id=eq.${orderId}` }, (payload) => {
                console.log('[Realtime] Atualização recebida:', payload.new);
                const newOrder = payload.new;
                const previousStatus = currentOrderStatus;
                
                // Toca som se o status mudou para Finalizado
                if (soundEnabled && newOrder.status === 'Finalizado' && previousStatus !== 'Finalizado') {
                    console.log("🔔 Tocando som de pedido pronto!");
                    orderReadySound.play().catch(e => console.warn("Autoplay do som bloqueado.", e));
                }
                
                displayOrderStatus(newOrder, true);
            }).subscribe();
        }

        function formatPaymentMethodForTracking(methodKey) {
            if (!methodKey) return 'Não informado';
            const paymentMap = { 'dinheiro': '💵 Dinheiro', 'pix': '📱 Pix', 'cartao-credito': '💳 Crédito', 'cartao-debito': '💳 Débito' };
            return paymentMap[methodKey] || methodKey.split('-').map(word => word.charAt(0).toUpperCase() + word.slice(1)).join(' ');
        }

        async function requestOrderCancellation(orderId, readableOrderId) {
            if (confirm(`Tem certeza que deseja cancelar o pedido #${readableOrderId}?`)) {
                const cancelButtonContainer = document.getElementById('cancel-order-container');
                if (cancelButtonContainer) cancelButtonContainer.innerHTML = `<p class="text-sm text-gray-500 animate-pulse">Cancelando...</p>`;
                try {
                    const { error } = await supabase.from('pedidos').update({ status: 'Cancelado' }).eq('id', orderId);
                    if (error) throw error;
                } catch (err) {
                    console.error("Erro ao cancelar pedido:", err);
                    alert("Ocorreu um erro ao cancelar. Contate o estabelecimento.");
                    window.location.reload();
                }
            }
        }

        function checkAndHideCancelButton(order) {
            const cancelButtonContainer = document.getElementById('cancel-order-container');
            if (!cancelButtonContainer) return;
            const timeInPreparation = (new Date() - new Date(order.updated_at));
            if (order.status === 'Em Preparo' && timeInPreparation > cancellationWindowMs) {
                cancelButtonContainer.classList.add('hidden');
                if (cancellationTimer) clearTimeout(cancellationTimer);
                if (cancellationCountdownInterval) clearInterval(cancellationCountdownInterval);
            }
        }

        function displayOrderStatus(order, isUpdate = false) {
            const resultDiv = document.getElementById('order-status-result');
            currentOrderStatus = order.status;
            const statuses = ['Novo', 'Em Preparo', 'Finalizado'];
            const currentStatusIndex = statuses.indexOf(order.status);
            const statusMap = {
                'Novo': { icon: '📝', title: 'Pedido Recebido', description: 'Seu pedido foi recebido e está na fila.' },
                'Em Preparo': { icon: '👨‍🍳', title: 'Em preparo', description: 'Seu pedido está sendo preparado!' },
                'Finalizado': { icon: '🛵', title: 'Pronto!', description: (() => {
                    switch (order.delivery_type) {
                        case 'delivery': return 'Seu pedido saiu para entrega. Bom apetite!';
                        case 'pickup': return 'Seu pedido está pronto para retirada no balcão.';
                        case 'local': return 'Seu pedido está sendo levado até sua mesa.';
                        default: return 'Seu pedido está pronto!';
                    }
                })() },
                'Cancelado': { icon: '❌', title: 'Pedido Cancelado', description: 'Seu pedido foi cancelado.' }
            };
            const orderInfo = statusMap[order.status] || { icon: '🤔', title: 'Status Desconhecido', description: '' };

            if (order.status === 'Cancelado') {
                // Limpar timers de cancelamento se o pedido for cancelado
                if (cancellationTimer) clearTimeout(cancellationTimer);
                if (cancellationCountdownInterval) clearInterval(cancellationCountdownInterval);
                resultDiv.innerHTML = `<div class="text-center p-4 bg-red-50 border border-red-200 rounded-lg"><div class="text-5xl mb-3">${orderInfo.icon}</div><h2 class="text-xl font-bold text-red-700">${orderInfo.title}</h2><p class="text-red-600 mt-1">Pedido #${order.order_id}</p><p class="text-gray-600 mt-2">${orderInfo.description}</p></div>`;
                return;
            }

            let itemsHtml = '';
            try {
                const items = Array.isArray(order.items) ? order.items : [];
                if (items.length > 0) {
                    const itemsList = items.map(item => {
                        let details = `<p class="text-gray-800"><strong>${item.quantity}x</strong> ${item.nome}</p>`;
                        if (item.variationText) details += `<p class="text-xs text-gray-600 pl-5">↳ Com: ${item.variationText.replace(/\n/g, ', ')}</p>`;
                        if (item.notes) details += `<p class="text-xs text-blue-700 pl-5">↳ Obs: ${item.notes}</p>`;
                        return `<li class="py-2 border-b last:border-b-0">${details}</li>`;
                    }).join('');
                    itemsHtml = `<div class="border-t mt-3 pt-3"><ul class="space-y-1">${itemsList}</ul></div>`;
                }
            } catch (e) { console.error("Erro ao renderizar itens:", e); }

            const stepsHtml = statuses.map((status, index) => {
                const isActive = index <= currentStatusIndex;
                const statusDetails = statusMap[status];
                return `<div class="status-step relative flex flex-col items-center w-1/3 ${isActive ? 'active' : ''}"><div class="w-12 h-12 rounded-full flex items-center justify-center text-2xl ${isActive ? 'text-white' : 'bg-gray-200 text-gray-500'}" style="${isActive ? 'background: var(--gradiente-secundario);' : ''}">${statusDetails.icon}</div><p class="mt-2 text-xs font-semibold ${isActive ? 'text-[color:var(--cor-primaria)]' : 'text-gray-500'}">${statusDetails.title}</p></div>`;
            }).join('');

            const progressPercentage = currentStatusIndex > 0 ? (currentStatusIndex / (statuses.length - 1)) * 100 : 0;

            const contactInfo = getContactInfo();
            const whatsappNumber = contactInfo.whatsapp ? contactInfo.whatsapp.replace(/\D/g, '') : '';

            resultDiv.innerHTML = `
                <div class="text-left mb-4 p-4 bg-gray-50 rounded-lg border">
                    <p class="text-sm text-gray-600">Pedido <span class="font-bold" style="color: var(--cor-primaria);">#${order.order_id}</span></p>
                    <div class="flex justify-between items-center">
                        <p class="text-sm text-gray-600">Cliente: <span class="font-bold text-gray-800">${order.customer_name}</span></p>
                        <p class="text-xs text-gray-500">Recebido às: ${new Date(order.created_at).toLocaleTimeString('pt-BR', { hour: '2-digit', minute: '2-digit' })}</p>
                    </div>
                    <p class="text-sm text-gray-600 mt-1">Valor Total: <span class="font-bold" style="color: var(--cor-secundaria);">${formatCurrency(order.total)}</span></p>
                    <p class="text-sm text-gray-600 mt-1">Pagamento: <span class="font-bold text-gray-800">${formatPaymentMethodForTracking(order.payment_method)}</span></p>
                    ${itemsHtml}
                </div>
                <div class="relative mb-6">
                    <div class="flex justify-between items-start">${stepsHtml}</div>
                    <div class="absolute top-6 left-0 w-full h-1 bg-gray-200" style="transform: translateY(-50%); z-index: -1;"><div class="status-line h-1" style="width: ${progressPercentage}%; background: var(--gradiente-primario);"></div></div>
                </div>
                <div id="current-status-card" class="mt-6 text-center p-4 rounded-lg ${isUpdate ? 'highlight-update' : ''}" style="background-color: rgba(var(--cor-primaria-rgb), 0.1); border: 1px solid rgba(var(--cor-primaria-rgb), 0.2);">
                    <h3 class="font-bold text-lg" style="color: var(--cor-secundaria);">${orderInfo.title}</h3>
                    <p class="text-gray-700 mt-1">${orderInfo.description}</p>
                </div>
                <div class="mt-6 border-t border-gray-200 pt-4 space-y-4 text-center">
                    <div id="cancel-order-container" class="${(() => {
                        if (order.status === 'Novo') return '';
                        if (order.status === 'Em Preparo') {
                            const timeInPreparation = (new Date() - new Date(order.updated_at));
                            return timeInPreparation <= cancellationWindowMs ? '' : 'hidden';
                        }
                        return 'hidden';
                    })()}">
                        <button onclick="requestOrderCancellation('${order.id}', '${order.order_id}')" class="text-sm font-medium text-red-600 hover:text-red-800 hover:underline transition-colors">Cancelar Pedido</button>
                        <p id="cancel-timer-message" class="text-xs text-gray-500 mt-2"></p>
                    </div>

                    ${whatsappNumber ? `
                    <div>
                        <a href="https://wa.me/${whatsappNumber}?text=${encodeURIComponent(`Olá! Gostaria de falar sobre o pedido *#${order.order_id}*`)}" target="_blank" class="inline-flex items-center justify-center space-x-2 px-4 py-2.5 rounded-lg text-sm font-medium transition-colors" style="background-color: #25D366; color: white;" onmouseover="this.style.backgroundColor='#128C7E'" onmouseout="this.style.backgroundColor='#25D366'" title="Falar com a loja no WhatsApp">
                            <svg class="w-5 h-5" fill="currentColor" viewBox="0 0 24 24"><path d="M17.472 14.382c-.297-.149-1.758-.867-2.03-.967-.273-.099-.471-.148-.67.15-.197.297-.767.966-.94 1.164-.173.199-.347.223-.644.075-.297-.15-1.255-.463-2.39-1.475-.883-.788-1.48-1.761-1.653-2.059-.173-.297-.018-.458.13-.606.134-.133.298-.347.446-.52.149-.174.198-.298.298-.497.099-.198.05-.371-.025-.52-.075-.149-.669-1.612-.916-2.207-.242-.579-.487-.5-.669-.51-.173-.008-.371-.01-.57-.01-.198 0-.52.074-.792.372-.272.297-1.04 1.016-1.04 2.479 0 1.462 1.065 2.875 1.213 3.074.149.198 2.096 3.2 5.077 4.487.709.306 1.262.489 1.694.625.712.227 1.36.195 1.871.118.571-.085 1.758-.719 2.006-1.413.248-.694.248-1.289.173-1.413-.074-.124-.272-.198-.57-.347m-5.421 7.403h-.004a9.87 9.87 0 01-5.031-1.378l-.361-.214-3.741.982.998-3.648-.235-.374a9.86 9.86 0 01-1.51-5.26c.001-5.45 4.436-9.884 9.888-9.884 2.64 0 5.122 1.03 6.988 2.898a9.825 9.825 0 012.893 6.994c-.003 5.45-4.437 9.884-9.885 9.884m8.413-18.297A11.815 11.815 0 0012.05 0C5.495 0 .16 5.335.157 11.892c0 2.096.547 4.142 1.588 5.945L.057 24l6.305-1.654a11.882 11.882 0 005.683 1.448h.005c6.554 0 11.89-5.335 11.893-11.893A11.821 11.821 0 0020.885 3.488"/></svg>
                            <span>Falar com a loja</span>
                        </a>
                    </div>
                    ` : ''}
                </div>
            `;

            if (order.status === 'Em Preparo') {
                if (cancellationTimer) clearTimeout(cancellationTimer);
                if (cancellationCountdownInterval) clearInterval(cancellationCountdownInterval);
                const timeInPreparation = new Date() - new Date(order.updated_at);
                const remainingTime = cancellationWindowMs - timeInPreparation;
                if (remainingTime > 0) {
                    const timerMessageEl = document.getElementById('cancel-timer-message');
                    const updateCountdown = () => {
                        const currentRemaining = cancellationWindowMs - (new Date() - new Date(order.updated_at));
                        if (currentRemaining > 0) {
                            timerMessageEl.textContent = `Tempo restante para cancelar: ${Math.round(currentRemaining / 1000)} segundos.`;
                        } else {
                            timerMessageEl.textContent = 'O tempo para cancelamento expirou.';
                            clearInterval(cancellationCountdownInterval);
                        }
                    };
                    updateCountdown();
                    cancellationCountdownInterval = setInterval(updateCountdown, 1000);
                    cancellationTimer = setTimeout(() => checkAndHideCancelButton(order), remainingTime + 1000);
                }
            } else if (order.status === 'Novo') {
                const timerMessageEl = document.getElementById('cancel-timer-message');
                if (timerMessageEl) timerMessageEl.textContent = 'Você pode cancelar o pedido enquanto ele não for para o preparo.';
            }
        }

        // --- FIM: Funções de Rastreio ---

        function getURLParameter(param) {
            const urlParams = new URLSearchParams(window.location.search);
            return urlParams.get(param);
        }

        function getMesaFromURL() {
            const mesa = getURLParameter('mesa');
            if (mesa && mesa.trim()) {
                debugLog('🪑 Mesa detectada na URL:', mesa);
                return mesa.trim();
            }
            return null;
        }

        function preencheMesaAutomatica() {
            const mesaURL = getMesaFromURL();
            const campoMesa = document.getElementById('table-number');
            
            if (mesaURL && campoMesa) {
                campoMesa.value = mesaURL;
                
                // Focar no campo para habilitar o botão continuar
                campoMesa.focus();
                campoMesa.blur(); // Simular saída do foco para disparar validação
                
                campoMesa.style.background = 'linear-gradient(135deg, #e8f5e9, #f1f8e9)';
                campoMesa.style.borderColor = 'var(--cor-sucesso)';
                
                const parent = campoMesa.parentNode;
                const successIcon = document.createElement('div');
                successIcon.className = 'mesa-auto-success';
                successIcon.innerHTML = '<div style="display: flex; align-items: center; margin-top: 4px; color: var(--cor-sucesso); font-size: 12px;"><svg style="width: 14px; height: 14px; margin-right: 4px;" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clip-rule="evenodd"></path></svg>Mesa preenchida automaticamente</div>';
                parent.appendChild(successIcon);
                
                setTimeout(() => {
                    campoMesa.style.background = '';
                    campoMesa.style.borderColor = '';
                    const successEl = parent.querySelector('.mesa-auto-success');
                    if (successEl) successEl.remove();
                }, 3000);
                
                debugLog('✅ Campo mesa preenchido automaticamente:', mesaURL);
                return true;
            }
            return false;
        }

        function mostrarIndicadorMesaURL() {
            const mesaURL = getMesaFromURL();
            if (mesaURL) {
                showToastMesa(mesaURL);
            }
        }

        function showToastMesa(numeroMesa) {
            // Remove existing toasts
            const existingToasts = document.querySelectorAll('.toast');
            existingToasts.forEach(toast => {
                toast.classList.add('toast-exit');
                setTimeout(() => toast.remove(), 300);
            });
            
            const toastDiv = document.createElement('div');
            toastDiv.className = 'toast toast-success';
            toastDiv.innerHTML = `
                <div class="flex items-center justify-between">
                    <div class="font-semibold text-sm text-white">Mesa ${numeroMesa} detectada</div>
                    <button onclick="this.parentElement.parentElement.classList.add('toast-exit'); setTimeout(() => this.parentElement.parentElement.remove(), 300)" class="text-white/80 hover:text-white ml-4 flex-shrink-0">
                        <span class="text-lg">×</span>
                    </button>
                </div>
            `;
            
            document.body.appendChild(toastDiv);
            
            // Auto remove
            setTimeout(() => {
                if (toastDiv.parentNode) {
                    toastDiv.classList.add('toast-exit');
                    setTimeout(() => toastDiv.remove(), 300);
                }
            }, 3500);
        }

        // ===== AUTOMAÇÃO MESA URL - CHECKOUT DIRETO =====
        function autoMesaCheckout() {
            const mesaURL = getMesaFromURL();
            if (!mesaURL) return false;
            
            debugLog('🪑 Automação Mesa URL ativada:', mesaURL);
            
            // 1. Ocultar todas as opções de entrega
            const deliveryOptions = document.getElementById('delivery-options');
            if (deliveryOptions) {
                const allOptions = deliveryOptions.querySelectorAll('label');
                allOptions.forEach(option => {
                    option.style.display = 'none';
                });
            }
            
            // 2. Mostrar apenas a opção "Consumo no Local"
            const localOption = deliveryOptions?.querySelector('input[value="local"]')?.closest('label');
            if (localOption) {
                localOption.style.display = 'flex';
                
                // 3. Selecionar automaticamente "Consumo no Local"
                const localRadio = localOption.querySelector('input[value="local"]');
                if (localRadio) {
                    localRadio.checked = true;
                    localRadio.dispatchEvent(new Event('change'));
                    debugLog('✅ "Consumo no Local" selecionado automaticamente');
                }
            }
            
            // 4. Aguardar um pouco para os campos aparecerem
            setTimeout(() => {
                // 5. Preencher campo da mesa
                const campoMesa = document.getElementById('table-number');
                if (campoMesa) {
                    campoMesa.value = mesaURL;
                    
                    // 6. Focar no campo (cursor piscando + teclado mobile)
                    campoMesa.focus();
                    
                    // 7. Disparar eventos para validação
                    campoMesa.dispatchEvent(new Event('input'));
                    campoMesa.dispatchEvent(new Event('change'));
                    
                    debugLog('✅ Campo mesa preenchido e focado:', mesaURL);
                }
            }, 100);
            
            return true;
        }

        // Toast da mesa será mostrado após o carregamento completo do cardápio

    </script>

    <!-- Notification Element -->
    <div id="notification" class="notification hidden">
        <span></span>
        <button class="notification-close" onclick="closeNotification()">×</button>
    </div>

    <style>
        /* Estilos para notificações */
        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 9999;
            max-width: 400px;
            padding: 16px 20px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            font-weight: 500;
            font-size: 14px;
            line-height: 1.4;
            transform: translateX(100%);
            opacity: 0;
            transition: all 0.3s ease;
            display: flex;
            align-items: flex-start;
            justify-content: space-between;
            gap: 12px;
        }

        .notification.show {
            transform: translateX(0);
            opacity: 1;
        }

        .notification.success {
            background-color: #10b981;
            color: white;
        }

        .notification.error {
            background-color: #ef4444;
            color: white;
        }

        .notification.warning {
            background-color: #f59e0b;
            color: white;
        }

        .notification.info {
            background-color: #3b82f6;
            color: white;
        }

        .notification-close {
            background: none;
            border: none;
            color: inherit;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            padding: 0;
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            transition: background-color 0.2s;
            flex-shrink: 0;
        }

        .notification-close:hover {
            background-color: rgba(255, 255, 255, 0.2);
        }

        /* Responsividade para mobile */
        @media (max-width: 640px) {
            .notification {
                left: 20px;
                right: 20px;
                max-width: none;
                transform: translateY(-100%);
            }

            .notification.show {
                transform: translateY(0);
            }
        }
    </style>

    <script>
        // Função para mostrar notificações
        function showNotification(message, type = 'info', duration = 4000) {
            const notification = document.getElementById('notification');
            
            // Escapar HTML para evitar XSS
            const escapedMessage = message.replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/\n/g, '<br>');
            
            notification.innerHTML = `
                <span>${escapedMessage}</span>
                <button class="notification-close" onclick="closeNotification()">×</button>
            `;
            notification.className = `notification ${type}`;
            notification.classList.add('show');
            
            // Limpar timeout anterior se existir
            if (notification.timeoutId) {
                clearTimeout(notification.timeoutId);
            }
            
            // Definir novo timeout
            notification.timeoutId = setTimeout(() => {
                notification.classList.remove('show');
            }, duration);
        }
        
        // Função para fechar notificação
        function closeNotification() {
            const notification = document.getElementById('notification');
            notification.classList.remove('show');
        }
        
        // Função para verificar limites de seleção
        function checkSelectionLimit(input, variationData) {
            if (!variationData || variationData.type !== 'checkbox') {
                return true;
            }
            
            const maxSelect = variationData.maxSelect;
            if (!maxSelect || maxSelect <= 0) {
                return true;
            }
            
            // Encontrar o container da variação
            const variationContainer = input.closest('.variation-container');
            if (!variationContainer) {
                return true;
            }
            
            const checkedInputs = variationContainer.querySelectorAll('input[type="checkbox"]:checked');
            
            if (input.checked && checkedInputs.length > maxSelect) {
                input.checked = false;
                showNotification(`Máximo de ${maxSelect} opções permitidas!`, 'warning', 3000);
                return false;
            }
            
            return true;
        }
        
        // Função para verificar seleções mínimas obrigatórias
        function checkMinimumSelections(variationData) {
            if (!variationData || variationData.type !== 'checkbox') {
                return true;
            }
            
            const minSelect = variationData.minSelect;
            if (!minSelect || minSelect <= 0) {
                return true;
            }
            
            // Contar seleções atuais para esta variação
            const variationIndex = variationData.index;
            const selectedCount = Object.keys(selectedVariations).filter(key => 
                key.startsWith(`${variationIndex}-`)
            ).length;
            
            if (selectedCount < minSelect) {
                showNotification(`Selecione pelo menos ${minSelect} opções em "${variationData.name}"!`, 'warning', 4000);
                return false;
            }
            
            return true;
        }
        
        // Função para validar todas as variações antes de adicionar ao carrinho
        function validateAllVariations() {
            const variations = parseVariations(currentProduct.classificacaoAdicional);
            if (!variations || variations.type !== 'multiple_variations') {
                return true;
            }
            
            let isValid = true;
            
            // Verificar variações obrigatórias
            const requiredVariations = variations.variations.filter(v => v.required);
            for (const requiredVar of requiredVariations) {
                const variationIndex = variations.variations.indexOf(requiredVar);
                const hasSelectionForThisVariation = Object.keys(selectedVariations)
                    .some(key => key.startsWith(`${variationIndex}-`));
                
                if (!hasSelectionForThisVariation) {
                    showNotification(`Selecione uma opção em "${requiredVar.name}"!`, 'warning', 4000);
                    isValid = false;
                    break;
                }
            }
            
            // Verificar seleções mínimas para checkboxes
            if (isValid) {
                for (let i = 0; i < variations.variations.length; i++) {
                    const variation = variations.variations[i];
                    if (variation.type === 'checkbox' && variation.minSelect > 0) {
                        const selectedCount = Object.keys(selectedVariations).filter(key => 
                            key.startsWith(`${i}-`)
                        ).length;
                        
                        if (selectedCount > 0 && selectedCount < variation.minSelect) {
                            showNotification(`Selecione pelo menos ${variation.minSelect} opções em "${variation.name}"!`, 'warning', 4000);
                            isValid = false;
                            break;
                        }
                    }
                }
            }
            
            return isValid;
        }
        
        // Função para validar todas as variações antes de adicionar ao carrinho
        function validateAllVariations() {
            const variations = document.querySelectorAll('[data-variation-name]');
            
            for (const variation of variations) {
                const variationName = variation.dataset.variationName;
                const variationData = {
                    name: variationName,
                    type: variation.dataset.variationType || 'radio',
                    required: variation.dataset.variationRequired === 'true',
                    min: parseInt(variation.dataset.variationMin) || 0,
                    max: parseInt(variation.dataset.variationMax) || 999
                };
                
                // Verificar seleções mínimas para variações obrigatórias
                if (variationData.required) {
                    const isValid = checkMinimumSelections(variationData);
                    if (!isValid) {
                        showToast(`Por favor, selecione pelo menos uma opção em "${variationName}"`, 'error');
                        return false;
                    }
                }
                
                // Verificar limites para variações checkbox
                if (variationData.type === 'checkbox') {
                    const selectedOptions = variation.querySelectorAll('input[type="checkbox"]:checked');
                    
                    if (selectedOptions.length < variationData.min) {
                        showToast(`Selecione pelo menos ${variationData.min} opções em "${variationName}"`, 'error');
                        return false;
                    }
                    
                    if (selectedOptions.length > variationData.max) {
                        showToast(`Selecione no máximo ${variationData.max} opções em "${variationName}"`, 'error');
                        return false;
                    }
                }
            }
            
            return true;
        }




        /**
 * ====================================================================
 * SISTEMA DE LOCALSTORAGE - CARDÁPIO SHEETS V3.8.0
 * ====================================================================
 * 
 * Sistema robusto de persistência de dados usando localStorage
 * para manter carrinho, cupons, dados do formulário e configurações
 * entre sessões do usuário.
 * 
 * Funcionalidades:
 * - Persistência de carrinho com variações e notas
 * - Persistência de cupons aplicados
 * - Persistência de dados do formulário de checkout
 * - Persistência de taxa de delivery
 * - Sistema de versionamento e expiração
 * - Limpeza automática de dados expirados
 * - Logs detalhados para debug
 * - Fallbacks para compatibilidade
 * 
 * Desenvolvido por Dante Testa - dantetesta.com.br
 */

(function() {
    'use strict';
    
    // ===== CONFIGURAÇÕES DO SISTEMA =====
    const STORAGE_CONFIG = {
        VERSION: '3.8.0',
        EXPIRATION_DAYS: 30, // Dados expiram em 30 dias
        KEYS: {
            CART: 'cardapio_cart_v2',
            COUPON: 'cardapio_coupon_v2',
            ORDER_DATA: 'cardapio_order_data_v2',
            DELIVERY_FEE: 'cardapio_delivery_fee_v2',
            CSV_CACHE: 'cardapio_csv_cache_v2'
        },
        DEBUG: true // Será sobrescrito pelo DEBUG_MODE do config.js
    };
    
    // ===== UTILITÁRIOS =====
    
    /**
     * Log de debug personalizado
     */
    function storageLog(message, ...args) {
        if (STORAGE_CONFIG.DEBUG && typeof debugLog === 'function') {
            debugLog('💾 [localStorage]', message, ...args);
        } else if (STORAGE_CONFIG.DEBUG) {
            debugLog('💾 [localStorage]', message, ...args);
        }
    }
    
    /**
     * Log de erro personalizado
     */
    function storageError(message, ...args) {
        if (typeof errorLog === 'function') {
            errorLog('❌ [localStorage]', message, ...args);
        } else {
            console.error('❌ [localStorage]', message, ...args);
        }
    }
    
    /**
     * Verificar se localStorage está disponível
     */
    function isLocalStorageAvailable() {
        try {
            const test = '__localStorage_test__';
            localStorage.setItem(test, test);
            localStorage.removeItem(test);
            return true;
        } catch (e) {
            return false;
        }
    }
    
    /**
     * Criar timestamp de expiração
     */
    function createExpirationTimestamp() {
        return Date.now() + (STORAGE_CONFIG.EXPIRATION_DAYS * 24 * 60 * 60 * 1000);
    }
    
    /**
     * Verificar se dados expiraram
     */
    function isExpired(timestamp) {
        return Date.now() > timestamp;
    }
    
    /**
     * Salvar dados no localStorage com versionamento e expiração
     */
    function saveToStorage(key, data) {
        if (!isLocalStorageAvailable()) {
            storageError('localStorage não disponível');
            return false;
        }
        
        try {
            const storageData = {
                version: STORAGE_CONFIG.VERSION,
                timestamp: Date.now(),
                expires: createExpirationTimestamp(),
                data: data
            };
            
            localStorage.setItem(key, JSON.stringify(storageData));
            storageLog(`Dados salvos: ${key}`, data);
            return true;
        } catch (e) {
            storageError(`Erro ao salvar ${key}:`, e);
            return false;
        }
    }
    
    /**
     * Carregar dados do localStorage com verificação de versão e expiração
     */
    function loadFromStorage(key) {
        if (!isLocalStorageAvailable()) {
            return null;
        }
        
        try {
            const stored = localStorage.getItem(key);
            if (!stored) {
                return null;
            }
            
            const storageData = JSON.parse(stored);
            
            // Verificar expiração
            if (storageData.expires && isExpired(storageData.expires)) {
                storageLog(`Dados expirados removidos: ${key}`);
                localStorage.removeItem(key);
                return null;
            }
            
            // Verificar versão (opcional - pode ser usado para migração futura)
            if (storageData.version !== STORAGE_CONFIG.VERSION) {
                storageLog(`Versão diferente detectada para ${key}: ${storageData.version} -> ${STORAGE_CONFIG.VERSION}`);
            }
            
            storageLog(`Dados carregados: ${key}`, storageData.data);
            return storageData.data;
        } catch (e) {
            storageError(`Erro ao carregar ${key}:`, e);
            localStorage.removeItem(key); // Remove dados corrompidos
            return null;
        }
    }
    
    /**
     * Remover dados específicos do localStorage
     */
    function removeFromStorage(key) {
        if (!isLocalStorageAvailable()) {
            return false;
        }
        
        try {
            localStorage.removeItem(key);
            storageLog(`Dados removidos: ${key}`);
            return true;
        } catch (e) {
            storageError(`Erro ao remover ${key}:`, e);
            return false;
        }
    }
    
    // ===== FUNÇÕES ESPECÍFICAS DO CARRINHO =====
    
    /**
     * Salvar carrinho no localStorage
     */
    window.saveCartToStorage = function() {
        if (typeof cart !== 'undefined' && Array.isArray(cart)) {
            const success = saveToStorage(STORAGE_CONFIG.KEYS.CART, cart);
            if (success) {
                storageLog(`🛒 Carrinho salvo: ${cart.length} itens`);
            }
            return success;
        }
        return false;
    };
    
    /**
     * Carregar carrinho do localStorage
     */
    window.loadCartFromStorage = function() {
        const cartData = loadFromStorage(STORAGE_CONFIG.KEYS.CART);
        if (cartData && Array.isArray(cartData) && cartData.length > 0) {
            if (typeof cart !== 'undefined') {
                cart.length = 0; // Limpar carrinho atual
                cart.push(...cartData); // Adicionar itens restaurados
                storageLog(`🛍 Carrinho restaurado: ${cart.length} itens`);
                return cart.length > 0; // Retorna true apenas se realmente restaurou itens
            }
        }
        storageLog('🛍 Nenhum item no carrinho para restaurar');
        return false;
    };
    
    /**
     * Limpar carrinho do localStorage
     */
    window.clearCartFromStorage = function() {
        const success = removeFromStorage(STORAGE_CONFIG.KEYS.CART);
        if (success) {
            storageLog('🛒 Carrinho limpo do localStorage');
        }
        return success;
    };
    
    // ===== FUNÇÕES ESPECÍFICAS DE CUPONS =====
    
    /**
     * Salvar cupom no localStorage
     */
    window.saveCouponToStorage = function() {
        if (typeof appliedCoupon !== 'undefined' && typeof couponDiscount !== 'undefined') {
            const couponData = {
                appliedCoupon: appliedCoupon,
                couponDiscount: couponDiscount
            };
            const success = saveToStorage(STORAGE_CONFIG.KEYS.COUPON, couponData);
            if (success && appliedCoupon) {
                storageLog(`🎟️ Cupom salvo: ${appliedCoupon.codigo} (${couponDiscount})`);
            }
            return success;
        }
        return false;
    };
    
    /**
     * Carregar cupom do localStorage
     */
    window.loadCouponFromStorage = function() {
        const couponData = loadFromStorage(STORAGE_CONFIG.KEYS.COUPON);
        if (couponData && couponData.appliedCoupon) {
            if (typeof appliedCoupon !== 'undefined' && typeof couponDiscount !== 'undefined') {
                appliedCoupon = couponData.appliedCoupon;
                couponDiscount = couponData.couponDiscount || 0;
                storageLog(`🎟️ Cupom restaurado: ${appliedCoupon.codigo} (${couponDiscount})`);
                return true;
            }
        }
        return false;
    };
    
    /**
     * Limpar cupom do localStorage
     */
    window.clearCouponFromStorage = function() {
        const success = removeFromStorage(STORAGE_CONFIG.KEYS.COUPON);
        if (success) {
            storageLog('🎟️ Cupom limpo do localStorage');
        }
        return success;
    };
    
    // ===== FUNÇÕES ESPECÍFICAS DE DADOS DO PEDIDO =====
    
    /**
     * Salvar dados do pedido no localStorage
     */
    window.saveOrderDataToStorage = function() {
        if (typeof orderData !== 'undefined' && orderData) {
            const success = saveToStorage(STORAGE_CONFIG.KEYS.ORDER_DATA, orderData);
            if (success) {
                storageLog('📝 Dados do pedido salvos', orderData);
            }
            return success;
        }
        return false;
    };
    
    /**
     * Carregar dados do pedido do localStorage
     */
    window.loadOrderDataFromStorage = function() {
        const savedOrderData = loadFromStorage(STORAGE_CONFIG.KEYS.ORDER_DATA);
        if (savedOrderData && typeof orderData !== 'undefined') {
            // Mesclar dados salvos com dados atuais
            Object.assign(orderData, savedOrderData);
            
            // Preencher campos do formulário
            fillFormFields(savedOrderData);
            
            storageLog('📝 Dados do pedido restaurados', savedOrderData);
            return true;
        }
        return false;
    };
    
    /**
     * Preencher campos do formulário com dados salvos
     */
    function fillFormFields(data) {
        try {
            if (data.customerName) {
                const nameField = document.getElementById('customer-name');
                if (nameField) nameField.value = data.customerName;
            }
            
            if (data.whatsapp) {
                const whatsappField = document.getElementById('customer-whatsapp');
                if (whatsappField) whatsappField.value = data.whatsapp;
            }
            
            if (data.paymentMethod) {
                const paymentField = document.getElementById('payment-method');
                if (paymentField) paymentField.value = data.paymentMethod;
            }
            
            if (data.changeAmount) {
                const changeField = document.getElementById('change-amount');
                if (changeField) changeField.value = data.changeAmount;
            }
            
            if (data.notes) {
                const notesField = document.getElementById('order-notes');
                if (notesField) notesField.value = data.notes;
            }
            
            if (data.deliveryType) {
                const deliveryRadio = document.querySelector(`input[name="delivery-type"][value="${data.deliveryType}"]`);
                if (deliveryRadio) deliveryRadio.checked = true;
            }
            
            storageLog('📝 Campos do formulário preenchidos');
        } catch (e) {
            storageError('Erro ao preencher campos do formulário:', e);
        }
    }
    
    /**
     * Limpar dados do pedido do localStorage
     */
    window.clearOrderDataFromStorage = function() {
        const success = removeFromStorage(STORAGE_CONFIG.KEYS.ORDER_DATA);
        if (success) {
            storageLog('📝 Dados do pedido limpos do localStorage');
        }
        return success;
    };
    
    // ===== FUNÇÕES ESPECÍFICAS DE TAXA DE DELIVERY =====
    
    /**
     * Salvar taxa de delivery no localStorage
     */
    window.saveDeliveryFeeToStorage = function() {
        if (typeof currentDeliveryFee !== 'undefined') {
            const success = saveToStorage(STORAGE_CONFIG.KEYS.DELIVERY_FEE, currentDeliveryFee);
            if (success) {
                storageLog(`🚚 Taxa de delivery salva: ${currentDeliveryFee}`);
            }
            return success;
        }
        return false;
    };
    
    /**
     * Carregar taxa de delivery do localStorage
     */
    window.loadDeliveryFeeFromStorage = function() {
        const savedFee = loadFromStorage(STORAGE_CONFIG.KEYS.DELIVERY_FEE);
        if (savedFee !== null && typeof currentDeliveryFee !== 'undefined') {
            currentDeliveryFee = savedFee;
            storageLog(`🚚 Taxa de delivery restaurada: ${savedFee}`);
            return true;
        }
        return false;
    };
    
    /**
     * Limpar taxa de delivery do localStorage
     */
    window.clearDeliveryFeeFromStorage = function() {
        const success = removeFromStorage(STORAGE_CONFIG.KEYS.DELIVERY_FEE);
        if (success) {
            storageLog('🚚 Taxa de delivery limpa do localStorage');
        }
        return success;
    };
    
    // ===== FUNÇÕES DE CACHE CSV (OPCIONAL) =====
    
    /**
     * Salvar cache de CSV no localStorage
     */
    window.saveCsvCacheToStorage = function(csvData) {
        if (csvData) {
            const success = saveToStorage(STORAGE_CONFIG.KEYS.CSV_CACHE, csvData);
            if (success) {
                storageLog('📊 Cache CSV salvo');
            }
            return success;
        }
        return false;
    };
    
    /**
     * Carregar cache de CSV do localStorage
     */
    window.loadCsvCacheFromStorage = function() {
        const cachedData = loadFromStorage(STORAGE_CONFIG.KEYS.CSV_CACHE);
        if (cachedData) {
            storageLog('📊 Cache CSV carregado');
            return cachedData;
        }
        return null;
    };
    
    // ===== FUNÇÕES DE LIMPEZA GERAL =====
    
    /**
     * Limpar todos os dados do sistema localStorage
     */
    window.clearAllStorageData = function() {
        let cleared = 0;
        
        Object.values(STORAGE_CONFIG.KEYS).forEach(key => {
            if (removeFromStorage(key)) {
                cleared++;
            }
        });
        
        storageLog(`🧹 Limpeza completa: ${cleared} chaves removidas`);
        return cleared > 0;
    };
    
    /**
     * Limpar dados expirados automaticamente
     */
    function cleanExpiredData() {
        let cleaned = 0;
        
        Object.values(STORAGE_CONFIG.KEYS).forEach(key => {
            try {
                const stored = localStorage.getItem(key);
                if (stored) {
                    const storageData = JSON.parse(stored);
                    if (storageData.expires && isExpired(storageData.expires)) {
                        localStorage.removeItem(key);
                        cleaned++;
                        storageLog(`🧹 Dados expirados removidos: ${key}`);
                    }
                }
            } catch (e) {
                // Remove dados corrompidos
                localStorage.removeItem(key);
                cleaned++;
                storageLog(`🧹 Dados corrompidos removidos: ${key}`);
            }
        });
        
        if (cleaned > 0) {
            storageLog(`🧹 Limpeza automática: ${cleaned} itens removidos`);
        }
        
        return cleaned;
    }
    
    /**
     * Obter estatísticas do localStorage
     */
    window.getStorageStats = function() {
        const stats = {
            available: isLocalStorageAvailable(),
            keys: {},
            totalSize: 0
        };
        
        if (stats.available) {
            Object.entries(STORAGE_CONFIG.KEYS).forEach(([name, key]) => {
                const data = localStorage.getItem(key);
                stats.keys[name] = {
                    exists: !!data,
                    size: data ? data.length : 0
                };
                stats.totalSize += stats.keys[name].size;
            });
        }
        
        return stats;
    };
    
    // ===== INICIALIZAÇÃO DO SISTEMA =====
    
    /**
     * Inicializar sistema de localStorage
     */
    window.initializeStorageSystem = function() {
        storageLog('🚀 Inicializando sistema de localStorage...');
        
        // Verificar disponibilidade
        if (!isLocalStorageAvailable()) {
            storageError('localStorage não está disponível neste navegador');
            return false;
        }
        
        // Sincronizar configuração de debug
        if (typeof DEBUG_MODE !== 'undefined') {
            STORAGE_CONFIG.DEBUG = DEBUG_MODE;
        }
        
        // Limpeza automática de dados expirados
        cleanExpiredData();
        
        // Log de estatísticas
        const stats = window.getStorageStats();
        storageLog('📊 Estatísticas do localStorage:', stats);
        
        storageLog('✅ Sistema de localStorage inicializado com sucesso');
        return true;
    };
    
    // ===== AUTO-INICIALIZAÇÃO =====
    
    // Aguardar DOM estar pronto
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', function() {
            // Aguardar um pouco mais para garantir que outras variáveis estejam disponíveis
            setTimeout(() => {
                if (typeof initializeStorageSystem === 'function') {
                    initializeStorageSystem();
                }
            }, 100);
        });
    } else {
        // DOM já está pronto
        setTimeout(() => {
            if (typeof initializeStorageSystem === 'function') {
                initializeStorageSystem();
            }
        }, 100);
    }
    
    storageLog('📦 Sistema de localStorage carregado');
    
})();

    </script>



<!-- ====================================================================
     SISTEMA DE TRADUÇÃO AUTOMÁTICA - GTRANSLATE
     ====================================================================
     Configurado dinamicamente através das variáveis TRADUCAO e LANGS
     definidas no arquivo config.js
     ==================================================================== -->
<div id="gtranslate_wrapper"></div>

<script>
debugLog('🔍 === DEBUG SISTEMA DE TRADUÇÃO ===');
debugLog('TRADUCAO definida?', typeof TRADUCAO !== 'undefined');
debugLog('TRADUCAO valor:', TRADUCAO);
debugLog('LANGS definida?', typeof LANGS !== 'undefined');
debugLog('LANGS valor:', LANGS);
debugLog('BANDEIRAS definida?', typeof BANDEIRAS !== 'undefined');
debugLog('BANDEIRAS valor:', BANDEIRAS);

// Verificar se o sistema de tradução está habilitado
if (typeof TRADUCAO !== 'undefined' && TRADUCAO === true) {
    infoLog('✅ Condição de tradução atendida - carregando GTranslate');
    
    // Carregar script do GTranslate apenas se habilitado
    const gtranslateScript = document.createElement('script');
    gtranslateScript.src = 'https://cdn.gtranslate.net/widgets/latest/float.js';
    gtranslateScript.defer = true;
    
    // Adicionar listeners para debug
    gtranslateScript.onload = function() {
        infoLog('✅ Script GTranslate carregado com sucesso');
    };
    gtranslateScript.onerror = function() {
        errorLog('❌ Erro ao carregar script GTranslate');
    };
    
    document.head.appendChild(gtranslateScript);
    debugLog('📦 Script GTranslate adicionado ao DOM');
    
    // Configurar GTranslate com base nas variáveis do config.js
    window.gtranslateSettings = {
        default_language: typeof LANGS !== 'undefined' && LANGS.length > 0 ? LANGS[0] : "pt",
        native_language_names: true, // Mostrar nomes dos idiomas em suas línguas nativas
        detect_browser_language: true, // Detectar idioma do navegador automaticamente
        languages: typeof LANGS !== 'undefined' && LANGS.length > 0 ? LANGS : ["pt", "en", "es"],
        wrapper_selector: "#gtranslate_wrapper",
        float: "right",
        flag_style: "3d", // Estilo das bandeiras: "3d", "default", "round"
        switcher_type: "flags", // Tipo do seletor: "flags", "dropdown", "popup"
        switcher_open_direction: "bottom", // Direção de abertura: "bottom", "top"
        alt_flags: BANDEIRAS // 🌎 Bandeiras definidas no config.js
    };
    
    debugLog('⚙️ Configurações GTranslate definidas:');
    debugLog('- default_language:', window.gtranslateSettings.default_language);
    debugLog('- languages:', window.gtranslateSettings.languages);
    debugLog('- alt_flags:', window.gtranslateSettings.alt_flags);
    infoLog('🌐 Sistema de tradução habilitado');
    infoLog('📋 Idiomas disponíveis:', window.gtranslateSettings.languages);
    infoLog('🎯 Idioma padrão:', window.gtranslateSettings.default_language);
} else {
    infoLog('🚫 Sistema de tradução desabilitado via config.js');
    // Ocultar o wrapper se tradução estiver desabilitada
    const wrapper = document.getElementById('gtranslate_wrapper');
    if (wrapper) {
        wrapper.style.display = 'none';
    }
}

// ====================================================================
// POSICIONAMENTO DINÂMICO DO BOTÃO DE COMPARTILHAMENTO
// ====================================================================
/**
 * Ajusta a posição do botão de compartilhamento baseado no status da tradução:
 * - TRADUCAO = true: bottom: 92px (posição original)
 * - TRADUCAO = false: bottom: 30px (mesma altura do carrinho)
 */
function adjustShareButtonPosition() {
    debugLog('🔍 === DEBUG POSICIONAMENTO BOTÃO COMPARTILHAMENTO ===');
    debugLog('TRADUCAO definida?', typeof TRADUCAO !== 'undefined');
    debugLog('TRADUCAO valor:', TRADUCAO);
    
    const shareButton = document.getElementById('share-fab');
    debugLog('Botão compartilhamento encontrado?', !!shareButton);
    
    if (shareButton) {
        // Verificar se tradução está habilitada
        const translationEnabled = typeof TRADUCAO !== 'undefined' && TRADUCAO === true;
        debugLog('Tradução habilitada?', translationEnabled);
        
        if (translationEnabled) {
            // Tradução habilitada: manter posição original (92px)
            shareButton.style.bottom = '92px';
            infoLog('✅ Botão compartilhamento: posição 92px (tradução ativa)');
            debugLog('Posição aplicada:', shareButton.style.bottom);
        } else {
            // Tradução desabilitada: alinhar com carrinho (30px)
            shareButton.style.bottom = '30px';
            infoLog('✅ Botão compartilhamento: posição 30px (tradução desabilitada)');
            debugLog('Posição aplicada:', shareButton.style.bottom);
        }
    } else {
        warnLog('❌ Botão compartilhamento não encontrado no DOM');
    }
    debugLog('=== FIM DEBUG POSICIONAMENTO ===');
}

// Executar ajuste de posicionamento após DOM carregado
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', function() {
        setTimeout(adjustShareButtonPosition, 500);
    });

        // Listener para o controle de som do rastreio
        const soundToggle = document.getElementById('sound-toggle');
        if(soundToggle) soundToggle.addEventListener('change', (e) => {
            soundEnabled = e.target.checked;
        });
} else {
    // DOM já carregado, executar com delay para garantir que elementos estejam disponíveis
    setTimeout(adjustShareButtonPosition, 500);
}
</script>

<!-- Modal de Autenticação de Cliente -->
<div id="auth-modal" class="fixed inset-0 z-[1000] hidden">
    <div class="absolute inset-0 bg-black/60 backdrop-blur-sm" onclick="closeAuthModal()"></div>
    <div class="relative z-[1001] flex items-center justify-center min-h-screen px-4">
        <div class="bg-white rounded-2xl shadow-2xl overflow-hidden max-w-md w-full relative">
            <!-- Tabs -->
            <div class="flex border-b relative">
                <!-- Botão Fechar -->
                <button onclick="closeAuthModal()" class="absolute top-3 right-3 z-10 w-8 h-8 flex items-center justify-center rounded-full hover:bg-gray-100 transition-colors" style="color: var(--cor-texto-secundario);" title="Fechar">
                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                    </svg>
                </button>
                <button id="auth-tab-login" class="flex-1 px-6 py-4 text-sm font-semibold transition-all border-b-2" style="border-color: var(--cor-primaria); color: var(--cor-primaria);" onclick="switchAuthTab('login')">
                    Entrar
                </button>
                <button id="auth-tab-signup" class="flex-1 px-6 py-4 text-sm font-semibold transition-all border-b-2 border-transparent text-gray-500" onclick="switchAuthTab('signup')">
                    Cadastrar
                </button>
            </div>
            
            <div class="p-6">
                <!-- Formulário de Login -->
                <form id="auth-form-login" class="space-y-4">
                    <div>
                        <label class="block text-sm font-medium text-gray-700 mb-1">Telefone</label>
                        <input id="auth-login-phone" type="tel" placeholder="(00) 00000-0000" required 
                               class="w-full px-4 py-3 rounded-lg bg-gray-50 border border-gray-300 focus:ring-2 focus:border-transparent transition-all" 
                               style="--tw-ring-color: var(--cor-primaria);">
                    </div>
                    <div>
                        <label class="block text-sm font-medium text-gray-700 mb-1">Senha</label>
                        <div class="relative">
                            <input id="auth-login-password" type="password" placeholder="••••••••" required 
                                   class="w-full px-4 py-3 pr-12 rounded-lg bg-gray-50 border border-gray-300 focus:ring-2 focus:border-transparent transition-all" 
                                   style="--tw-ring-color: var(--cor-primaria);">
                            <button type="button" onclick="togglePasswordVisibility('auth-login-password')" 
                                    class="absolute right-3 top-1/2 -translate-y-1/2 text-gray-500 hover:text-gray-700 transition-colors" 
                                    title="Mostrar/Ocultar senha">
                                <svg id="auth-login-password-icon-hide" class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"></path>
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z"></path>
                                </svg>
                                <svg id="auth-login-password-icon-show" class="w-5 h-5 hidden" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13.875 18.825A10.05 10.05 0 0112 19c-4.478 0-8.268-2.943-9.543-7a9.97 9.97 0 011.563-3.029m5.858.908a3 3 0 114.243 4.243M9.878 9.878l4.242 4.242M9.88 9.88l-3.29-3.29m7.532 7.532l3.29 3.29M3 3l3.59 3.59m0 0A9.953 9.953 0 0112 5c4.478 0 8.268 2.943 9.543 7a10.025 10.025 0 01-4.132 5.411m0 0L21 21"></path>
                                </svg>
                            </button>
                        </div>
                    </div>
                    
                    <!-- Checkbox Lembrar-me -->
                    <div class="flex items-center">
                        <input id="auth-remember-me" type="checkbox" 
                               class="w-4 h-4 rounded border-gray-300 focus:ring-2 transition-all cursor-pointer" 
                               style="--tw-ring-color: var(--cor-primaria); accent-color: var(--cor-primaria);">
                        <label for="auth-remember-me" class="ml-2 text-sm text-gray-700 cursor-pointer select-none">
                            Lembrar meus dados
                        </label>
                    </div>
                    
                    <button id="auth-login-submit" type="submit" 
                            class="w-full px-4 py-3 font-semibold text-white rounded-lg transition-all hover:opacity-90" 
                            style="background: var(--cor-primaria);">
                        Entrar
                    </button>
                    <p id="auth-login-error" class="text-sm text-red-600 hidden mt-2"></p>
                    <p id="auth-login-success" class="text-sm text-green-600 hidden mt-2"></p>
                </form>
                
                <!-- Formulário de Cadastro -->
                <form id="auth-form-signup" class="space-y-4 hidden">
                    <div>
                        <label class="block text-sm font-medium text-gray-700 mb-1">Nome Completo</label>
                        <input id="auth-signup-name" type="text" placeholder="Seu nome" required 
                               class="w-full px-4 py-3 rounded-lg bg-gray-50 border border-gray-300 focus:ring-2 focus:border-transparent transition-all" 
                               style="--tw-ring-color: var(--cor-primaria);">
                    </div>
                    <div>
                        <label class="block text-sm font-medium text-gray-700 mb-1">Email</label>
                        <input id="auth-signup-email" type="email" placeholder="seu@email.com" required 
                               class="w-full px-4 py-3 rounded-lg bg-gray-50 border border-gray-300 focus:ring-2 focus:border-transparent transition-all" 
                               style="--tw-ring-color: var(--cor-primaria);">
                    </div>
                    <div>
                        <label class="block text-sm font-medium text-gray-700 mb-1">Telefone</label>
                        <input id="auth-signup-phone" type="tel" placeholder="(00) 00000-0000" required 
                               class="w-full px-4 py-3 rounded-lg bg-gray-50 border border-gray-300 focus:ring-2 focus:border-transparent transition-all" 
                               style="--tw-ring-color: var(--cor-primaria);">
                    </div>
                    <div>
                        <label class="block text-sm font-medium text-gray-700 mb-1">Senha</label>
                        <div class="relative">
                            <input id="auth-signup-password" type="password" placeholder="Mínimo 6 caracteres" required minlength="6" 
                                   class="w-full px-4 py-3 pr-12 rounded-lg bg-gray-50 border border-gray-300 focus:ring-2 focus:border-transparent transition-all" 
                                   style="--tw-ring-color: var(--cor-primaria);">
                            <button type="button" onclick="togglePasswordVisibility('auth-signup-password')" 
                                    class="absolute right-3 top-1/2 -translate-y-1/2 text-gray-500 hover:text-gray-700 transition-colors" 
                                    title="Mostrar/Ocultar senha">
                                <svg id="auth-signup-password-icon-hide" class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"></path>
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z"></path>
                                </svg>
                                <svg id="auth-signup-password-icon-show" class="w-5 h-5 hidden" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13.875 18.825A10.05 10.05 0 0112 19c-4.478 0-8.268-2.943-9.543-7a9.97 9.97 0 011.563-3.029m5.858.908a3 3 0 114.243 4.243M9.878 9.878l4.242 4.242M9.88 9.88l-3.29-3.29m7.532 7.532l3.29 3.29M3 3l3.59 3.59m0 0A9.953 9.953 0 0112 5c4.478 0 8.268 2.943 9.543 7a10.025 10.025 0 01-4.132 5.411m0 0L21 21"></path>
                                </svg>
                            </button>
                        </div>
                    </div>
                    <div>
                        <label class="block text-sm font-medium text-gray-700 mb-1">Confirmar Senha</label>
                        <div class="relative">
                            <input id="auth-signup-password-confirm" type="password" placeholder="Digite a senha novamente" required minlength="6" 
                                   class="w-full px-4 py-3 pr-12 rounded-lg bg-gray-50 border border-gray-300 focus:ring-2 focus:border-transparent transition-all" 
                                   style="--tw-ring-color: var(--cor-primaria);">
                            <button type="button" onclick="togglePasswordVisibility('auth-signup-password-confirm')" 
                                    class="absolute right-3 top-1/2 -translate-y-1/2 text-gray-500 hover:text-gray-700 transition-colors" 
                                    title="Mostrar/Ocultar senha">
                                <svg id="auth-signup-password-confirm-icon-hide" class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"></path>
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z"></path>
                                </svg>
                                <svg id="auth-signup-password-confirm-icon-show" class="w-5 h-5 hidden" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13.875 18.825A10.05 10.05 0 0112 19c-4.478 0-8.268-2.943-9.543-7a9.97 9.97 0 011.563-3.029m5.858.908a3 3 0 114.243 4.243M9.878 9.878l4.242 4.242M9.88 9.88l-3.29-3.29m7.532 7.532l3.29 3.29M3 3l3.59 3.59m0 0A9.953 9.953 0 0112 5c4.478 0 8.268 2.943 9.543 7a10.025 10.025 0 01-4.132 5.411m0 0L21 21"></path>
                                </svg>
                            </button>
                        </div>
                    </div>
                    <button id="auth-signup-submit" type="submit" 
                            class="w-full px-4 py-3 font-semibold text-white rounded-lg transition-all hover:opacity-90" 
                            style="background: var(--cor-primaria);">
                        Cadastrar Endereço
                    </button>
                    <p id="auth-signup-error" class="text-sm text-red-600 hidden mt-2"></p>
                    <p id="auth-signup-success" class="text-sm text-green-600 hidden mt-2"></p>
                </form>
            </div>
        </div>
    </div>
</div>

<script>
// ====================================================================
// SISTEMA DE AUTENTICAÇÃO DE CLIENTES
// ====================================================================

function openAuthModal() {
    document.getElementById('auth-modal').classList.remove('hidden');
    document.body.style.overflow = 'hidden';
    
    // Carregar dados salvos se existirem
    loadRememberedLoginData();
}

function closeAuthModal() {
    document.getElementById('auth-modal').classList.add('hidden');
    document.body.style.overflow = '';
    // Limpar mensagens de erro
    document.getElementById('auth-login-error').classList.add('hidden');
    document.getElementById('auth-signup-error').classList.add('hidden');
    document.getElementById('auth-login-success').classList.add('hidden');
    document.getElementById('auth-signup-success').classList.add('hidden');
}

function switchAuthTab(tab) {
    const loginTab = document.getElementById('auth-tab-login');
    const signupTab = document.getElementById('auth-tab-signup');
    const loginForm = document.getElementById('auth-form-login');
    const signupForm = document.getElementById('auth-form-signup');
    
    if (tab === 'login') {
        loginTab.style.borderColor = 'var(--cor-primaria)';
        loginTab.style.color = 'var(--cor-primaria)';
        signupTab.style.borderColor = 'transparent';
        signupTab.style.color = '#6b7280';
        loginForm.classList.remove('hidden');
        signupForm.classList.add('hidden');
    } else {
        signupTab.style.borderColor = 'var(--cor-primaria)';
        signupTab.style.color = 'var(--cor-primaria)';
        loginTab.style.borderColor = 'transparent';
        loginTab.style.color = '#6b7280';
        signupForm.classList.remove('hidden');
        loginForm.classList.add('hidden');
    }
    
    // Limpar mensagens
    document.getElementById('auth-login-error').classList.add('hidden');
    document.getElementById('auth-signup-error').classList.add('hidden');
    document.getElementById('auth-login-success').classList.add('hidden');
    document.getElementById('auth-signup-success').classList.add('hidden');
}

// Função para mostrar/ocultar senha
function togglePasswordVisibility(inputId) {
    const input = document.getElementById(inputId);
    const iconHide = document.getElementById(inputId + '-icon-hide');
    const iconShow = document.getElementById(inputId + '-icon-show');
    
    if (input.type === 'password') {
        input.type = 'text';
        iconHide.classList.add('hidden');
        iconShow.classList.remove('hidden');
    } else {
        input.type = 'password';
        iconHide.classList.remove('hidden');
        iconShow.classList.add('hidden');
    }
}

// Função para aplicar máscara de telefone
function applyPhoneMask(value) {
    // Remove tudo que não é número
    const numbers = value.replace(/\D/g, '');
    
    // Aplica a máscara
    if (numbers.length <= 10) {
        // Formato: (00) 0000-0000
        return numbers.replace(/(\d{2})(\d{4})(\d{0,4})/, '($1) $2-$3').replace(/-$/, '');
    } else {
        // Formato: (00) 00000-0000
        return numbers.replace(/(\d{2})(\d{5})(\d{0,4})/, '($1) $2-$3').replace(/-$/, '');
    }
}

// Adicionar máscara aos campos de telefone
document.addEventListener('DOMContentLoaded', () => {
    const phoneInputs = [
        document.getElementById('auth-login-phone'),
        document.getElementById('auth-signup-phone')
    ];
    
    phoneInputs.forEach(input => {
        if (input) {
            input.addEventListener('input', (e) => {
                e.target.value = applyPhoneMask(e.target.value);
            });
        }
    });
});

// Handler de Login
document.getElementById('auth-form-login').addEventListener('submit', async (e) => {
    e.preventDefault();
    
    const phone = document.getElementById('auth-login-phone').value;
    const password = document.getElementById('auth-login-password').value;
    const submitBtn = document.getElementById('auth-login-submit');
    const errorMsg = document.getElementById('auth-login-error');
    const successMsg = document.getElementById('auth-login-success');
    
    // Desabilitar botão e mostrar loading
    submitBtn.disabled = true;
    submitBtn.innerHTML = '<svg class="animate-spin h-5 w-5 mx-auto" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg>';
    errorMsg.classList.add('hidden');
    successMsg.classList.add('hidden');
    
    // Mostrar overlay de loading
    const loadingOverlay = document.getElementById('auth-loading-overlay');
    const loadingText = document.getElementById('auth-loading-text');
    loadingText.textContent = 'Fazendo loguin...';
    loadingOverlay.classList.add('active');
    
    try {
        debugLog('🔐 Tentando fazer login com telefone:', phone);
        
        // Limpar telefone (remover formatação)
        const cleanPhone = phone.replace(/\D/g, '');
        
        // Buscar usuário pelo telefone na tabela usuarios
        debugLog('📞 Buscando usuário com telefone:', cleanPhone);
        debugLog('📞 Telefone formatado:', phone);
        
        let userProfile = null;
        let userEmail = null;
        
        try {
            // Buscar todos os usuários e comparar apenas dígitos (mais confiável)
            debugLog('🔍 Buscando todos os usuários da tabela clientes...');
            const { data: allUsers, error: fetchError } = await supabase
                .from('clientes')
                .select('user_id, nome_completo, email, telefone')
                .not('telefone', 'is', null);
            
            debugLog(`📊 Total de usuários encontrados: ${allUsers?.length || 0}`);
            if (allUsers && allUsers.length > 0) {
                debugLog('📋 Telefones no banco:', allUsers.map(u => u.telefone));
            }
            
            if (fetchError) {
                // Se erro na coluna email, tentar sem ela
                if (fetchError.code === 'PGRST204' || fetchError.message?.includes('email')) {
                    debugLog('⚠️ Coluna email não existe. Tentando sem ela...');
                    
                    const { data: usersNoEmail, error: error2 } = await supabase
                        .from('clientes')
                        .select('user_id, nome_completo, telefone')
                        .not('telefone', 'is', null);
                    
                    if (error2) throw error2;
                    
                    debugLog(`📊 Total de usuários (sem email): ${usersNoEmail?.length || 0}`);
                    
                    // Encontrar usuário comparando apenas dígitos
                    userProfile = usersNoEmail?.find(user => {
                        if (!user.telefone) return false;
                        const userCleanPhone = user.telefone.replace(/\D/g, '');
                        debugLog(`🔍 Comparando: ${userCleanPhone} === ${cleanPhone}`);
                        return userCleanPhone === cleanPhone;
                    });
                    
                    userEmail = null;
                } else {
                    throw fetchError;
                }
            } else {
                // Encontrar usuário comparando apenas dígitos
                userProfile = allUsers?.find(user => {
                    if (!user.telefone) return false;
                    const userCleanPhone = user.telefone.replace(/\D/g, '');
                    debugLog(`🔍 Comparando: ${userCleanPhone} === ${cleanPhone}`);
                    return userCleanPhone === cleanPhone;
                });
                
                userEmail = userProfile?.email;
                debugLog(`✅ Usuário encontrado:`, userProfile);
            }
        } catch (err) {
            console.error('❌ Erro ao buscar usuário:', err);
            throw new Error('Telefone não encontrado. Verifique o número ou cadastre-se.');
        }
        
        if (!userProfile) {
            debugLog('❌ Telefone não encontrado:', cleanPhone);
            debugLog('❌ Telefone formatado tentado:', phone);
            debugLog('⚠️ Possíveis causas:');
            debugLog('   1. Telefone não está cadastrado');
            debugLog('   2. Políticas RLS estão bloqueando a leitura');
            debugLog('   3. Formato do telefone no banco é diferente');
            throw new Error('Telefone não encontrado. Verifique o número ou cadastre-se.');
        }
        
        debugLog('👤 Usuário encontrado:', userProfile);
        
        // Se não tem email, precisamos buscar de outra forma
        if (!userEmail) {
            debugLog('⚠️ Email não disponível na tabela. Buscando via RPC...');
            
            // Criar uma função RPC temporária ou usar método alternativo
            // Por enquanto, vamos pedir para executar o script SQL
            throw new Error('Execute o script SQL "supabase_add_email_to_usuarios.sql" no Supabase Dashboard primeiro.');
        }
        
        debugLog('📧 Email encontrado:', userEmail);
        
        // Fazer login com email e senha
        const { data, error } = await supabase.auth.signInWithPassword({
            email: userEmail,
            password: password,
        });
        
        if (error) {
            console.error('❌ Erro no login:', error);
            throw error;
        }
        
        debugLog('✅ Login bem-sucedido:', data);
        
        // Salvar dados se "Lembrar-me" estiver marcado
        const rememberMe = document.getElementById('auth-remember-me').checked;
        if (rememberMe) {
            localStorage.setItem('rememberedPhone', phone);
            localStorage.setItem('rememberedPassword', password);
            localStorage.setItem('rememberMe', 'true');
            debugLog('💾 Dados salvos para próximo login');
        } else {
            localStorage.removeItem('rememberedPhone');
            localStorage.removeItem('rememberedPassword');
            localStorage.removeItem('rememberMe');
            debugLog('🗑️ Dados de login removidos');
        }
        
        // Remover overlay de loading
        loadingOverlay.classList.remove('active');
        
        successMsg.textContent = 'Login realizado com sucesso!';
        successMsg.classList.remove('hidden');
        
        debugLog('✅ Login completo. Redirecionando...');
        
        // Fechar modal após 1 segundo e prosseguir com checkout
        setTimeout(() => {
            closeAuthModal();
            // Garante que a rolagem seja restaurada antes de prosseguir
            document.body.style.overflow = ''; 
            setTimeout(() => proceedToCheckout(), 50); // Pequeno delay para garantir a transição
        }, 1000);
        
    } catch (error) {
        console.error('❌ Erro completo no login:', error);
        
        // Remover overlay de loading
        loadingOverlay.classList.remove('active');
        
        let errorMessage = 'Erro ao fazer login. Tente novamente.';
        
        if (error.message === 'Invalid login credentials') {
            errorMessage = 'Telefone ou senha incorretos.';
        } else if (error.message.includes('Telefone não encontrado')) {
            errorMessage = error.message;
        } else if (error.message.includes('usuário sem email')) {
            errorMessage = error.message;
        } else if (error.message.includes('Email not confirmed')) {
            errorMessage = 'Email não confirmado. Verifique sua caixa de entrada.';
        } else if (error.message.includes('User not found')) {
            errorMessage = 'Usuário não encontrado. Verifique o telefone ou cadastre-se.';
        }
        
        errorMsg.textContent = errorMessage;
        errorMsg.classList.remove('hidden');
        submitBtn.disabled = false;
        submitBtn.textContent = 'Entrar';
    }
});

// Carregar dados salvos ao abrir o modal de login
function loadRememberedLoginData() {
    const rememberMe = localStorage.getItem('rememberMe') === 'true';
    
    if (rememberMe) {
        const savedPhone = localStorage.getItem('rememberedPhone');
        const savedPassword = localStorage.getItem('rememberedPassword');
        
        if (savedPhone) {
            document.getElementById('auth-login-phone').value = savedPhone;
        }
        if (savedPassword) {
            document.getElementById('auth-login-password').value = savedPassword;
        }
        document.getElementById('auth-remember-me').checked = true;
        
        debugLog('✅ Dados de login carregados do localStorage');
    }
}

// Limpar dados salvos quando desmarcar o checkbox
document.getElementById('auth-remember-me')?.addEventListener('change', function(e) {
    if (!e.target.checked) {
        localStorage.removeItem('rememberedPhone');
        localStorage.removeItem('rememberedPassword');
        localStorage.removeItem('rememberMe');
        debugLog('🗑️ Dados de login removidos (checkbox desmarcado)');
    }
});

// Handler de Cadastro
document.getElementById('auth-form-signup').addEventListener('submit', async (e) => {
    e.preventDefault();
    
    const name = document.getElementById('auth-signup-name').value;
    const email = document.getElementById('auth-signup-email').value;
    const phone = document.getElementById('auth-signup-phone').value;
    const password = document.getElementById('auth-signup-password').value;
    const passwordConfirm = document.getElementById('auth-signup-password-confirm').value;
    const submitBtn = document.getElementById('auth-signup-submit');
    const errorMsg = document.getElementById('auth-signup-error');
    const successMsg = document.getElementById('auth-signup-success');
    
    // Validar senhas
    if (password !== passwordConfirm) {
        errorMsg.textContent = 'As senhas não coincidem.';
        errorMsg.classList.remove('hidden');
        return;
    }
    
    // Validar telefone
    const cleanPhone = phone.replace(/\D/g, '');
    if (cleanPhone.length < 10 || cleanPhone.length > 11) {
        errorMsg.textContent = 'Telefone inválido. Use o formato (00) 00000-0000';
        errorMsg.classList.remove('hidden');
        return;
    }
    
    // Desabilitar botão e mostrar loading
    submitBtn.disabled = true;
    submitBtn.innerHTML = '<svg class="animate-spin h-5 w-5 mx-auto" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg>';
    errorMsg.classList.add('hidden');
    successMsg.classList.add('hidden');
    
    try {
        debugLog('📝 Tentando cadastrar usuário:', { email, name, phone });
        
        // Mostrar mensagem de validação
        successMsg.textContent = '🔍 Verificando se telefone já está cadastrado...';
        successMsg.classList.remove('hidden');
        
        // ✅ VALIDAÇÃO 1: Verificar telefone usando função RPC
        debugLog('📞 Verificando se telefone já existe (via RPC):', phone);
        debugLog('📞 Telefone limpo para comparação:', cleanPhone);
        
        const { data: phoneExists, error: phoneCheckError } = await supabase.rpc('check_phone_exists', {
            phone_to_check: phone
        });
        
        if (phoneCheckError) {
            console.error('⚠️ Erro ao validar telefone:', phoneCheckError);
            debugLog('⚠️ ATENÇÃO: Função RPC não encontrada ou erro ao executar.');
            debugLog('⚠️ Você precisa executar o script CREATE_PHONE_VALIDATION_FUNCTION.sql no Supabase!');
            debugLog('⚠️ Continuando mesmo assim (constraint do banco vai proteger)...');
        } else {
            debugLog('📊 Resultado da validação RPC:', phoneExists);
            
            if (phoneExists === true) {
                debugLog('❌ Telefone já cadastrado na base de dados!');
                throw new Error('Este telefone já está cadastrado. Use outro número ou faça login.');
            } else {
                debugLog('✅ Telefone disponível - pode prosseguir');
            }
        }
        
        // ✅ VALIDAÇÃO 2: Verificar se email já existe na tabela clientes
        debugLog('📧 Verificando se email já existe (via RPC):', email);
        successMsg.textContent = '🔍 Verificando se email já está cadastrado...';
        
        const { data: emailExists, error: emailCheckError } = await supabase.rpc('check_email_exists', {
            email_to_check: email
        });
        
        if (emailCheckError) {
            console.error('⚠️ Erro ao validar email:', emailCheckError);
            debugLog('⚠️ ATENÇÃO: Função RPC check_email_exists não encontrada.');
            debugLog('⚠️ Você precisa executar o script CREATE_EMAIL_VALIDATION_FUNCTION.sql no Supabase!');
            debugLog('⚠️ Continuando mesmo assim (erro aparecerá ao tentar criar conta)...');
        } else {
            debugLog('📊 Resultado da validação de email:', emailExists);
            
            if (emailExists === true) {
                debugLog('❌ Email já cadastrado na base de dados!');
                throw new Error('Este email já está cadastrado. Use outro email ou faça login.');
            } else {
                debugLog('✅ Email disponível - pode prosseguir');
            }
        }
        
        debugLog('✅ Email e telefone disponíveis. Preparando dados para cadastro...');
        
        // ⚠️ NÃO criar conta no Auth ainda!
        // Armazenar dados temporariamente e abrir modal de endereço
        const tempUserData = {
            nome_completo: name,
            email: email,
            telefone: phone,
            password: password  // Armazenar senha temporariamente (será usada depois)
        };
        
        successMsg.textContent = 'Dados validados! Agora complete seu endereço.';
        successMsg.classList.remove('hidden');
        
        debugLog('✅ Dados validados. Abrindo modal de endereço...');
        
        // Limpar formulário
        document.getElementById('auth-form-signup').reset();
        
        // Abrir modal de endereço após 1 segundo
        setTimeout(() => {
            closeAuthModal();
            openSignupAddressModal(null, tempUserData);  // null = ainda não criou no Auth
        }, 1000);
        
    } catch (error) {
        console.error('❌ Erro completo no cadastro:', error);
        debugLog('❌ ERRO NO MODAL DE CADASTRO (não no modal de endereço!)');
        debugLog('❌ Tipo do erro:', error.constructor.name);
        debugLog('❌ Mensagem:', error.message);
        
        let errorMessage = 'Erro ao criar conta. Tente novamente.';
        let isPhoneError = false;
        let isEmailError = false;
        
        // Verificar mensagens de erro específicas
        if (error.message) {
            if (error.message.includes('telefone já está cadastrado')) {
                errorMessage = error.message;
                isPhoneError = true;
                debugLog('⚠️ Telefone já cadastrado:', cleanPhone);
            } else if (error.message.includes('Database error saving new user')) {
                // Erro do trigger - provavelmente telefone duplicado
                errorMessage = 'Este telefone já está cadastrado. Use outro número ou faça login.';
                isPhoneError = true;
                debugLog('⚠️ Erro de banco - telefone duplicado (trigger):', cleanPhone);
            } else if (error.message.includes('duplicate key value') || error.message.includes('unique constraint')) {
                // Erro de constraint única
                errorMessage = 'Este telefone ou email já está cadastrado. Use outros dados ou faça login.';
                isPhoneError = true;
                debugLog('⚠️ Violação de constraint única:', error.message);
            } else if (error.message.includes('email já está cadastrado')) {
                errorMessage = error.message;
                isEmailError = true;
                debugLog('⚠️ Email já cadastrado:', email);
            } else if (error.message.includes('already registered') || error.message.includes('User already registered')) {
                errorMessage = 'Este email já está cadastrado. Use outro email ou faça login.';
                isEmailError = true;
                debugLog('⚠️ Email já cadastrado (Supabase Auth):', email);
            } else if (error.message.includes('Password') || error.message.includes('password')) {
                errorMessage = 'A senha deve ter no mínimo 6 caracteres.';
            } else if (error.message.includes('Email') && !error.message.includes('email já está cadastrado')) {
                errorMessage = 'Email inválido. Verifique e tente novamente.';
            } else if (error.message.includes('Signup requires a valid password')) {
                errorMessage = 'Senha inválida. Use no mínimo 6 caracteres.';
            } else if (error.message.includes('disabled')) {
                errorMessage = 'Cadastro desabilitado. Entre em contato com o suporte.';
            } else {
                // Mostrar mensagem de erro original para debug
                errorMessage = `Erro: ${error.message}`;
            }
        }
        
        errorMsg.textContent = errorMessage;
        errorMsg.classList.remove('hidden');
        submitBtn.disabled = false;
        submitBtn.textContent = 'Cadastrar';
    }
});

// ====================================================================
// SISTEMA DE CADASTRO DE ENDEREÇO (APÓS SIGNUP)
// ====================================================================

let signupUserData = null;

function openSignupAddressModal(user, userData) {
    // Salvar dados do usuário E os dados pessoais do formulário
    // user será null se ainda não criou conta no Auth
    signupUserData = {
        user: user,  // null até finalizar cadastro
        nome_completo: userData.nome_completo,
        email: userData.email,
        telefone: userData.telefone,
        password: userData.password  // Armazenar senha temporariamente
    };
    
    debugLog('📋 Dados temporários armazenados para cadastro:', {
        nome: userData.nome_completo,
        email: userData.email,
        telefone: userData.telefone,
        hasPassword: !!userData.password
    });
    
    document.getElementById('signup-address-modal').classList.remove('hidden');
    document.body.style.overflow = 'hidden';
    
    // Carregar bairros no select
    populateSignupBairroSelect();
}

function closeSignupAddressModal() {
    document.getElementById('signup-address-modal').classList.add('hidden');
    document.body.style.overflow = '';
    signupUserData = null;
    
    // Limpar formulário
    document.getElementById('signup-address-form').reset();
    document.getElementById('signup-address-error').classList.add('hidden');
    document.getElementById('signup-address-success').classList.add('hidden');
}

function populateSignupBairroSelect() {
    const select = document.getElementById('signup-bairro');
    if (!select) return;
    
    // Limpar opções existentes (exceto a primeira)
    select.innerHTML = '<option value="">Selecione o bairro</option>';
    
    // Verificar se temos a lista de bairros carregada
    if (typeof neighborhoodsList !== 'undefined' && neighborhoodsList.length > 0) {
        neighborhoodsList.forEach(item => {
            const option = document.createElement('option');
            option.value = item.nome;
            option.textContent = item.nome.charAt(0).toUpperCase() + item.nome.slice(1);
            option.dataset.cidade = item.cidade || '';
            select.appendChild(option);
        });
        debugLog('✅ Select de bairros populado no signup com', neighborhoodsList.length, 'bairros');
    } else {
        debugLog('⚠️ Lista de bairros não disponível ainda no signup');
    }
}

function handleSignupBairroChange() {
    const bairroSelect = document.getElementById('signup-bairro');
    const selectedBairro = bairroSelect.value;
    
    if (selectedBairro) {
        debugLog('🏘️ Bairro selecionado no signup:', selectedBairro);
        
        // Buscar informações do bairro (taxa, cidade, etc)
        if (typeof neighborhoodsList !== 'undefined') {
            const bairroInfo = neighborhoodsList.find(b => b.nome === selectedBairro);
            if (bairroInfo && bairroInfo.cidade) {
                // Preencher cidade automaticamente
                const cidadeInput = document.getElementById('signup-cidade');
                if (cidadeInput) {
                    cidadeInput.value = bairroInfo.cidade;
                    debugLog('✅ Cidade preenchida automaticamente no signup:', bairroInfo.cidade);
                }
            }
        }
    }
}

// Handler do formulário de endereço do signup
// Aguardar DOM estar pronto antes de adicionar event listener
function initSignupAddressForm() {
    const form = document.getElementById('signup-address-form');
    if (!form) {
        console.error('❌ Formulário signup-address-form não encontrado');
        return;
    }
    
    form.addEventListener('submit', async (e) => {
    e.preventDefault();
    
    if (!signupUserData) {
        console.error('❌ Dados do usuário não encontrados');
        return;
    }
    
    const submitBtn = document.getElementById('signup-address-submit');
    const errorMsg = document.getElementById('signup-address-error');
    const successMsg = document.getElementById('signup-address-success');
    
    // Validar campos obrigatórios
    const rua = document.getElementById('signup-rua').value.trim();
    const numero = document.getElementById('signup-numero').value.trim();
    const bairro = document.getElementById('signup-bairro').value.trim();
    const cidade = document.getElementById('signup-cidade').value.trim();
    
    if (!rua || !numero || !bairro || !cidade) {
        errorMsg.textContent = 'Preencha todos os campos obrigatórios (*).';
        errorMsg.classList.remove('hidden');
        successMsg.classList.add('hidden');
        return;
    }
    
    // Desabilitar botão e mostrar loading
    submitBtn.disabled = true;
    submitBtn.innerHTML = '<svg class="animate-spin h-5 w-5 mx-auto" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg>';
    errorMsg.classList.add('hidden');
    successMsg.classList.add('hidden');
    
    try {
        // PASSO 1: Criar conta no Supabase Auth
        debugLog('🔐 PASSO 1: Criando conta no Supabase Auth...');
        successMsg.textContent = 'Criando sua conta...';
        successMsg.classList.remove('hidden');
        
        const { data: authData, error: authError } = await supabase.auth.signUp({
            email: signupUserData.email,
            password: signupUserData.password,
            options: {
                data: {
                    full_name: signupUserData.nome_completo,
                    phone: signupUserData.telefone
                }
            }
        });
        
        if (authError) {
            console.error('❌ Erro ao criar conta no Auth:', authError);
            throw authError;
        }
        
        if (!authData.user) {
            throw new Error('Erro ao criar conta. Tente novamente.');
        }
        
        debugLog('✅ Conta criada no Auth com sucesso!', authData.user.id);
        
        // PASSO 2: Salvar dados completos na tabela clientes
        debugLog('💾 PASSO 2: Salvando dados completos na tabela clientes...');
        successMsg.textContent = 'Salvando seus dados...';
        
        const completeUserData = {
            user_id: authData.user.id,
            nome_completo: signupUserData.nome_completo,
            email: signupUserData.email,
            telefone: signupUserData.telefone,
            cep: '',
            rua: rua,
            numero: numero,
            bairro: bairro,
            cidade: cidade,
            complemento: document.getElementById('signup-complemento').value.trim()
        };
        
        const { data, error } = await supabase
            .from('clientes')
            .insert(completeUserData)
            .select()
            .maybeSingle();
        
        if (error) {
            console.error('❌ Erro ao salvar dados na tabela:', error);
            // ⚠️ PROBLEMA: Conta foi criada no Auth mas dados não foram salvos na tabela
            // Não podemos deletar a conta do Auth com a chave anon
            debugLog('⚠️ ATENÇÃO: Conta criada no Auth mas dados não salvos na tabela!');
            debugLog('⚠️ User ID:', authData.user.id);
            debugLog('⚠️ Email:', authData.user.email);
            throw error;
        }
        
        debugLog('✅ Dados salvos com sucesso!', data);
        
        successMsg.textContent = 'Cadastro completo! Redirecionando...';
        successMsg.classList.remove('hidden');
        
        // Fechar modal e redirecionar para login após 2 segundos
        setTimeout(() => {
            closeSignupAddressModal();
            alert('Cadastro completo! Faça login para continuar.');
            openAuthModal();
            switchAuthTab('login');
        }, 2000);
        
    } catch (error) {
        console.error('❌ Erro ao salvar dados do cliente:', error);
        debugLog('❌ ERRO NO MODAL DE ENDEREÇO:', error);
        debugLog('❌ Código do erro:', error.code);
        debugLog('❌ Mensagem do erro:', error.message);
        
        // Verificar se é erro de telefone duplicado (constraint UNIQUE)
        let errorMessage = 'Erro ao salvar dados. Tente novamente.';
        
        if (error.message && error.message.includes('Este telefone já está cadastrado')) {
            errorMessage = error.message;
            debugLog('⚠️ Erro de telefone duplicado detectado (mensagem customizada)');
        } else if (error.message && (error.message.includes('unique_telefone') || error.message.includes('duplicate key'))) {
            errorMessage = '⚠️ ERRO: Este telefone já foi cadastrado por outro usuário. A validação inicial falhou. Por favor, reporte este bug.';
            debugLog('🐛 BUG: Constraint UNIQUE violada - a validação inicial não funcionou!');
        } else if (error.code === '23505') {
            // Código PostgreSQL para violação de constraint única
            errorMessage = '⚠️ ERRO: Este telefone já foi cadastrado. A validação inicial falhou. Por favor, reporte este bug.';
            debugLog('🐛 BUG: Código 23505 - Constraint UNIQUE violada!');
        }
        
        errorMsg.textContent = errorMessage;
        errorMsg.classList.remove('hidden');
        successMsg.classList.add('hidden');
        
        // Reabilitar botão
        submitBtn.disabled = false;
        submitBtn.textContent = 'Finalizar Cadastro';
    }
    });
}

// Inicializar formulário quando DOM estiver pronto
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initSignupAddressForm);
} else {
    initSignupAddressForm();
}

// Verificar se usuário está logado ao carregar a página e atualizar botões
(async () => {
    debugLog('🔍 Verificando sessão ao carregar página...');
    
    const { data: { session } } = await supabase.auth.getSession();
    
    if (session) {
        debugLog('✅ Sessão encontrada:', session.user.email);
        
        // Verificar se o usuário realmente existe na tabela clientes
        try {
            const { data: userProfile, error: profileError } = await supabase
                .from('clientes')
                .select('*')
                .eq('user_id', session.user.id)
                .single();
            
            if (profileError && profileError.code === 'PGRST116') {
                // Usuário não tem perfil - permitir acesso mesmo assim
                debugLog('⚠️ Usuário logado sem perfil completo.');
                updateAuthButtons(session);
                return;
            } else if (profileError) {
                // Outro erro - pode ser usuário deletado
                console.error('❌ Erro ao verificar perfil:', profileError);
                debugLog('⚠️ Sessão inválida detectada. Fazendo logout...');
                await supabase.auth.signOut();
                location.reload();
                return;
            }
            
            debugLog('✅ Usuário válido. Atualizando botões...');
            updateAuthButtons(session);
            
        } catch (error) {
            console.error('❌ Erro ao validar sessão:', error);
            debugLog('⚠️ Erro na validação. Fazendo logout...');
            await supabase.auth.signOut();
            location.reload();
        }
    } else {
        debugLog('ℹ️ Nenhuma sessão ativa');
    }
})();

// Atualizar botões de autenticação baseado no status de login
function updateAuthButtons(session) {
    const desktopBtn = document.getElementById('auth-button-desktop');
    const mobileBtn = document.getElementById('auth-button-mobile');
    
    if (session) {
        // Usuário logado - mostrar "Perfil"
        if (desktopBtn) {
            desktopBtn.onclick = () => openProfileModal();
            desktopBtn.title = 'Meu Perfil';
            desktopBtn.querySelector('span').textContent = 'Perfil';
        }
        if (mobileBtn) {
            mobileBtn.onclick = () => openProfileModal();
            mobileBtn.title = 'Meu Perfil';
            mobileBtn.querySelector('span').textContent = 'Meu Perfil';
        }
    } else {
        // Usuário não logado - mostrar "Entrar"
        if (desktopBtn) {
            desktopBtn.onclick = () => openAuthModal();
            desktopBtn.title = 'Entrar ou Cadastrar';
            desktopBtn.querySelector('span').textContent = 'Entrar';
        }
        if (mobileBtn) {
            mobileBtn.onclick = () => openAuthModal();
            mobileBtn.title = 'Entrar ou Cadastrar';
            mobileBtn.querySelector('span').textContent = 'Entrar / Cadastrar';
        }
    }
}

// Listener para mudanças de autenticação
supabase.auth.onAuthStateChange(async (event, session) => {
    debugLog('🔐 Auth state changed:', event);
    
    // Tratar erro de token inválido
    if (event === 'TOKEN_REFRESHED') {
        debugLog('✅ Token renovado com sucesso');
    } else if (event === 'SIGNED_OUT') {
        debugLog('🚪 Usuário deslogado');
        // Limpar dados locais
        localStorage.removeItem('supabase.auth.token');
    }
    
    updateAuthButtons(session);
});

// Capturar erros de refresh token globalmente
window.addEventListener('unhandledrejection', (event) => {
    if (event.reason && event.reason.message && 
        (event.reason.message.includes('Invalid Refresh Token') || 
         event.reason.message.includes('Refresh Token Not Found'))) {
        console.warn('⚠️ Erro de refresh token detectado, limpando sessão...');
        event.preventDefault(); // Prevenir erro no console
        
        // Limpar sessão silenciosamente
        supabase.auth.signOut().then(() => {
            localStorage.clear();
            debugLog('🧹 Sessão limpa devido a token inválido');
        });
    }
});
</script>

<!-- Modal de Perfil do Cliente -->
<div id="profile-modal" class="fixed inset-0 z-[1000] hidden" style="touch-action: none;">
    <div class="absolute inset-0 bg-black/60 backdrop-blur-sm" onclick="closeProfileModal()"></div>
    <div class="relative z-[1001] h-full flex items-center justify-center p-4" style="pointer-events: none;">
        <div class="bg-white rounded-2xl shadow-2xl w-full max-w-2xl max-h-[90vh] flex flex-col" style="pointer-events: auto; touch-action: pan-y;">
            <!-- Header -->
            <div class="flex-shrink-0 bg-white border-b p-6">
                <div class="flex items-center justify-between">
                    <div class="flex items-center space-x-3">
                        <div class="w-10 h-10 rounded-full flex items-center justify-center" style="background-color: var(--cor-primaria);">
                            <svg class="w-6 h-6 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z"></path>
                            </svg>
                        </div>
                        <div>
                            <h2 class="text-xl font-bold">Meu Perfil</h2>
                            <p id="profile-user-email" class="text-sm text-gray-600"></p>
                        </div>
                    </div>
                    
                    <!-- Botões de ação -->
                    <div class="flex items-center space-x-2">
                        <!-- Botão Sair -->
                        <button onclick="logout()" class="flex items-center space-x-2 px-4 py-2 rounded-lg font-medium text-sm transition-all hover:shadow-md" style="background-color: #fee2e2; color: #dc2626; border: 1px solid #fecaca;" onmouseover="this.style.backgroundColor='#fecaca'; this.style.transform='translateY(-1px)'" onmouseout="this.style.backgroundColor='#fee2e2'; this.style.transform='translateY(0)'" title="Sair da conta">
                            <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17 16l4-4m0 0l-4-4m4 4H7m6 4v1a3 3 0 01-3 3H6a3 3 0 01-3-3V7a3 3 0 013-3h4a3 3 0 013 3v1"></path>
                            </svg>
                            <span class="hidden sm:inline">Sair</span>
                        </button>
                        
                        <!-- Botão Fechar -->
                        <button onclick="closeProfileModal()" class="w-8 h-8 flex items-center justify-center rounded-full hover:bg-gray-100 transition-colors" style="color: var(--cor-texto-secundario);" title="Fechar">
                            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                            </svg>
                        </button>
                    </div>
                </div>
            </div>
            
            <div class="flex-1 overflow-y-auto p-6 space-y-6" style="-webkit-overflow-scrolling: touch; overscroll-behavior: contain;">
                <!-- Seção: Dados Pessoais -->
                <div class="bg-gray-50 rounded-xl p-5">
                    <div class="flex items-center justify-between mb-4">
                        <h3 class="text-lg font-semibold flex items-center space-x-2">
                            <svg class="w-5 h-5" style="color: var(--cor-primaria);" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z"></path>
                            </svg>
                            <span>Dados Pessoais</span>
                        </h3>
                        <button id="edit-personal-btn" onclick="togglePersonalEdit()" class="text-sm font-medium px-3 py-1 rounded-lg transition-colors" style="color: var(--cor-primaria); border: 1px solid var(--cor-primaria);" onmouseover="this.style.backgroundColor='var(--cor-primaria)'; this.style.color='white';" onmouseout="this.style.backgroundColor='transparent'; this.style.color='var(--cor-primaria)';">
                            Editar
                        </button>
                    </div>
                    
                    <!-- Visualização dos Dados Pessoais -->
                    <div id="personal-display" class="space-y-2">
                        <div class="flex items-center space-x-2">
                            <span class="text-sm font-medium text-gray-700">Nome:</span>
                            <span id="personal-nome-text" class="text-sm text-gray-600">Não informado</span>
                        </div>
                        <div class="flex items-center space-x-2">
                            <span class="text-sm font-medium text-gray-700">Telefone:</span>
                            <span id="personal-telefone-text" class="text-sm text-gray-600">Não informado</span>
                        </div>
                    </div>
                    
                    <!-- Formulário de Edição -->
                    <form id="personal-form" class="hidden space-y-3">
                        <div>
                            <label class="block text-sm font-medium text-gray-700 mb-1">Nome Completo</label>
                            <input id="profile-nome" type="text" placeholder="Seu nome completo" class="w-full px-3 py-2 rounded-lg bg-white border border-gray-300 focus:ring-2 focus:border-transparent text-sm" style="--tw-ring-color: var(--cor-primaria);">
                        </div>
                        <div>
                            <label class="block text-sm font-medium text-gray-700 mb-1">Telefone</label>
                            <input id="profile-telefone" type="text" placeholder="(28) 9 9999-9999" class="w-full px-3 py-2 rounded-lg bg-white border border-gray-300 focus:ring-2 focus:border-transparent text-sm" style="--tw-ring-color: var(--cor-primaria);">
                        </div>
                        <div class="flex space-x-2 pt-2">
                            <button type="button" onclick="cancelPersonalEdit()" class="flex-1 px-4 py-2 rounded-lg font-medium text-sm transition-colors bg-gray-200 hover:bg-gray-300">
                                Cancelar
                            </button>
                            <button type="submit" class="flex-1 px-4 py-2 rounded-lg font-medium text-sm text-white transition-colors" style="background-color: var(--cor-primaria);" onmouseover="this.style.opacity='0.9'" onmouseout="this.style.opacity='1'">
                                Salvar Dados
                            </button>
                        </div>
                        <p id="personal-save-error" class="text-sm text-red-600 hidden mt-2"></p>
                        <p id="personal-save-success" class="text-sm text-green-600 hidden mt-2"></p>
                    </form>
                </div>
                
                <!-- Seção: Endereço -->
                <div class="bg-gray-50 rounded-xl p-5">
                    <div class="flex items-center justify-between mb-4">
                        <h3 class="text-lg font-semibold flex items-center space-x-2">
                            <svg class="w-5 h-5" style="color: var(--cor-primaria);" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17.657 16.657L13.414 20.9a1.998 1.998 0 01-2.827 0l-4.244-4.243a8 8 0 1111.314 0z"></path>
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 11a3 3 0 11-6 0 3 3 0 016 0z"></path>
                            </svg>
                            <span>Endereço de Entrega</span>
                        </h3>
                        <button id="edit-address-btn" onclick="toggleAddressEdit()" class="text-sm font-medium px-3 py-1 rounded-lg transition-colors" style="color: var(--cor-primaria); border: 1px solid var(--cor-primaria);" onmouseover="this.style.backgroundColor='var(--cor-primaria)'; this.style.color='white';" onmouseout="this.style.backgroundColor='transparent'; this.style.color='var(--cor-primaria)';">
                            Editar
                        </button>
                    </div>
                    
                    <!-- Visualização do Endereço -->
                    <div id="address-display" class="space-y-2">
                        <p id="address-text" class="text-gray-600">Nenhum endereço cadastrado</p>
                    </div>
                    
                    <!-- Formulário de Edição -->
                    <form id="address-form" class="hidden space-y-3">
                        <div>
                            <label class="block text-sm font-medium text-gray-700 mb-1">Número *</label>
                            <input id="profile-numero" type="text" placeholder="123" required class="w-full px-3 py-2 rounded-lg bg-white border border-gray-300 focus:ring-2 focus:border-transparent text-sm" style="--tw-ring-color: var(--cor-primaria);">
                        </div>
                        <div>
                            <label class="block text-sm font-medium text-gray-700 mb-1">Rua *</label>
                            <input id="profile-rua" type="text" placeholder="Nome da rua" required class="w-full px-3 py-2 rounded-lg bg-white border border-gray-300 focus:ring-2 focus:border-transparent text-sm" style="--tw-ring-color: var(--cor-primaria);">
                        </div>
                        <div class="grid grid-cols-2 gap-3">
                            <div>
                                <label class="block text-sm font-medium text-gray-700 mb-1">Bairro *</label>
                                <!-- Select de bairros - populado dinamicamente da planilha -->
                                <select id="profile-bairro" required class="w-full px-3 py-2 rounded-lg bg-white border border-gray-300 focus:ring-2 focus:border-transparent text-sm" style="--tw-ring-color: var(--cor-primaria);" onchange="handleProfileBairroChange()">
                                    <option value="">Selecione o bairro</option>
                                </select>
                            </div>
                            <div>
                                <label class="block text-sm font-medium text-gray-700 mb-1">Cidade *</label>
                                <input id="profile-cidade" type="text" placeholder="Cidade" required class="w-full px-3 py-2 rounded-lg bg-white border border-gray-300 focus:ring-2 focus:border-transparent text-sm" style="--tw-ring-color: var(--cor-primaria);">
                            </div>
                        </div>
                        <div>
                            <label class="block text-sm font-medium text-gray-700 mb-1">Complemento (opcional)</label>
                            <input id="profile-complemento" type="text" placeholder="Apto, bloco, etc." class="w-full px-3 py-2 rounded-lg bg-white border border-gray-300 focus:ring-2 focus:border-transparent text-sm" style="--tw-ring-color: var(--cor-primaria);">
                        </div>
<!-- ... -->
                        <div class="flex space-x-2 pt-2">
                            <button type="button" onclick="cancelAddressEdit()" class="flex-1 px-4 py-2 rounded-lg font-medium text-sm transition-colors bg-gray-200 hover:bg-gray-300">
                                Cancelar
                            </button>
                            <button type="submit" class="flex-1 px-4 py-2 rounded-lg font-medium text-sm text-white transition-colors" style="background-color: var(--cor-primaria);" onmouseover="this.style.opacity='0.9'" onmouseout="this.style.opacity='1'">
                                Salvar Endereço
                            </button>
                        </div>
                        <p id="address-save-error" class="text-sm text-red-600 hidden mt-2"></p>
                        <p id="address-save-success" class="text-sm text-green-600 hidden mt-2"></p>
                    </form>
                </div>
                
                <!-- Seção: Histórico de Pedidos -->
                <div class="bg-gray-50 rounded-xl p-5">
                    <h3 class="text-lg font-semibold flex items-center space-x-2 mb-4">
                        <svg class="w-5 h-5" style="color: var(--cor-primaria);" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2"></path>
                        </svg>
                        <span>Meus Pedidos</span>
                    </h3>
                    <div id="orders-list" class="space-y-3">
                        <p class="text-gray-600 text-center py-4">Carregando pedidos...</p>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Modal: Meu Endereço (para checkout) -->
<div id="my-address-modal" class="fixed inset-0 z-[1000] hidden" style="touch-action: none;">
    <div class="absolute inset-0 bg-black/60 backdrop-blur-sm" onclick="closeMyAddressModal()"></div>
    <div class="relative z-[1001] h-full flex items-center justify-center p-4" style="pointer-events: none;">
        <div class="bg-white rounded-2xl shadow-2xl overflow-hidden max-w-lg w-full max-h-[90vh] flex flex-col" style="pointer-events: auto; touch-action: pan-y;">
            <!-- Header -->
            <div class="p-6 text-white" style="background: linear-gradient(to right, var(--cor-primaria), var(--cor-primaria));">
                <div class="flex items-center justify-between">
                    <div class="flex items-center space-x-3">
                        <div class="w-12 h-12 rounded-full bg-white/20 backdrop-blur-sm flex items-center justify-center">
                            <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17.657 16.657L13.414 20.9a1.998 1.998 0 01-2.827 0l-4.244-4.243a8 8 0 1111.314 0z"></path>
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 11a3 3 0 11-6 0 3 3 0 016 0z"></path>
                            </svg>
                        </div>
                        <div>
                            <h2 class="text-xl font-bold">Meu Endereço</h2>
                            <p class="text-sm" style="color: rgba(255, 255, 255, 0.9);">Confirme seu endereço de entrega</p>
                        </div>
                    </div>
                    <button onclick="closeMyAddressModal()" class="w-8 h-8 flex items-center justify-center rounded-full hover:bg-white/20 transition-colors" title="Fechar">
                        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                        </svg>
                    </button>
                </div>
            </div>
            
            <!-- Conteúdo -->
            <div class="flex-1 overflow-y-auto p-6" style="-webkit-overflow-scrolling: touch; overscroll-behavior: contain;">
                <!-- Loading State -->
                <div id="my-address-loading" class="text-center py-8">
                    <svg class="w-12 h-12 mx-auto mb-4 animate-spin" fill="none" stroke="currentColor" viewBox="0 0 24 24" style="color: var(--cor-primaria);">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"></path>
                    </svg>
                    <p class="text-gray-600">Carregando seu endereço...</p>
                </div>
                
                <!-- No Address State -->
                <div id="my-address-empty" class="hidden text-center py-8">
                    <svg class="w-16 h-16 mx-auto mb-4 text-gray-300" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17.657 16.657L13.414 20.9a1.998 1.998 0 01-2.827 0l-4.244-4.243a8 8 0 1111.314 0z"></path>
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 11a3 3 0 11-6 0 3 3 0 016 0z"></path>
                    </svg>
                    <h3 class="text-lg font-semibold text-gray-800 mb-2">Nenhum endereço cadastrado</h3>
                    <p class="text-gray-600 mb-6">Cadastre seu endereço no perfil para usar esta funcionalidade.</p>
                    <button onclick="openProfileFromAddress()" class="px-6 py-2 rounded-lg font-medium text-white transition-colors" style="background-color: var(--cor-primaria);" onmouseover="this.style.opacity='0.9'" onmouseout="this.style.opacity='1'">
                        Ir para Perfil
                    </button>
                </div>
                
                <!-- Address Display -->
                <div id="my-address-content" class="hidden space-y-4">
                    <div class="bg-blue-50 border border-blue-200 rounded-xl p-4">
                        <div class="flex items-start space-x-3">
                            <div class="flex-shrink-0 mt-1">
                                <svg class="w-5 h-5 text-blue-600" fill="currentColor" viewBox="0 0 20 20">
                                    <path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2v-3a1 1 0 00-1-1H9z" clip-rule="evenodd"></path>
                                </svg>
                            </div>
                            <div class="flex-1">
                                <p class="text-sm text-blue-800">Este é o endereço cadastrado no seu perfil. Confirme se está correto antes de continuar.</p>
                            </div>
                        </div>
                    </div>
                    
                    <div class="bg-gray-50 rounded-xl p-5 space-y-3">
                        <div class="flex items-start space-x-3">
                            <svg class="w-5 h-5 text-gray-400 mt-0.5 flex-shrink-0" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 12l2-2m0 0l7-7 7 7M5 10v10a1 1 0 001 1h3m10-11l2 2m-2-2v10a1 1 0 01-1 1h-3m-6 0a1 1 0 001-1v-4a1 1 0 011-1h2a1 1 0 011 1v4a1 1 0 001 1m-6 0h6"></path>
                            </svg>
                            <div class="flex-1">
                                <p class="text-sm text-gray-500 mb-1">Endereço</p>
                                <p id="modal-address-street" class="font-medium text-gray-800"></p>
                            </div>
                        </div>
                        
                        <div class="flex items-start space-x-3">
                            <svg class="w-5 h-5 text-gray-400 mt-0.5 flex-shrink-0" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 20l4-16m2 16l4-16M6 9h14M4 15h14"></path>
                            </svg>
                            <div class="flex-1">
                                <p class="text-sm text-gray-500 mb-1">Número</p>
                                <p id="modal-address-number" class="font-medium text-gray-800"></p>
                            </div>
                        </div>
                        
                        <div id="modal-address-complement-container" class="hidden flex items-start space-x-3">
                            <svg class="w-5 h-5 text-gray-400 mt-0.5 flex-shrink-0" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                            </svg>
                            <div class="flex-1">
                                <p class="text-sm text-gray-500 mb-1">Complemento</p>
                                <p id="modal-address-complement" class="font-medium text-gray-800"></p>
                            </div>
                        </div>
                        
                        <div class="flex items-start space-x-3">
                            <svg class="w-5 h-5 text-gray-400 mt-0.5 flex-shrink-0" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17.657 16.657L13.414 20.9a1.998 1.998 0 01-2.827 0l-4.244-4.243a8 8 0 1111.314 0z"></path>
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 11a3 3 0 11-6 0 3 3 0 016 0z"></path>
                            </svg>
                            <div class="flex-1">
                                <p class="text-sm text-gray-500 mb-1">Bairro / Cidade</p>
                                <p id="modal-address-location" class="font-medium text-gray-800"></p>
                            </div>
                        </div>
                        
                    </div>
                </div>
            </div>
            
            <!-- Footer / Actions -->
            <div id="my-address-actions" class="hidden border-t p-6 bg-gray-50 flex gap-3">
                <button onclick="closeMyAddressModal()" class="flex-1 px-4 py-3 rounded-lg font-medium text-gray-700 bg-white border border-gray-300 hover:bg-gray-50 transition-colors">
                    Cancelar
                </button>
                <button onclick="confirmUseAddress()" class="flex-1 px-4 py-3 rounded-lg font-medium text-white transition-colors" style="background-color: var(--cor-primaria);" onmouseover="this.style.opacity='0.9'" onmouseout="this.style.opacity='1'">
                    ✓ Usar este endereço
                </button>
            </div>
        </div>
    </div>
</div>

<!-- Modal: Cadastro de Endereço (após signup) -->
<div id="signup-address-modal" class="fixed inset-0 z-[1000] hidden" style="touch-action: none;">
    <div class="absolute inset-0 bg-black/60 backdrop-blur-sm"></div>
    <div class="relative z-[1001] h-full flex items-center justify-center p-4" style="pointer-events: none;">
        <div class="bg-white rounded-2xl shadow-2xl overflow-hidden max-w-lg w-full max-h-[90vh] flex flex-col" style="pointer-events: auto; touch-action: pan-y;">
            <!-- Header -->
            <div class="p-6 text-white" style="background: linear-gradient(to right, var(--cor-primaria), var(--cor-primaria));">
                <div class="flex items-center justify-between">
                    <div class="flex items-center space-x-3">
                        <div class="w-12 h-12 rounded-full bg-white/20 backdrop-blur-sm flex items-center justify-center">
                            <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17.657 16.657L13.414 20.9a1.998 1.998 0 01-2.827 0l-4.244-4.243a8 8 0 1111.314 0z"></path>
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 11a3 3 0 11-6 0 3 3 0 016 0z"></path>
                            </svg>
                        </div>
                        <div>
                            <h2 class="text-xl font-bold">Meu Endereço</h2>
                            <p class="text-sm" style="color: rgba(255, 255, 255, 0.9);">Complete seu cadastro com o endereço de entrega</p>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Conteúdo -->
            <div class="flex-1 overflow-y-auto p-6" style="-webkit-overflow-scrolling: touch; overscroll-behavior: contain;">
                <form id="signup-address-form" class="space-y-4">
                    <div>
                        <label class="block text-sm font-medium text-gray-700 mb-1">Número *</label>
                        <input id="signup-numero" type="text" placeholder="123" required class="w-full px-4 py-3 rounded-lg bg-gray-50 border border-gray-300 focus:ring-2 focus:border-transparent transition-all" style="--tw-ring-color: var(--cor-primaria);">
                    </div>
                    <div>
                        <label class="block text-sm font-medium text-gray-700 mb-1">Rua *</label>
                        <input id="signup-rua" type="text" placeholder="Nome da rua" required class="w-full px-4 py-3 rounded-lg bg-gray-50 border border-gray-300 focus:ring-2 focus:border-transparent transition-all" style="--tw-ring-color: var(--cor-primaria);">
                    </div>
                    <div class="grid grid-cols-2 gap-3">
                        <div>
                            <label class="block text-sm font-medium text-gray-700 mb-1">Bairro *</label>
                            <select id="signup-bairro" required class="w-full px-4 py-3 rounded-lg bg-gray-50 border border-gray-300 focus:ring-2 focus:border-transparent transition-all" style="--tw-ring-color: var(--cor-primaria);" onchange="handleSignupBairroChange()">
                                <option value="">Selecione o bairro</option>
                            </select>
                        </div>
                        <div>
                            <label class="block text-sm font-medium text-gray-700 mb-1">Cidade *</label>
                            <input id="signup-cidade" type="text" placeholder="Cidade" required class="w-full px-4 py-3 rounded-lg bg-gray-50 border border-gray-300 focus:ring-2 focus:border-transparent transition-all" style="--tw-ring-color: var(--cor-primaria);">
                        </div>
                    </div>
                    <div>
                        <label class="block text-sm font-medium text-gray-700 mb-1">Complemento (opcional)</label>
                        <input id="signup-complemento" type="text" placeholder="Apto, bloco, etc." class="w-full px-4 py-3 rounded-lg bg-gray-50 border border-gray-300 focus:ring-2 focus:border-transparent transition-all" style="--tw-ring-color: var(--cor-primaria);">
                    </div>
                    
                    <p id="signup-address-error" class="text-sm text-red-600 hidden mt-2"></p>
                    <p id="signup-address-success" class="text-sm text-green-600 hidden mt-2"></p>
                    
                    <button id="signup-address-submit" type="submit" 
                            class="w-full px-4 py-3 font-semibold text-white rounded-lg transition-all hover:opacity-90" 
                            style="background: var(--cor-primaria);">
                        Finalizar Cadastro
                    </button>
                </form>
            </div>
        </div>
    </div>
</div>

<script>
// ====================================================================
// SISTEMA DE PERFIL DO CLIENTE
// ====================================================================

let currentUserAddress = null;

function openProfileModal() {
    document.getElementById('profile-modal').classList.remove('hidden');
    loadUserProfile();
}

function closeProfileModal() {
    document.getElementById('profile-modal').classList.add('hidden');
    cancelAddressEdit();
    // Limpar subscriptions e polling de pedidos
    cleanupOrdersUpdates();
}

async function loadUserProfile() {
    debugLog('🔄 Carregando perfil do usuário...');
    
    const { data: { session } } = await supabase.auth.getSession();
    if (!session) {
        console.error('❌ Sessão não encontrada ao carregar perfil');
        return;
    }
    
    debugLog('✅ Sessão encontrada:', session.user.email);
    debugLog('👤 User ID:', session.user.id);
    
    // Mostrar email do usuário
    const emailElement = document.getElementById('profile-user-email');
    if (emailElement) {
        emailElement.textContent = session.user.email;
        debugLog('✅ Email exibido no perfil');
    }
    
    // Carregar dados pessoais do usuário
    debugLog('👤 Carregando dados pessoais...');
    await loadUserPersonalData(session.user.id);
    
    // Carregar endereço do usuário
    debugLog('📍 Carregando endereço...');
    await loadUserAddress(session.user.id);
    
    // Carregar histórico de pedidos
    debugLog('📦 Carregando histórico de pedidos...');
    await loadUserOrders(session.user.id);
    debugLog('✅ Perfil carregado completamente!');
}

let currentUserPersonalData = null;

async function loadUserPersonalData(userId) {
    try {
        const { data, error } = await supabase
            .from('clientes')
            .select('*')
            .eq('user_id', userId)
            .single();
        
        if (error && error.code !== 'PGRST116') {
            console.error('Erro ao carregar dados pessoais:', error);
            throw error;
        }
        
        if (data) {
            currentUserPersonalData = data;
            displayPersonalData(data);
            debugLog('✅ Dados pessoais carregados:', data);
        } else {
            // Usuário não tem perfil - mostrar dados do Auth
            debugLog('⚠️ Perfil não encontrado - usando dados do Auth');
            const { data: { user } } = await supabase.auth.getUser();
            if (user) {
                document.getElementById('personal-nome-text').textContent = user.user_metadata?.full_name || 'Não informado';
                document.getElementById('personal-telefone-text').textContent = user.user_metadata?.phone || 'Não informado';
            }
        }
    } catch (error) {
        console.error('Erro ao carregar dados pessoais:', error);
        document.getElementById('personal-nome-text').textContent = 'Erro ao carregar';
        document.getElementById('personal-telefone-text').textContent = 'Erro ao carregar';
    }
}

// Função createUserProfile removida - não criamos mais perfis automaticamente
// Os dados só são salvos quando o usuário completa o cadastro com endereço

async function loadUserAddress(userId) {
    try {
        // Agora o endereço está na mesma tabela clientes
        const { data, error } = await supabase
            .from('clientes')
            .select('*')
            .eq('user_id', userId)
            .maybeSingle();
        
        if (error) throw error;
        
        if (data) {
            currentUserAddress = data;
            displayAddress(data);
            debugLog('✅ Endereço carregado:', data);
        } else {
            document.getElementById('address-text').innerHTML = 'Nenhum endereço cadastrado';
            debugLog('ℹ️ Nenhum endereço encontrado');
        }
    } catch (error) {
        console.error('Erro ao carregar endereço:', error);
        document.getElementById('address-text').textContent = 'Erro ao carregar endereço';
    }
}

function displayAddress(address) {
    const addressText = document.getElementById('address-text');
    if (address) {
        addressText.innerHTML = `
            <p class="font-medium text-gray-800">${address.rua}, ${address.numero}</p>
            ${address.complemento ? `<p class="text-sm text-gray-600">${address.complemento}</p>` : ''}
            <p class="text-sm text-gray-600">${address.bairro} - ${address.cidade}</p>
        `;
    } else {
        addressText.textContent = 'Nenhum endereço cadastrado';
    }
}

function displayPersonalData(data) {
    // Exibir nome
    const nomeText = document.getElementById('personal-nome-text');
    if (nomeText) {
        nomeText.textContent = data.nome_completo || 'Não informado';
    }
    
    // Exibir telefone formatado
    const telefoneText = document.getElementById('personal-telefone-text');
    if (telefoneText) {
        if (data.telefone) {
            // Formatar telefone
            let tel = data.telefone.replace(/\D/g, '');
            if (tel.startsWith('55') && tel.length > 11) {
                tel = tel.substring(2);
            }
            if (tel.length === 11) {
                tel = `(${tel.substring(0, 2)}) ${tel.substring(2, 3)} ${tel.substring(3, 7)}-${tel.substring(7)}`;
            } else if (tel.length === 10) {
                tel = `(${tel.substring(0, 2)}) ${tel.substring(2, 6)}-${tel.substring(6)}`;
            }
            telefoneText.textContent = tel;
        } else {
            telefoneText.textContent = 'Não informado';
        }
    }
}

function togglePersonalEdit() {
    const display = document.getElementById('personal-display');
    const form = document.getElementById('personal-form');
    const btn = document.getElementById('edit-personal-btn');
    
    if (form.classList.contains('hidden')) {
        // Preencher formulário com dados atuais
        if (currentUserPersonalData) {
            document.getElementById('profile-nome').value = currentUserPersonalData.nome_completo || '';
            document.getElementById('profile-telefone').value = currentUserPersonalData.telefone || '';
        }
        display.classList.add('hidden');
        form.classList.remove('hidden');
        btn.textContent = 'Cancelar';
    } else {
        cancelPersonalEdit();
    }
}

function cancelPersonalEdit() {
    const display = document.getElementById('personal-display');
    const form = document.getElementById('personal-form');
    const btn = document.getElementById('edit-personal-btn');
    
    display.classList.remove('hidden');
    form.classList.add('hidden');
    btn.textContent = 'Editar';
    
    // Limpar mensagens
    document.getElementById('personal-save-error').classList.add('hidden');
    document.getElementById('personal-save-success').classList.add('hidden');
}

// ====================================================================
// FUNÇÃO: POPULAR SELECT DE BAIRROS NO PERFIL
// ====================================================================
// Preenche o select de bairros com os dados da planilha (neighborhoodsList)
// Igual ao funcionamento do checkout
function populateProfileBairroSelect() {
    const bairroSelect = document.getElementById('profile-bairro');
    if (!bairroSelect) return;
    
    // Limpar opções existentes (exceto a primeira)
    bairroSelect.innerHTML = '<option value="">Selecione o bairro</option>';
    
    // Verificar se temos a lista de bairros carregada
    if (typeof neighborhoodsList !== 'undefined' && neighborhoodsList.length > 0) {
        neighborhoodsList.forEach(item => {
            const option = document.createElement('option');
            option.value = item.nome;
            option.textContent = item.nome.charAt(0).toUpperCase() + item.nome.slice(1);
            bairroSelect.appendChild(option);
        });
        debugLog('✅ Select de bairros populado no perfil com', neighborhoodsList.length, 'bairros');
    } else {
        debugLog('⚠️ Lista de bairros não disponível ainda');
    }
}

// Handler para mudança de bairro no perfil
function handleProfileBairroChange() {
    const bairroSelect = document.getElementById('profile-bairro');
    const selectedBairro = bairroSelect.value;
    
    if (selectedBairro) {
        debugLog('🏘️ Bairro selecionado no perfil:', selectedBairro);
        
        // Buscar informações do bairro (taxa, cidade, etc)
        if (typeof neighborhoodsList !== 'undefined') {
            const bairroInfo = neighborhoodsList.find(b => b.nome === selectedBairro);
            if (bairroInfo && bairroInfo.cidade) {
                // Preencher cidade automaticamente
                const cidadeInput = document.getElementById('profile-cidade');
                if (cidadeInput) {
                    cidadeInput.value = bairroInfo.cidade;
                    debugLog('✅ Cidade preenchida automaticamente:', bairroInfo.cidade);
                }
            }
        }
    }
}

function toggleAddressEdit() {
    const display = document.getElementById('address-display');
    const form = document.getElementById('address-form');
    const btn = document.getElementById('edit-address-btn');
    
    if (form.classList.contains('hidden')) {
        // Popular select de bairros
        populateProfileBairroSelect();
        
        // Preencher formulário com dados atuais
        if (currentUserAddress) {
            document.getElementById('profile-rua').value = currentUserAddress.rua || '';
            document.getElementById('profile-numero').value = currentUserAddress.numero || '';
            document.getElementById('profile-bairro').value = currentUserAddress.bairro || '';
            document.getElementById('profile-cidade').value = currentUserAddress.cidade || '';
            document.getElementById('profile-complemento').value = currentUserAddress.complemento || '';
        }
        display.classList.add('hidden');
        form.classList.remove('hidden');
        btn.textContent = 'Cancelar';
    } else {
        cancelAddressEdit();
    }
}

function cancelAddressEdit() {
    const display = document.getElementById('address-display');
    const form = document.getElementById('address-form');
    const btn = document.getElementById('edit-address-btn');
    
    display.classList.remove('hidden');
    form.classList.add('hidden');
    btn.textContent = 'Editar';
    
    // Limpar mensagens
    document.getElementById('address-save-error').classList.add('hidden');
    document.getElementById('address-save-success').classList.add('hidden');
}

// Handler para salvar dados pessoais
document.getElementById('personal-form').addEventListener('submit', async (e) => {
    e.preventDefault();
    
    const { data: { session } } = await supabase.auth.getSession();
    if (!session) return;
    
    const errorMsg = document.getElementById('personal-save-error');
    const successMsg = document.getElementById('personal-save-success');
    
    const nome = document.getElementById('profile-nome').value.trim();
    const telefone = document.getElementById('profile-telefone').value.trim();
    
    if (!nome) {
        errorMsg.textContent = 'Nome é obrigatório';
        errorMsg.classList.remove('hidden');
        return;
    }
    
    const personalData = {
        user_id: session.user.id,
        nome_completo: nome,
        telefone: telefone
    };
    
    try {
        debugLog('💾 Salvando dados pessoais na tabela clientes:', personalData);
        
        const { data, error } = await supabase
            .from('clientes')
            .upsert(personalData, { onConflict: 'user_id' })
            .select()
            .single();
        
        if (error) throw error;
        
        currentUserPersonalData = data;
        displayPersonalData(data);
        
        debugLog('✅ Dados pessoais salvos com sucesso!');
        
        successMsg.textContent = 'Dados salvos com sucesso!';
        successMsg.classList.remove('hidden');
        errorMsg.classList.add('hidden');
        
        setTimeout(() => {
            cancelPersonalEdit();
        }, 1500);
        
    } catch (error) {
        console.error('Erro ao salvar dados pessoais:', error);
        errorMsg.textContent = 'Erro ao salvar dados. Tente novamente.';
        errorMsg.classList.remove('hidden');
        successMsg.classList.add('hidden');
    }
});

// Handler para salvar endereço
document.getElementById('address-form').addEventListener('submit', async (e) => {
    e.preventDefault();
    
    const { data: { session } } = await supabase.auth.getSession();
    if (!session) return;
    
    const errorMsg = document.getElementById('address-save-error');
    const successMsg = document.getElementById('address-save-success');
    
    // Validar campos obrigatórios
    const rua = document.getElementById('profile-rua').value.trim();
    const numero = document.getElementById('profile-numero').value.trim();
    const bairro = document.getElementById('profile-bairro').value.trim();
    const cidade = document.getElementById('profile-cidade').value.trim();
    
    if (!rua || !numero || !bairro || !cidade) {
        errorMsg.textContent = 'Preencha todos os campos obrigatórios (*).';
        errorMsg.classList.remove('hidden');
        successMsg.classList.add('hidden');
        return;
    }
    
    const addressData = {
        user_id: session.user.id,
        // Campo removido da interface, mas mantido vazio para compatibilidade com o banco
        rua: rua,
        numero: numero,
        bairro: bairro,
        cidade: cidade,
        complemento: document.getElementById('profile-complemento').value.trim()
    };
    
    try {
        // Agora salvamos o endereço na mesma tabela clientes
        const { data, error } = await supabase
            .from('clientes')
            .upsert(addressData, { onConflict: 'user_id' })
            .select()
            .maybeSingle();
        
        if (error) throw error;
        
        currentUserAddress = data;
        displayAddress(data);
        
        successMsg.textContent = 'Endereço salvo com sucesso!';
        successMsg.classList.remove('hidden');
        errorMsg.classList.add('hidden');
        
        setTimeout(() => {
            cancelAddressEdit();
        }, 1500);
        
    } catch (error) {
        console.error('Erro ao salvar endereço:', error);
        errorMsg.textContent = 'Erro ao salvar endereço. Tente novamente.';
        errorMsg.classList.remove('hidden');
        successMsg.classList.add('hidden');
    }
});

// Remover máscara de CEP (campo removido)

// Variáveis globais para gerenciar atualizações de pedidos
let ordersSubscription = null;
let ordersPollingInterval = null;
let currentUserId = null;

// Função auxiliar para renderizar um pedido
function renderOrderCard(order) {
    const date = new Date(order.created_at).toLocaleDateString('pt-BR');
    const time = new Date(order.created_at).toLocaleTimeString('pt-BR', { hour: '2-digit', minute: '2-digit' });
    
    // Mapeamento de cores e textos para os status reais do sistema
    const statusColors = {
        'Novo': 'bg-yellow-100 text-yellow-800',
        'Em Preparo': 'bg-blue-100 text-blue-800',
        'Finalizado': 'bg-green-100 text-green-800',
        'Cancelado': 'bg-red-100 text-red-800'
    };
    
    const statusIcons = {
        'Novo': '📝',
        'Em Preparo': '👨‍🍳',
        'Finalizado': '✅',
        'Cancelado': '❌'
    };
    
    const deliveryTypeText = {
        'delivery': '🛵 Delivery',
        'pickup': '🏪 Retirada',
        'default': '🍽️ Mesa'
    };
    
    return `
        <div class="bg-white rounded-lg p-4 border border-gray-200 hover:shadow-md transition-all cursor-pointer" 
             data-order-id="${order.order_id}" 
             onclick="openTrackingModalWithOrder('${order.order_id}')">
            <div class="flex justify-between items-start mb-2">
                <div>
                    <p class="font-semibold text-gray-800">Pedido #${order.order_id}</p>
                    <p class="text-xs text-gray-500">${date} às ${time}</p>
                </div>
                <span class="order-status px-2 py-1 rounded-full text-xs font-medium ${statusColors[order.status] || 'bg-gray-100 text-gray-800'}" 
                      data-status="${order.status}">
                    ${statusIcons[order.status] || ''} ${order.status}
                </span>
            </div>
            <div class="flex justify-between items-center mt-3 pt-3 border-t border-gray-100">
                <span class="text-sm text-gray-600">${deliveryTypeText[order.delivery_type] || deliveryTypeText['default']}</span>
                <span class="font-bold" style="color: var(--cor-secundaria);">R$ ${parseFloat(order.total).toFixed(2)}</span>
            </div>
        </div>
    `;
}

// Função para atualizar apenas o status de um pedido específico
function updateOrderStatus(orderId, newStatus) {
    const orderCard = document.querySelector(`[data-order-id="${orderId}"]`);
    if (!orderCard) return;
    
    const statusElement = orderCard.querySelector('.order-status');
    if (!statusElement) return;
    
    const currentStatus = statusElement.getAttribute('data-status');
    if (currentStatus === newStatus) return; // Sem mudança
    
    // Mapeamento de cores e ícones
    const statusColors = {
        'Novo': 'bg-yellow-100 text-yellow-800',
        'Em Preparo': 'bg-blue-100 text-blue-800',
        'Finalizado': 'bg-green-100 text-green-800',
        'Cancelado': 'bg-red-100 text-red-800'
    };
    
    const statusIcons = {
        'Novo': '📝',
        'Em Preparo': '👨‍🍳',
        'Finalizado': '✅',
        'Cancelado': '❌'
    };
    
    // Animação de atualização
    orderCard.classList.add('ring-2', 'ring-blue-400', 'animate-pulse');
    
    // Atualizar o status
    statusElement.className = `order-status px-2 py-1 rounded-full text-xs font-medium ${statusColors[newStatus] || 'bg-gray-100 text-gray-800'}`;
    statusElement.setAttribute('data-status', newStatus);
    statusElement.innerHTML = `${statusIcons[newStatus] || ''} ${newStatus}`;
    
    // Remover animação após 2 segundos
    setTimeout(() => {
        orderCard.classList.remove('ring-2', 'ring-blue-400', 'animate-pulse');
    }, 2000);
    
    debugLog(`🔄 Status do pedido #${orderId} atualizado: ${currentStatus} → ${newStatus}`);
}

// Função para configurar realtime subscription
function setupOrdersRealtime(userId) {
    // Remover subscription anterior se existir
    if (ordersSubscription) {
        supabase.removeChannel(ordersSubscription);
        ordersSubscription = null;
    }
    
    // Criar nova subscription
    ordersSubscription = supabase
        .channel('user-orders-changes')
        .on(
            'postgres_changes',
            {
                event: 'UPDATE',
                schema: 'public',
                table: 'pedidos',
                filter: `user_id=eq.${userId}`
            },
            (payload) => {
                debugLog('🔔 Atualização de pedido recebida:', payload);
                if (payload.new && payload.new.order_id) {
                    updateOrderStatus(payload.new.order_id, payload.new.status);
                    
                    // Notificação visual opcional
                    showOrderUpdateNotification(payload.new.order_id, payload.new.status);
                }
            }
        )
        .subscribe((status) => {
            if (status === 'SUBSCRIBED') {
                debugLog('✅ Realtime ativo para pedidos do usuário');
            }
        });
}

// Função para mostrar notificação de atualização
function showOrderUpdateNotification(orderId, status) {
    const notification = document.createElement('div');
    notification.className = 'fixed top-20 right-4 bg-blue-500 text-white px-4 py-3 rounded-lg shadow-lg z-50 animate-slide-in';
    notification.innerHTML = `
        <div class="flex items-center gap-2">
            <span class="text-xl">🔔</span>
            <div>
                <p class="font-semibold">Pedido #${orderId}</p>
                <p class="text-sm">Status: ${status}</p>
            </div>
        </div>
    `;
    
    document.body.appendChild(notification);
    
    // Remover após 4 segundos
    setTimeout(() => {
        notification.style.opacity = '0';
        notification.style.transform = 'translateX(100%)';
        setTimeout(() => notification.remove(), 300);
    }, 4000);
}

// Função para polling inteligente (apenas pedidos ativos)
async function startOrdersPolling(userId) {
    // Limpar polling anterior
    if (ordersPollingInterval) {
        clearInterval(ordersPollingInterval);
        ordersPollingInterval = null;
    }
    
    // Polling a cada 30 segundos para pedidos ativos
    ordersPollingInterval = setInterval(async () => {
        try {
            // Buscar apenas pedidos ativos (Novo ou Em Preparo)
            const { data, error } = await supabase
                .from('pedidos')
                .select('order_id, status')
                .eq('user_id', userId)
                .in('status', ['Novo', 'Em Preparo'])
                .order('created_at', { ascending: false });
            
            if (error) throw error;
            
            // Atualizar status de cada pedido ativo
            if (data && data.length > 0) {
                data.forEach(order => {
                    updateOrderStatus(order.order_id, order.status);
                });
                debugLog(`🔄 Polling: ${data.length} pedidos ativos verificados`);
            } else {
                // Se não há pedidos ativos, parar o polling
                debugLog('⏸️ Nenhum pedido ativo, pausando polling');
                clearInterval(ordersPollingInterval);
                ordersPollingInterval = null;
            }
        } catch (error) {
            console.error('❌ Erro no polling de pedidos:', error);
        }
    }, 30000); // 30 segundos
}

// Função principal para carregar pedidos
async function loadUserOrders(userId) {
    const ordersList = document.getElementById('orders-list');
    
    if (!ordersList) {
        console.error('❌ Elemento orders-list não encontrado');
        return;
    }
    
    // Salvar userId atual
    currentUserId = userId;
    
    try {
        debugLog('🔍 Carregando pedidos do usuário:', userId);
        
        const { data, error } = await supabase
            .from('pedidos')
            .select('*')
            .eq('user_id', userId)
            .order('created_at', { ascending: false })
            .limit(20);
        
        if (error) {
            console.error('❌ Erro ao buscar pedidos:', error);
            throw error;
        }
        
        debugLog('📦 Pedidos encontrados:', data?.length || 0);
        
        if (data && data.length > 0) {
            ordersList.innerHTML = data.map(order => renderOrderCard(order)).join('');
            debugLog('✅ Pedidos renderizados com sucesso!');
            
            // Configurar realtime e polling
            setupOrdersRealtime(userId);
            
            // Verificar se há pedidos ativos para iniciar polling
            const hasActiveOrders = data.some(order => 
                order.status === 'Novo' || order.status === 'Em Preparo'
            );
            
            if (hasActiveOrders) {
                startOrdersPolling(userId);
                debugLog('🔄 Polling iniciado para pedidos ativos');
            }
        } else {
            ordersList.innerHTML = `
                <div class="text-center py-8">
                    <svg class="w-16 h-16 mx-auto text-gray-300 mb-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2"></path>
                    </svg>
                    <p class="text-gray-600">Você ainda não fez nenhum pedido</p>
                    <p class="text-sm text-gray-500 mt-2">Faça seu primeiro pedido e acompanhe aqui!</p>
                </div>
            `;
            debugLog('ℹ️ Nenhum pedido encontrado para este usuário');
        }
    } catch (error) {
        console.error('❌ Erro ao carregar pedidos:', error);
        ordersList.innerHTML = `
            <div class="text-center py-8">
                <svg class="w-16 h-16 mx-auto text-red-300 mb-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                </svg>
                <p class="text-red-600">Erro ao carregar pedidos</p>
                <p class="text-sm text-gray-500 mt-2">Tente novamente mais tarde</p>
            </div>
        `;
    }
}

// Função para limpar subscriptions e polling quando o modal é fechado
function cleanupOrdersUpdates() {
    if (ordersSubscription) {
        supabase.removeChannel(ordersSubscription);
        ordersSubscription = null;
        debugLog('🧹 Realtime de pedidos desconectado');
    }
    
    if (ordersPollingInterval) {
        clearInterval(ordersPollingInterval);
        ordersPollingInterval = null;
        debugLog('🧹 Polling de pedidos parado');
    }
}

// Função para abrir modal de rastreamento com um pedido específico
function openTrackingModalWithOrder(orderId) {
    openTrackingModal();
    const orderIdInput = document.getElementById('order-id-input');
    if (orderIdInput) {
        orderIdInput.value = orderId;
        trackOrder();
    }
}

async function logout() {
    try {
        // Verificar se há sessão ativa antes de tentar logout
        const { data: { session }, error: sessionError } = await supabase.auth.getSession();
        
        if (sessionError || !session) {
            debugLog('⚠️ Nenhuma sessão ativa para fazer logout');
            // Limpar interface mesmo sem sessão
            updateAuthButtons(null);
            closeProfileModal();
            // Limpar localStorage
            localStorage.removeItem('supabase.auth.token');
            return;
        }
        
        // Confirmação mais amigável
        const confirmLogout = confirm('🚪 Deseja realmente sair da sua conta?\n\nVocê precisará fazer login novamente para acessar seu perfil e fazer pedidos.');
        
        if (!confirmLogout) {
            return;
        }
        
        debugLog('🚪 Iniciando logout...');
        
        // Mostrar overlay de loading
        const loadingOverlay = document.getElementById('auth-loading-overlay');
        const loadingText = document.getElementById('auth-loading-text');
        loadingText.textContent = 'Deslogando...';
        loadingOverlay.classList.add('active');
        
        // Fazer logout no Supabase (scope: 'local' evita requisição ao servidor se não houver sessão)
        const { error } = await supabase.auth.signOut({ scope: 'local' });
        
        if (error) {
            // Remover overlay de loading
            loadingOverlay.classList.remove('active');
            
            // Silenciar erro de sessão ausente
            if (error.message && error.message.includes('Auth session missing')) {
                debugLog('⚠️ Sessão já estava ausente, limpando interface...');
                updateAuthButtons(null);
                closeProfileModal();
                return;
            }
            console.error('❌ Erro ao fazer logout:', error);
            alert('Erro ao sair da conta. Tente novamente.');
            return;
        }
        
        debugLog('✅ Logout realizado com sucesso');
        
        // Limpar formulários
        const loginForm = document.getElementById('auth-form-login');
        const signupForm = document.getElementById('auth-form-signup');
        if (loginForm) loginForm.reset();
        if (signupForm) signupForm.reset();
        
        // Fechar modais
        closeProfileModal();
        closeAuthModal();
        
        // Atualizar botões
        updateAuthButtons(null);
        
        debugLog('👋 Usuário deslogado - recarregando página...');
        
        // Mostrar mensagem de sucesso
       
        
        // Recarregar página para limpar estado
        setTimeout(() => {
            location.reload();
        }, 300);
    } catch (error) {
        // Silenciar erro de sessão ausente
        if (error.message && error.message.includes('Auth session missing')) {
            debugLog('⚠️ Erro capturado: Sessão ausente, limpando interface...');
            updateAuthButtons(null);
            closeProfileModal();
            return;
        }
        console.error('❌ Erro inesperado no logout:', error);
        alert('Erro ao sair da conta. Tente novamente.');
    }
}

// ====================================================================
// PREENCHIMENTO AUTOMÁTICO REMOVIDO
// ====================================================================
// O preenchimento automático foi removido para evitar duplicação.
// Agora o usuário deve usar o botão "Utilizar meu endereço" que abre
// um modal para confirmar antes de preencher os campos.
</script>

<!-- Google API Scripts - IMPORTANTE: erp-integration.js deve vir DEPOIS de env-config.js -->
<script src="erp-integration.js"></script>
<script src="https://apis.google.com/js/api.js" onload="gapiLoaded()"></script>
<script src="https://accounts.google.com/gsi/client" onload="gisLoaded()" async defer></script>

</body>
</html>
